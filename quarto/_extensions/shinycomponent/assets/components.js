var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i6 = decorators.length - 1, decorator; i6 >= 0; i6--)
    if (decorator = decorators[i6])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// node_modules/preact/dist/preact.module.js
function h3(n9, l7) {
  for (var u5 in l7)
    n9[u5] = l7[u5];
  return n9;
}
function p2(n9) {
  var l7 = n9.parentNode;
  l7 && l7.removeChild(n9);
}
function y2(l7, u5, i6) {
  var t6, o8, r6, f4 = {};
  for (r6 in u5)
    "key" == r6 ? t6 = u5[r6] : "ref" == r6 ? o8 = u5[r6] : f4[r6] = u5[r6];
  if (arguments.length > 2 && (f4.children = arguments.length > 3 ? n5.call(arguments, 2) : i6), "function" == typeof l7 && null != l7.defaultProps)
    for (r6 in l7.defaultProps)
      void 0 === f4[r6] && (f4[r6] = l7.defaultProps[r6]);
  return d3(l7, f4, t6, o8, null);
}
function d3(n9, i6, t6, o8, r6) {
  var f4 = { type: n9, props: i6, key: t6, ref: o8, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == r6 ? ++u3 : r6 };
  return null == r6 && null != l4.vnode && l4.vnode(f4), f4;
}
function _2() {
  return { current: null };
}
function k2(n9) {
  return n9.children;
}
function b2(n9, l7) {
  this.props = n9, this.context = l7;
}
function g2(n9, l7) {
  if (null == l7)
    return n9.__ ? g2(n9.__, n9.__.__k.indexOf(n9) + 1) : null;
  for (var u5; l7 < n9.__k.length; l7++)
    if (null != (u5 = n9.__k[l7]) && null != u5.__e)
      return u5.__e;
  return "function" == typeof n9.type ? g2(n9) : null;
}
function m2(n9) {
  var l7, u5;
  if (null != (n9 = n9.__) && null != n9.__c) {
    for (n9.__e = n9.__c.base = null, l7 = 0; l7 < n9.__k.length; l7++)
      if (null != (u5 = n9.__k[l7]) && null != u5.__e) {
        n9.__e = n9.__c.base = u5.__e;
        break;
      }
    return m2(n9);
  }
}
function w2(n9) {
  (!n9.__d && (n9.__d = true) && t3.push(n9) && !x2.__r++ || o5 !== l4.debounceRendering) && ((o5 = l4.debounceRendering) || r4)(x2);
}
function x2() {
  var n9, l7, u5, i6, o8, r6, e9, c9;
  for (t3.sort(f2); n9 = t3.shift(); )
    n9.__d && (l7 = t3.length, i6 = void 0, o8 = void 0, e9 = (r6 = (u5 = n9).__v).__e, (c9 = u5.__P) && (i6 = [], (o8 = h3({}, r6)).__v = r6.__v + 1, L2(c9, r6, o8, u5.__n, void 0 !== c9.ownerSVGElement, null != r6.__h ? [e9] : null, i6, null == e9 ? g2(r6) : e9, r6.__h), M2(i6, r6), r6.__e != e9 && m2(r6)), t3.length > l7 && t3.sort(f2));
  x2.__r = 0;
}
function P2(n9, l7, u5, i6, t6, o8, r6, f4, e9, a7) {
  var h5, p5, y5, _4, b5, m5, w5, x6 = i6 && i6.__k || s5, P5 = x6.length;
  for (u5.__k = [], h5 = 0; h5 < l7.length; h5++)
    if (null != (_4 = u5.__k[h5] = null == (_4 = l7[h5]) || "boolean" == typeof _4 || "function" == typeof _4 ? null : "string" == typeof _4 || "number" == typeof _4 || "bigint" == typeof _4 ? d3(null, _4, null, null, _4) : v2(_4) ? d3(k2, { children: _4 }, null, null, null) : _4.__b > 0 ? d3(_4.type, _4.props, _4.key, _4.ref ? _4.ref : null, _4.__v) : _4)) {
      if (_4.__ = u5, _4.__b = u5.__b + 1, null === (y5 = x6[h5]) || y5 && _4.key == y5.key && _4.type === y5.type)
        x6[h5] = void 0;
      else
        for (p5 = 0; p5 < P5; p5++) {
          if ((y5 = x6[p5]) && _4.key == y5.key && _4.type === y5.type) {
            x6[p5] = void 0;
            break;
          }
          y5 = null;
        }
      L2(n9, _4, y5 = y5 || c3, t6, o8, r6, f4, e9, a7), b5 = _4.__e, (p5 = _4.ref) && y5.ref != p5 && (w5 || (w5 = []), y5.ref && w5.push(y5.ref, null, _4), w5.push(p5, _4.__c || b5, _4)), null != b5 ? (null == m5 && (m5 = b5), "function" == typeof _4.type && _4.__k === y5.__k ? _4.__d = e9 = C2(_4, e9, n9) : e9 = $3(n9, _4, y5, x6, b5, e9), "function" == typeof u5.type && (u5.__d = e9)) : e9 && y5.__e == e9 && e9.parentNode != n9 && (e9 = g2(y5));
    }
  for (u5.__e = m5, h5 = P5; h5--; )
    null != x6[h5] && ("function" == typeof u5.type && null != x6[h5].__e && x6[h5].__e == u5.__d && (u5.__d = A2(i6).nextSibling), q(x6[h5], x6[h5]));
  if (w5)
    for (h5 = 0; h5 < w5.length; h5++)
      O(w5[h5], w5[++h5], w5[++h5]);
}
function C2(n9, l7, u5) {
  for (var i6, t6 = n9.__k, o8 = 0; t6 && o8 < t6.length; o8++)
    (i6 = t6[o8]) && (i6.__ = n9, l7 = "function" == typeof i6.type ? C2(i6, l7, u5) : $3(u5, i6, i6, t6, i6.__e, l7));
  return l7;
}
function S3(n9, l7) {
  return l7 = l7 || [], null == n9 || "boolean" == typeof n9 || (v2(n9) ? n9.some(function(n10) {
    S3(n10, l7);
  }) : l7.push(n9)), l7;
}
function $3(n9, l7, u5, i6, t6, o8) {
  var r6, f4, e9;
  if (void 0 !== l7.__d)
    r6 = l7.__d, l7.__d = void 0;
  else if (null == u5 || t6 != o8 || null == t6.parentNode)
    n:
      if (null == o8 || o8.parentNode !== n9)
        n9.appendChild(t6), r6 = null;
      else {
        for (f4 = o8, e9 = 0; (f4 = f4.nextSibling) && e9 < i6.length; e9 += 1)
          if (f4 == t6)
            break n;
        n9.insertBefore(t6, o8), r6 = o8;
      }
  return void 0 !== r6 ? r6 : t6.nextSibling;
}
function A2(n9) {
  var l7, u5, i6;
  if (null == n9.type || "string" == typeof n9.type)
    return n9.__e;
  if (n9.__k) {
    for (l7 = n9.__k.length - 1; l7 >= 0; l7--)
      if ((u5 = n9.__k[l7]) && (i6 = A2(u5)))
        return i6;
  }
  return null;
}
function H2(n9, l7, u5, i6, t6) {
  var o8;
  for (o8 in u5)
    "children" === o8 || "key" === o8 || o8 in l7 || T2(n9, o8, null, u5[o8], i6);
  for (o8 in l7)
    t6 && "function" != typeof l7[o8] || "children" === o8 || "key" === o8 || "value" === o8 || "checked" === o8 || u5[o8] === l7[o8] || T2(n9, o8, l7[o8], u5[o8], i6);
}
function I2(n9, l7, u5) {
  "-" === l7[0] ? n9.setProperty(l7, null == u5 ? "" : u5) : n9[l7] = null == u5 ? "" : "number" != typeof u5 || a3.test(l7) ? u5 : u5 + "px";
}
function T2(n9, l7, u5, i6, t6) {
  var o8;
  n:
    if ("style" === l7)
      if ("string" == typeof u5)
        n9.style.cssText = u5;
      else {
        if ("string" == typeof i6 && (n9.style.cssText = i6 = ""), i6)
          for (l7 in i6)
            u5 && l7 in u5 || I2(n9.style, l7, "");
        if (u5)
          for (l7 in u5)
            i6 && u5[l7] === i6[l7] || I2(n9.style, l7, u5[l7]);
      }
    else if ("o" === l7[0] && "n" === l7[1])
      o8 = l7 !== (l7 = l7.replace(/Capture$/, "")), l7 = l7.toLowerCase() in n9 ? l7.toLowerCase().slice(2) : l7.slice(2), n9.l || (n9.l = {}), n9.l[l7 + o8] = u5, u5 ? i6 || n9.addEventListener(l7, o8 ? z2 : j2, o8) : n9.removeEventListener(l7, o8 ? z2 : j2, o8);
    else if ("dangerouslySetInnerHTML" !== l7) {
      if (t6)
        l7 = l7.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== l7 && "height" !== l7 && "href" !== l7 && "list" !== l7 && "form" !== l7 && "tabIndex" !== l7 && "download" !== l7 && "rowSpan" !== l7 && "colSpan" !== l7 && l7 in n9)
        try {
          n9[l7] = null == u5 ? "" : u5;
          break n;
        } catch (n10) {
        }
      "function" == typeof u5 || (null == u5 || false === u5 && "-" !== l7[4] ? n9.removeAttribute(l7) : n9.setAttribute(l7, u5));
    }
}
function j2(n9) {
  return this.l[n9.type + false](l4.event ? l4.event(n9) : n9);
}
function z2(n9) {
  return this.l[n9.type + true](l4.event ? l4.event(n9) : n9);
}
function L2(n9, u5, i6, t6, o8, r6, f4, e9, c9) {
  var s8, a7, p5, y5, d6, _4, g6, m5, w5, x6, C5, S4, $5, A6, H4, I4 = u5.type;
  if (void 0 !== u5.constructor)
    return null;
  null != i6.__h && (c9 = i6.__h, e9 = u5.__e = i6.__e, u5.__h = null, r6 = [e9]), (s8 = l4.__b) && s8(u5);
  try {
    n:
      if ("function" == typeof I4) {
        if (m5 = u5.props, w5 = (s8 = I4.contextType) && t6[s8.__c], x6 = s8 ? w5 ? w5.props.value : s8.__ : t6, i6.__c ? g6 = (a7 = u5.__c = i6.__c).__ = a7.__E : ("prototype" in I4 && I4.prototype.render ? u5.__c = a7 = new I4(m5, x6) : (u5.__c = a7 = new b2(m5, x6), a7.constructor = I4, a7.render = B2), w5 && w5.sub(a7), a7.props = m5, a7.state || (a7.state = {}), a7.context = x6, a7.__n = t6, p5 = a7.__d = true, a7.__h = [], a7._sb = []), null == a7.__s && (a7.__s = a7.state), null != I4.getDerivedStateFromProps && (a7.__s == a7.state && (a7.__s = h3({}, a7.__s)), h3(a7.__s, I4.getDerivedStateFromProps(m5, a7.__s))), y5 = a7.props, d6 = a7.state, a7.__v = u5, p5)
          null == I4.getDerivedStateFromProps && null != a7.componentWillMount && a7.componentWillMount(), null != a7.componentDidMount && a7.__h.push(a7.componentDidMount);
        else {
          if (null == I4.getDerivedStateFromProps && m5 !== y5 && null != a7.componentWillReceiveProps && a7.componentWillReceiveProps(m5, x6), !a7.__e && null != a7.shouldComponentUpdate && false === a7.shouldComponentUpdate(m5, a7.__s, x6) || u5.__v === i6.__v) {
            for (u5.__v !== i6.__v && (a7.props = m5, a7.state = a7.__s, a7.__d = false), a7.__e = false, u5.__e = i6.__e, u5.__k = i6.__k, u5.__k.forEach(function(n10) {
              n10 && (n10.__ = u5);
            }), C5 = 0; C5 < a7._sb.length; C5++)
              a7.__h.push(a7._sb[C5]);
            a7._sb = [], a7.__h.length && f4.push(a7);
            break n;
          }
          null != a7.componentWillUpdate && a7.componentWillUpdate(m5, a7.__s, x6), null != a7.componentDidUpdate && a7.__h.push(function() {
            a7.componentDidUpdate(y5, d6, _4);
          });
        }
        if (a7.context = x6, a7.props = m5, a7.__P = n9, S4 = l4.__r, $5 = 0, "prototype" in I4 && I4.prototype.render) {
          for (a7.state = a7.__s, a7.__d = false, S4 && S4(u5), s8 = a7.render(a7.props, a7.state, a7.context), A6 = 0; A6 < a7._sb.length; A6++)
            a7.__h.push(a7._sb[A6]);
          a7._sb = [];
        } else
          do {
            a7.__d = false, S4 && S4(u5), s8 = a7.render(a7.props, a7.state, a7.context), a7.state = a7.__s;
          } while (a7.__d && ++$5 < 25);
        a7.state = a7.__s, null != a7.getChildContext && (t6 = h3(h3({}, t6), a7.getChildContext())), p5 || null == a7.getSnapshotBeforeUpdate || (_4 = a7.getSnapshotBeforeUpdate(y5, d6)), P2(n9, v2(H4 = null != s8 && s8.type === k2 && null == s8.key ? s8.props.children : s8) ? H4 : [H4], u5, i6, t6, o8, r6, f4, e9, c9), a7.base = u5.__e, u5.__h = null, a7.__h.length && f4.push(a7), g6 && (a7.__E = a7.__ = null), a7.__e = false;
      } else
        null == r6 && u5.__v === i6.__v ? (u5.__k = i6.__k, u5.__e = i6.__e) : u5.__e = N2(i6.__e, u5, i6, t6, o8, r6, f4, c9);
    (s8 = l4.diffed) && s8(u5);
  } catch (n10) {
    u5.__v = null, (c9 || null != r6) && (u5.__e = e9, u5.__h = !!c9, r6[r6.indexOf(e9)] = null), l4.__e(n10, u5, i6);
  }
}
function M2(n9, u5) {
  l4.__c && l4.__c(u5, n9), n9.some(function(u6) {
    try {
      n9 = u6.__h, u6.__h = [], n9.some(function(n10) {
        n10.call(u6);
      });
    } catch (n10) {
      l4.__e(n10, u6.__v);
    }
  });
}
function N2(l7, u5, i6, t6, o8, r6, f4, e9) {
  var s8, a7, h5, y5 = i6.props, d6 = u5.props, _4 = u5.type, k6 = 0;
  if ("svg" === _4 && (o8 = true), null != r6) {
    for (; k6 < r6.length; k6++)
      if ((s8 = r6[k6]) && "setAttribute" in s8 == !!_4 && (_4 ? s8.localName === _4 : 3 === s8.nodeType)) {
        l7 = s8, r6[k6] = null;
        break;
      }
  }
  if (null == l7) {
    if (null === _4)
      return document.createTextNode(d6);
    l7 = o8 ? document.createElementNS("http://www.w3.org/2000/svg", _4) : document.createElement(_4, d6.is && d6), r6 = null, e9 = false;
  }
  if (null === _4)
    y5 === d6 || e9 && l7.data === d6 || (l7.data = d6);
  else {
    if (r6 = r6 && n5.call(l7.childNodes), a7 = (y5 = i6.props || c3).dangerouslySetInnerHTML, h5 = d6.dangerouslySetInnerHTML, !e9) {
      if (null != r6)
        for (y5 = {}, k6 = 0; k6 < l7.attributes.length; k6++)
          y5[l7.attributes[k6].name] = l7.attributes[k6].value;
      (h5 || a7) && (h5 && (a7 && h5.__html == a7.__html || h5.__html === l7.innerHTML) || (l7.innerHTML = h5 && h5.__html || ""));
    }
    if (H2(l7, d6, y5, o8, e9), h5)
      u5.__k = [];
    else if (P2(l7, v2(k6 = u5.props.children) ? k6 : [k6], u5, i6, t6, o8 && "foreignObject" !== _4, r6, f4, r6 ? r6[0] : i6.__k && g2(i6, 0), e9), null != r6)
      for (k6 = r6.length; k6--; )
        null != r6[k6] && p2(r6[k6]);
    e9 || ("value" in d6 && void 0 !== (k6 = d6.value) && (k6 !== l7.value || "progress" === _4 && !k6 || "option" === _4 && k6 !== y5.value) && T2(l7, "value", k6, y5.value, false), "checked" in d6 && void 0 !== (k6 = d6.checked) && k6 !== l7.checked && T2(l7, "checked", k6, y5.checked, false));
  }
  return l7;
}
function O(n9, u5, i6) {
  try {
    "function" == typeof n9 ? n9(u5) : n9.current = u5;
  } catch (n10) {
    l4.__e(n10, i6);
  }
}
function q(n9, u5, i6) {
  var t6, o8;
  if (l4.unmount && l4.unmount(n9), (t6 = n9.ref) && (t6.current && t6.current !== n9.__e || O(t6, null, u5)), null != (t6 = n9.__c)) {
    if (t6.componentWillUnmount)
      try {
        t6.componentWillUnmount();
      } catch (n10) {
        l4.__e(n10, u5);
      }
    t6.base = t6.__P = null, n9.__c = void 0;
  }
  if (t6 = n9.__k)
    for (o8 = 0; o8 < t6.length; o8++)
      t6[o8] && q(t6[o8], u5, i6 || "function" != typeof n9.type);
  i6 || null == n9.__e || p2(n9.__e), n9.__ = n9.__e = n9.__d = void 0;
}
function B2(n9, l7, u5) {
  return this.constructor(n9, u5);
}
function D(u5, i6, t6) {
  var o8, r6, f4;
  l4.__ && l4.__(u5, i6), r6 = (o8 = "function" == typeof t6) ? null : t6 && t6.__k || i6.__k, f4 = [], L2(i6, u5 = (!o8 && t6 || i6).__k = y2(k2, null, [u5]), r6 || c3, c3, void 0 !== i6.ownerSVGElement, !o8 && t6 ? [t6] : r6 ? null : i6.firstChild ? n5.call(i6.childNodes) : null, f4, !o8 && t6 ? t6 : r6 ? r6.__e : i6.firstChild, o8), M2(f4, u5);
}
function E2(n9, l7) {
  D(n9, l7, E2);
}
function F(l7, u5, i6) {
  var t6, o8, r6, f4, e9 = h3({}, l7.props);
  for (r6 in l7.type && l7.type.defaultProps && (f4 = l7.type.defaultProps), u5)
    "key" == r6 ? t6 = u5[r6] : "ref" == r6 ? o8 = u5[r6] : e9[r6] = void 0 === u5[r6] && void 0 !== f4 ? f4[r6] : u5[r6];
  return arguments.length > 2 && (e9.children = arguments.length > 3 ? n5.call(arguments, 2) : i6), d3(l7.type, e9, t6 || l7.key, o8 || l7.ref, null);
}
function G(n9, l7) {
  var u5 = { __c: l7 = "__cC" + e4++, __: n9, Consumer: function(n10, l8) {
    return n10.children(l8);
  }, Provider: function(n10) {
    var u6, i6;
    return this.getChildContext || (u6 = [], (i6 = {})[l7] = this, this.getChildContext = function() {
      return i6;
    }, this.shouldComponentUpdate = function(n11) {
      this.props.value !== n11.value && u6.some(function(n12) {
        n12.__e = true, w2(n12);
      });
    }, this.sub = function(n11) {
      u6.push(n11);
      var l8 = n11.componentWillUnmount;
      n11.componentWillUnmount = function() {
        u6.splice(u6.indexOf(n11), 1), l8 && l8.call(n11);
      };
    }), n10.children;
  } };
  return u5.Provider.__ = u5.Consumer.contextType = u5;
}
var n5, l4, u3, i3, t3, o5, r4, f2, e4, c3, s5, a3, v2;
var init_preact_module = __esm({
  "node_modules/preact/dist/preact.module.js"() {
    c3 = {};
    s5 = [];
    a3 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
    v2 = Array.isArray;
    n5 = s5.slice, l4 = { __e: function(n9, l7, u5, i6) {
      for (var t6, o8, r6; l7 = l7.__; )
        if ((t6 = l7.__c) && !t6.__)
          try {
            if ((o8 = t6.constructor) && null != o8.getDerivedStateFromError && (t6.setState(o8.getDerivedStateFromError(n9)), r6 = t6.__d), null != t6.componentDidCatch && (t6.componentDidCatch(n9, i6 || {}), r6 = t6.__d), r6)
              return t6.__E = t6;
          } catch (l8) {
            n9 = l8;
          }
      throw n9;
    } }, u3 = 0, i3 = function(n9) {
      return null != n9 && void 0 === n9.constructor;
    }, b2.prototype.setState = function(n9, l7) {
      var u5;
      u5 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h3({}, this.state), "function" == typeof n9 && (n9 = n9(h3({}, u5), this.props)), n9 && h3(u5, n9), null != n9 && this.__v && (l7 && this._sb.push(l7), w2(this));
    }, b2.prototype.forceUpdate = function(n9) {
      this.__v && (this.__e = true, n9 && this.__h.push(n9), w2(this));
    }, b2.prototype.render = k2, t3 = [], r4 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f2 = function(n9, l7) {
      return n9.__v.__b - l7.__v.__b;
    }, x2.__r = 0, e4 = 0;
  }
});

// node_modules/preact/hooks/dist/hooks.module.js
function d4(t6, u5) {
  l4.__h && l4.__h(r5, t6, o6 || u5), o6 = 0;
  var i6 = r5.__H || (r5.__H = { __: [], __h: [] });
  return t6 >= i6.__.length && i6.__.push({ __V: c4 }), i6.__[t6];
}
function h4(n9) {
  return o6 = 1, s6(B3, n9);
}
function s6(n9, u5, i6) {
  var o8 = d4(t4++, 2);
  if (o8.t = n9, !o8.__c && (o8.__ = [i6 ? i6(u5) : B3(void 0, u5), function(n10) {
    var t6 = o8.__N ? o8.__N[0] : o8.__[0], r6 = o8.t(t6, n10);
    t6 !== r6 && (o8.__N = [r6, o8.__[1]], o8.__c.setState({}));
  }], o8.__c = r5, !r5.u)) {
    var f4 = function(n10, t6, r6) {
      if (!o8.__c.__H)
        return true;
      var u6 = o8.__c.__H.__.filter(function(n11) {
        return n11.__c;
      });
      if (u6.every(function(n11) {
        return !n11.__N;
      }))
        return !c9 || c9.call(this, n10, t6, r6);
      var i7 = false;
      return u6.forEach(function(n11) {
        if (n11.__N) {
          var t7 = n11.__[0];
          n11.__ = n11.__N, n11.__N = void 0, t7 !== n11.__[0] && (i7 = true);
        }
      }), !(!i7 && o8.__c.props === n10) && (!c9 || c9.call(this, n10, t6, r6));
    };
    r5.u = true;
    var c9 = r5.shouldComponentUpdate, e9 = r5.componentWillUpdate;
    r5.componentWillUpdate = function(n10, t6, r6) {
      if (this.__e) {
        var u6 = c9;
        c9 = void 0, f4(n10, t6, r6), c9 = u6;
      }
      e9 && e9.call(this, n10, t6, r6);
    }, r5.shouldComponentUpdate = f4;
  }
  return o8.__N || o8.__;
}
function p3(u5, i6) {
  var o8 = d4(t4++, 3);
  !l4.__s && z3(o8.__H, i6) && (o8.__ = u5, o8.i = i6, r5.__H.__h.push(o8));
}
function y3(u5, i6) {
  var o8 = d4(t4++, 4);
  !l4.__s && z3(o8.__H, i6) && (o8.__ = u5, o8.i = i6, r5.__h.push(o8));
}
function _3(n9) {
  return o6 = 5, F2(function() {
    return { current: n9 };
  }, []);
}
function A3(n9, t6, r6) {
  o6 = 6, y3(function() {
    return "function" == typeof n9 ? (n9(t6()), function() {
      return n9(null);
    }) : n9 ? (n9.current = t6(), function() {
      return n9.current = null;
    }) : void 0;
  }, null == r6 ? r6 : r6.concat(n9));
}
function F2(n9, r6) {
  var u5 = d4(t4++, 7);
  return z3(u5.__H, r6) ? (u5.__V = n9(), u5.i = r6, u5.__h = n9, u5.__V) : u5.__;
}
function T3(n9, t6) {
  return o6 = 8, F2(function() {
    return n9;
  }, t6);
}
function q2(n9) {
  var u5 = r5.context[n9.__c], i6 = d4(t4++, 9);
  return i6.c = n9, u5 ? (null == i6.__ && (i6.__ = true, u5.sub(r5)), u5.props.value) : n9.__;
}
function x3(t6, r6) {
  l4.useDebugValue && l4.useDebugValue(r6 ? r6(t6) : t6);
}
function P3(n9) {
  var u5 = d4(t4++, 10), i6 = h4();
  return u5.__ = n9, r5.componentDidCatch || (r5.componentDidCatch = function(n10, t6) {
    u5.__ && u5.__(n10, t6), i6[1](n10);
  }), [i6[0], function() {
    i6[1](void 0);
  }];
}
function V2() {
  var n9 = d4(t4++, 11);
  if (!n9.__) {
    for (var u5 = r5.__v; null !== u5 && !u5.__m && null !== u5.__; )
      u5 = u5.__;
    var i6 = u5.__m || (u5.__m = [0, 0]);
    n9.__ = "P" + i6[0] + "-" + i6[1]++;
  }
  return n9.__;
}
function b3() {
  for (var t6; t6 = f3.shift(); )
    if (t6.__P && t6.__H)
      try {
        t6.__H.__h.forEach(k3), t6.__H.__h.forEach(w3), t6.__H.__h = [];
      } catch (r6) {
        t6.__H.__h = [], l4.__e(r6, t6.__v);
      }
}
function j3(n9) {
  var t6, r6 = function() {
    clearTimeout(u5), g3 && cancelAnimationFrame(t6), setTimeout(n9);
  }, u5 = setTimeout(r6, 100);
  g3 && (t6 = requestAnimationFrame(r6));
}
function k3(n9) {
  var t6 = r5, u5 = n9.__c;
  "function" == typeof u5 && (n9.__c = void 0, u5()), r5 = t6;
}
function w3(n9) {
  var t6 = r5;
  n9.__c = n9.__(), r5 = t6;
}
function z3(n9, t6) {
  return !n9 || n9.length !== t6.length || t6.some(function(t7, r6) {
    return t7 !== n9[r6];
  });
}
function B3(n9, t6) {
  return "function" == typeof t6 ? t6(n9) : t6;
}
var t4, r5, u4, i4, o6, f3, c4, e5, a4, v3, l5, m3, g3;
var init_hooks_module = __esm({
  "node_modules/preact/hooks/dist/hooks.module.js"() {
    init_preact_module();
    o6 = 0;
    f3 = [];
    c4 = [];
    e5 = l4.__b;
    a4 = l4.__r;
    v3 = l4.diffed;
    l5 = l4.__c;
    m3 = l4.unmount;
    l4.__b = function(n9) {
      r5 = null, e5 && e5(n9);
    }, l4.__r = function(n9) {
      a4 && a4(n9), t4 = 0;
      var i6 = (r5 = n9.__c).__H;
      i6 && (u4 === r5 ? (i6.__h = [], r5.__h = [], i6.__.forEach(function(n10) {
        n10.__N && (n10.__ = n10.__N), n10.__V = c4, n10.__N = n10.i = void 0;
      })) : (i6.__h.forEach(k3), i6.__h.forEach(w3), i6.__h = [], t4 = 0)), u4 = r5;
    }, l4.diffed = function(t6) {
      v3 && v3(t6);
      var o8 = t6.__c;
      o8 && o8.__H && (o8.__H.__h.length && (1 !== f3.push(o8) && i4 === l4.requestAnimationFrame || ((i4 = l4.requestAnimationFrame) || j3)(b3)), o8.__H.__.forEach(function(n9) {
        n9.i && (n9.__H = n9.i), n9.__V !== c4 && (n9.__ = n9.__V), n9.i = void 0, n9.__V = c4;
      })), u4 = r5 = null;
    }, l4.__c = function(t6, r6) {
      r6.some(function(t7) {
        try {
          t7.__h.forEach(k3), t7.__h = t7.__h.filter(function(n9) {
            return !n9.__ || w3(n9);
          });
        } catch (u5) {
          r6.some(function(n9) {
            n9.__h && (n9.__h = []);
          }), r6 = [], l4.__e(u5, t7.__v);
        }
      }), l5 && l5(t6, r6);
    }, l4.unmount = function(t6) {
      m3 && m3(t6);
      var r6, u5 = t6.__c;
      u5 && u5.__H && (u5.__H.__.forEach(function(n9) {
        try {
          k3(n9);
        } catch (n10) {
          r6 = n10;
        }
      }), u5.__H = void 0, r6 && l4.__e(r6, u5.__v));
    };
    g3 = "function" == typeof requestAnimationFrame;
  }
});

// node_modules/preact/compat/dist/compat.module.js
function g4(n9, t6) {
  for (var e9 in t6)
    n9[e9] = t6[e9];
  return n9;
}
function C3(n9, t6) {
  for (var e9 in n9)
    if ("__source" !== e9 && !(e9 in t6))
      return true;
  for (var r6 in t6)
    if ("__source" !== r6 && n9[r6] !== t6[r6])
      return true;
  return false;
}
function E3(n9, t6) {
  return n9 === t6 && (0 !== n9 || 1 / n9 == 1 / t6) || n9 != n9 && t6 != t6;
}
function w4(n9) {
  this.props = n9;
}
function x4(n9, e9) {
  function r6(n10) {
    var t6 = this.props.ref, r7 = t6 == n10.ref;
    return !r7 && t6 && (t6.call ? t6(null) : t6.current = null), e9 ? !e9(this.props, n10) || !r7 : C3(this.props, n10);
  }
  function u5(e11) {
    return this.shouldComponentUpdate = r6, y2(n9, e11);
  }
  return u5.displayName = "Memo(" + (n9.displayName || n9.name) + ")", u5.prototype.isReactComponent = true, u5.__f = true, u5;
}
function k4(n9) {
  function t6(t7) {
    var e9 = g4({}, t7);
    return delete e9.ref, n9(e9, t7.ref || null);
  }
  return t6.$$typeof = N3, t6.render = t6, t6.prototype.isReactComponent = t6.__f = true, t6.displayName = "ForwardRef(" + (n9.displayName || n9.name) + ")", t6;
}
function L3(n9, t6, e9) {
  return n9 && (n9.__c && n9.__c.__H && (n9.__c.__H.__.forEach(function(n10) {
    "function" == typeof n10.__c && n10.__c();
  }), n9.__c.__H = null), null != (n9 = g4({}, n9)).__c && (n9.__c.__P === e9 && (n9.__c.__P = t6), n9.__c = null), n9.__k = n9.__k && n9.__k.map(function(n10) {
    return L3(n10, t6, e9);
  })), n9;
}
function U(n9, t6, e9) {
  return n9 && (n9.__v = null, n9.__k = n9.__k && n9.__k.map(function(n10) {
    return U(n10, t6, e9);
  }), n9.__c && n9.__c.__P === t6 && (n9.__e && e9.insertBefore(n9.__e, n9.__d), n9.__c.__e = true, n9.__c.__P = e9)), n9;
}
function D2() {
  this.__u = 0, this.t = null, this.__b = null;
}
function F3(n9) {
  var t6 = n9.__.__c;
  return t6 && t6.__a && t6.__a(n9);
}
function M3(n9) {
  var e9, r6, u5;
  function o8(o9) {
    if (e9 || (e9 = n9()).then(function(n10) {
      r6 = n10.default || n10;
    }, function(n10) {
      u5 = n10;
    }), u5)
      throw u5;
    if (!r6)
      throw e9;
    return y2(r6, o9);
  }
  return o8.displayName = "Lazy", o8.__f = true, o8;
}
function V3() {
  this.u = null, this.o = null;
}
function P4(n9) {
  return this.getChildContext = function() {
    return n9.context;
  }, n9.children;
}
function j4(n9) {
  var e9 = this, r6 = n9.i;
  e9.componentWillUnmount = function() {
    D(null, e9.l), e9.l = null, e9.i = null;
  }, e9.i && e9.i !== r6 && e9.componentWillUnmount(), n9.__v ? (e9.l || (e9.i = r6, e9.l = { nodeType: 1, parentNode: r6, childNodes: [], appendChild: function(n10) {
    this.childNodes.push(n10), e9.i.appendChild(n10);
  }, insertBefore: function(n10, t6) {
    this.childNodes.push(n10), e9.i.appendChild(n10);
  }, removeChild: function(n10) {
    this.childNodes.splice(this.childNodes.indexOf(n10) >>> 1, 1), e9.i.removeChild(n10);
  } }), D(y2(P4, { context: e9.context }, n9.__v), e9.l)) : e9.l && e9.componentWillUnmount();
}
function z4(n9, e9) {
  var r6 = y2(j4, { __v: n9, i: e9 });
  return r6.containerInfo = e9, r6;
}
function G2(n9, t6, e9) {
  return null == t6.__k && (t6.textContent = ""), D(n9, t6), "function" == typeof e9 && e9(), n9 ? n9.__c : null;
}
function J(n9, t6, e9) {
  return E2(n9, t6), "function" == typeof e9 && e9(), n9 ? n9.__c : null;
}
function Q() {
}
function X() {
  return this.cancelBubble;
}
function nn() {
  return this.defaultPrevented;
}
function fn(n9) {
  return y2.bind(null, n9);
}
function an(n9) {
  return !!n9 && n9.$$typeof === B4;
}
function sn(n9) {
  return an(n9) ? F.apply(null, arguments) : n9;
}
function hn(n9) {
  return !!n9.__k && (D(null, n9), true);
}
function vn(n9) {
  return n9 && (n9.base || 1 === n9.nodeType && n9) || null;
}
function yn(n9) {
  n9();
}
function _n(n9) {
  return n9;
}
function bn() {
  return [false, yn];
}
function gn(n9, t6) {
  var e9 = t6(), r6 = h4({ h: { __: e9, v: t6 } }), u5 = r6[0].h, o8 = r6[1];
  return y3(function() {
    u5.__ = e9, u5.v = t6, E3(u5.__, t6()) || o8({ h: u5 });
  }, [n9, e9, t6]), p3(function() {
    return E3(u5.__, u5.v()) || o8({ h: u5 }), n9(function() {
      E3(u5.__, u5.v()) || o8({ h: u5 });
    });
  }, [n9]), e9;
}
var R2, N3, A4, O2, T4, I3, W, B4, H3, Z, Y, $4, q3, K, tn, en, rn, un, on, ln, cn, dn, pn, mn, Sn, Cn;
var init_compat_module = __esm({
  "node_modules/preact/compat/dist/compat.module.js"() {
    init_preact_module();
    init_preact_module();
    init_hooks_module();
    init_hooks_module();
    (w4.prototype = new b2()).isPureReactComponent = true, w4.prototype.shouldComponentUpdate = function(n9, t6) {
      return C3(this.props, n9) || C3(this.state, t6);
    };
    R2 = l4.__b;
    l4.__b = function(n9) {
      n9.type && n9.type.__f && n9.ref && (n9.props.ref = n9.ref, n9.ref = null), R2 && R2(n9);
    };
    N3 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
    A4 = function(n9, t6) {
      return null == n9 ? null : S3(S3(n9).map(t6));
    };
    O2 = { map: A4, forEach: A4, count: function(n9) {
      return n9 ? S3(n9).length : 0;
    }, only: function(n9) {
      var t6 = S3(n9);
      if (1 !== t6.length)
        throw "Children.only";
      return t6[0];
    }, toArray: S3 };
    T4 = l4.__e;
    l4.__e = function(n9, t6, e9, r6) {
      if (n9.then) {
        for (var u5, o8 = t6; o8 = o8.__; )
          if ((u5 = o8.__c) && u5.__c)
            return null == t6.__e && (t6.__e = e9.__e, t6.__k = e9.__k), u5.__c(n9, t6);
      }
      T4(n9, t6, e9, r6);
    };
    I3 = l4.unmount;
    l4.unmount = function(n9) {
      var t6 = n9.__c;
      t6 && t6.__R && t6.__R(), t6 && true === n9.__h && (n9.type = null), I3 && I3(n9);
    }, (D2.prototype = new b2()).__c = function(n9, t6) {
      var e9 = t6.__c, r6 = this;
      null == r6.t && (r6.t = []), r6.t.push(e9);
      var u5 = F3(r6.__v), o8 = false, i6 = function() {
        o8 || (o8 = true, e9.__R = null, u5 ? u5(l7) : l7());
      };
      e9.__R = i6;
      var l7 = function() {
        if (!--r6.__u) {
          if (r6.state.__a) {
            var n10 = r6.state.__a;
            r6.__v.__k[0] = U(n10, n10.__c.__P, n10.__c.__O);
          }
          var t7;
          for (r6.setState({ __a: r6.__b = null }); t7 = r6.t.pop(); )
            t7.forceUpdate();
        }
      }, c9 = true === t6.__h;
      r6.__u++ || c9 || r6.setState({ __a: r6.__b = r6.__v.__k[0] }), n9.then(i6, i6);
    }, D2.prototype.componentWillUnmount = function() {
      this.t = [];
    }, D2.prototype.render = function(n9, e9) {
      if (this.__b) {
        if (this.__v.__k) {
          var r6 = document.createElement("div"), o8 = this.__v.__k[0].__c;
          this.__v.__k[0] = L3(this.__b, r6, o8.__O = o8.__P);
        }
        this.__b = null;
      }
      var i6 = e9.__a && y2(k2, null, n9.fallback);
      return i6 && (i6.__h = null), [y2(k2, null, e9.__a ? null : n9.children), i6];
    };
    W = function(n9, t6, e9) {
      if (++e9[1] === e9[0] && n9.o.delete(t6), n9.props.revealOrder && ("t" !== n9.props.revealOrder[0] || !n9.o.size))
        for (e9 = n9.u; e9; ) {
          for (; e9.length > 3; )
            e9.pop()();
          if (e9[1] < e9[0])
            break;
          n9.u = e9 = e9[2];
        }
    };
    (V3.prototype = new b2()).__a = function(n9) {
      var t6 = this, e9 = F3(t6.__v), r6 = t6.o.get(n9);
      return r6[0]++, function(u5) {
        var o8 = function() {
          t6.props.revealOrder ? (r6.push(u5), W(t6, n9, r6)) : u5();
        };
        e9 ? e9(o8) : o8();
      };
    }, V3.prototype.render = function(n9) {
      this.u = null, this.o = /* @__PURE__ */ new Map();
      var t6 = S3(n9.children);
      n9.revealOrder && "b" === n9.revealOrder[0] && t6.reverse();
      for (var e9 = t6.length; e9--; )
        this.o.set(t6[e9], this.u = [1, 0, this.u]);
      return n9.children;
    }, V3.prototype.componentDidUpdate = V3.prototype.componentDidMount = function() {
      var n9 = this;
      this.o.forEach(function(t6, e9) {
        W(n9, e9, t6);
      });
    };
    B4 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
    H3 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
    Z = /^on(Ani|Tra|Tou|BeforeInp|Compo)/;
    Y = /[A-Z0-9]/g;
    $4 = "undefined" != typeof document;
    q3 = function(n9) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n9);
    };
    b2.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t6) {
      Object.defineProperty(b2.prototype, t6, { configurable: true, get: function() {
        return this["UNSAFE_" + t6];
      }, set: function(n9) {
        Object.defineProperty(this, t6, { configurable: true, writable: true, value: n9 });
      } });
    });
    K = l4.event;
    l4.event = function(n9) {
      return K && (n9 = K(n9)), n9.persist = Q, n9.isPropagationStopped = X, n9.isDefaultPrevented = nn, n9.nativeEvent = n9;
    };
    en = { enumerable: false, configurable: true, get: function() {
      return this.class;
    } };
    rn = l4.vnode;
    l4.vnode = function(n9) {
      "string" == typeof n9.type && function(n10) {
        var t6 = n10.props, e9 = n10.type, u5 = {};
        for (var o8 in t6) {
          var i6 = t6[o8];
          if (!("value" === o8 && "defaultValue" in t6 && null == i6 || $4 && "children" === o8 && "noscript" === e9 || "class" === o8 || "className" === o8)) {
            var l7 = o8.toLowerCase();
            "defaultValue" === o8 && "value" in t6 && null == t6.value ? o8 = "value" : "download" === o8 && true === i6 ? i6 = "" : "ondoubleclick" === l7 ? o8 = "ondblclick" : "onchange" !== l7 || "input" !== e9 && "textarea" !== e9 || q3(t6.type) ? "onfocus" === l7 ? o8 = "onfocusin" : "onblur" === l7 ? o8 = "onfocusout" : Z.test(o8) ? o8 = l7 : -1 === e9.indexOf("-") && H3.test(o8) ? o8 = o8.replace(Y, "-$&").toLowerCase() : null === i6 && (i6 = void 0) : l7 = o8 = "oninput", "oninput" === l7 && u5[o8 = l7] && (o8 = "oninputCapture"), u5[o8] = i6;
          }
        }
        "select" == e9 && u5.multiple && Array.isArray(u5.value) && (u5.value = S3(t6.children).forEach(function(n11) {
          n11.props.selected = -1 != u5.value.indexOf(n11.props.value);
        })), "select" == e9 && null != u5.defaultValue && (u5.value = S3(t6.children).forEach(function(n11) {
          n11.props.selected = u5.multiple ? -1 != u5.defaultValue.indexOf(n11.props.value) : u5.defaultValue == n11.props.value;
        })), t6.class && !t6.className ? (u5.class = t6.class, Object.defineProperty(u5, "className", en)) : (t6.className && !t6.class || t6.class && t6.className) && (u5.class = u5.className = t6.className), n10.props = u5;
      }(n9), n9.$$typeof = B4, rn && rn(n9);
    };
    un = l4.__r;
    l4.__r = function(n9) {
      un && un(n9), tn = n9.__c;
    };
    on = l4.diffed;
    l4.diffed = function(n9) {
      on && on(n9);
      var t6 = n9.props, e9 = n9.__e;
      null != e9 && "textarea" === n9.type && "value" in t6 && t6.value !== e9.value && (e9.value = null == t6.value ? "" : t6.value), tn = null;
    };
    ln = { ReactCurrentDispatcher: { current: { readContext: function(n9) {
      return tn.__n[n9.__c].props.value;
    } } } };
    cn = "17.0.2";
    dn = function(n9, t6) {
      return n9(t6);
    };
    pn = function(n9, t6) {
      return n9(t6);
    };
    mn = k2;
    Sn = y3;
    Cn = { useState: h4, useId: V2, useReducer: s6, useEffect: p3, useLayoutEffect: y3, useInsertionEffect: Sn, useTransition: bn, useDeferredValue: _n, useSyncExternalStore: gn, startTransition: yn, useRef: _3, useImperativeHandle: A3, useMemo: F2, useCallback: T3, useContext: q2, useDebugValue: x3, version: "17.0.2", Children: O2, render: G2, hydrate: J, unmountComponentAtNode: hn, createPortal: z4, createElement: y2, createContext: G, createFactory: fn, cloneElement: sn, createRef: _2, Fragment: k2, isValidElement: an, findDOMNode: vn, Component: b2, PureComponent: w4, memo: x4, forwardRef: k4, flushSync: pn, unstable_batchedUpdates: dn, StrictMode: mn, Suspense: D2, SuspenseList: V3, lazy: M3, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ln };
  }
});

// node_modules/react/index.mjs
var react_exports = {};
__export(react_exports, {
  Children: () => O2,
  Component: () => b2,
  Fragment: () => k2,
  PureComponent: () => w4,
  StrictMode: () => mn,
  Suspense: () => D2,
  SuspenseList: () => V3,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => ln,
  cloneElement: () => sn,
  createContext: () => G,
  createElement: () => y2,
  createFactory: () => fn,
  createPortal: () => z4,
  createRef: () => _2,
  default: () => Cn,
  findDOMNode: () => vn,
  flushSync: () => pn,
  forwardRef: () => k4,
  hydrate: () => J,
  isValidElement: () => an,
  lazy: () => M3,
  memo: () => x4,
  render: () => G2,
  startTransition: () => yn,
  unmountComponentAtNode: () => hn,
  unstable_batchedUpdates: () => dn,
  useCallback: () => T3,
  useContext: () => q2,
  useDebugValue: () => x3,
  useDeferredValue: () => _n,
  useEffect: () => p3,
  useErrorBoundary: () => P3,
  useId: () => V2,
  useImperativeHandle: () => A3,
  useInsertionEffect: () => Sn,
  useLayoutEffect: () => y3,
  useMemo: () => F2,
  useReducer: () => s6,
  useRef: () => _3,
  useState: () => h4,
  useSyncExternalStore: () => gn,
  useTransition: () => bn,
  version: () => cn
});
var init_react = __esm({
  "node_modules/react/index.mjs"() {
    init_compat_module();
    init_compat_module();
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal2 = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal2;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal2 = require_freeGlobal();
    var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
    var root3 = freeGlobal2 || freeSelf2 || Function("return this")();
    module2.exports = root3;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root3 = require_root();
    var Symbol4 = root3.Symbol;
    module2.exports = Symbol4;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol4 = require_Symbol();
    var objectProto16 = Object.prototype;
    var hasOwnProperty13 = objectProto16.hasOwnProperty;
    var nativeObjectToString3 = objectProto16.toString;
    var symToStringTag3 = Symbol4 ? Symbol4.toStringTag : void 0;
    function getRawTag2(value) {
      var isOwn = hasOwnProperty13.call(value, symToStringTag3), tag = value[symToStringTag3];
      try {
        value[symToStringTag3] = void 0;
        var unmasked = true;
      } catch (e9) {
      }
      var result = nativeObjectToString3.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag3] = tag;
        } else {
          delete value[symToStringTag3];
        }
      }
      return result;
    }
    module2.exports = getRawTag2;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto16 = Object.prototype;
    var nativeObjectToString3 = objectProto16.toString;
    function objectToString3(value) {
      return nativeObjectToString3.call(value);
    }
    module2.exports = objectToString3;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol4 = require_Symbol();
    var getRawTag2 = require_getRawTag();
    var objectToString3 = require_objectToString();
    var nullTag2 = "[object Null]";
    var undefinedTag2 = "[object Undefined]";
    var symToStringTag3 = Symbol4 ? Symbol4.toStringTag : void 0;
    function baseGetTag2(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag2 : nullTag2;
      }
      return symToStringTag3 && symToStringTag3 in Object(value) ? getRawTag2(value) : objectToString3(value);
    }
    module2.exports = baseGetTag2;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray2 = Array.isArray;
    module2.exports = isArray2;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike2(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike2;
  }
});

// node_modules/lodash/isString.js
var require_isString = __commonJS({
  "node_modules/lodash/isString.js"(exports2, module2) {
    var baseGetTag2 = require_baseGetTag();
    var isArray2 = require_isArray();
    var isObjectLike2 = require_isObjectLike();
    var stringTag3 = "[object String]";
    function isString2(value) {
      return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag3;
    }
    module2.exports = isString2;
  }
});

// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/lodash/_createBaseFor.js"(exports2, module2) {
    function createBaseFor2(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object), props = keysFunc(object), length3 = props.length;
        while (length3--) {
          var key = props[fromRight ? length3 : ++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module2.exports = createBaseFor2;
  }
});

// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/lodash/_baseFor.js"(exports2, module2) {
    var createBaseFor2 = require_createBaseFor();
    var baseFor2 = createBaseFor2();
    module2.exports = baseFor2;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports2, module2) {
    function baseTimes2(n9, iteratee) {
      var index2 = -1, result = Array(n9);
      while (++index2 < n9) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    module2.exports = baseTimes2;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
    var baseGetTag2 = require_baseGetTag();
    var isObjectLike2 = require_isObjectLike();
    var argsTag4 = "[object Arguments]";
    function baseIsArguments2(value) {
      return isObjectLike2(value) && baseGetTag2(value) == argsTag4;
    }
    module2.exports = baseIsArguments2;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports2, module2) {
    var baseIsArguments2 = require_baseIsArguments();
    var isObjectLike2 = require_isObjectLike();
    var objectProto16 = Object.prototype;
    var hasOwnProperty13 = objectProto16.hasOwnProperty;
    var propertyIsEnumerable3 = objectProto16.propertyIsEnumerable;
    var isArguments2 = baseIsArguments2(function() {
      return arguments;
    }()) ? baseIsArguments2 : function(value) {
      return isObjectLike2(value) && hasOwnProperty13.call(value, "callee") && !propertyIsEnumerable3.call(value, "callee");
    };
    module2.exports = isArguments2;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports2, module2) {
    function stubFalse2() {
      return false;
    }
    module2.exports = stubFalse2;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports2, module2) {
    var root3 = require_root();
    var stubFalse2 = require_stubFalse();
    var freeExports4 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule4 = freeExports4 && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
    var Buffer4 = moduleExports4 ? root3.Buffer : void 0;
    var nativeIsBuffer2 = Buffer4 ? Buffer4.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer2 || stubFalse2;
    module2.exports = isBuffer2;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports2, module2) {
    var MAX_SAFE_INTEGER3 = 9007199254740991;
    var reIsUint2 = /^(?:0|[1-9]\d*)$/;
    function isIndex2(value, length3) {
      var type3 = typeof value;
      length3 = length3 == null ? MAX_SAFE_INTEGER3 : length3;
      return !!length3 && (type3 == "number" || type3 != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length3);
    }
    module2.exports = isIndex2;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports2, module2) {
    var MAX_SAFE_INTEGER3 = 9007199254740991;
    function isLength2(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER3;
    }
    module2.exports = isLength2;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
    var baseGetTag2 = require_baseGetTag();
    var isLength2 = require_isLength();
    var isObjectLike2 = require_isObjectLike();
    var argsTag4 = "[object Arguments]";
    var arrayTag3 = "[object Array]";
    var boolTag3 = "[object Boolean]";
    var dateTag3 = "[object Date]";
    var errorTag3 = "[object Error]";
    var funcTag3 = "[object Function]";
    var mapTag4 = "[object Map]";
    var numberTag3 = "[object Number]";
    var objectTag5 = "[object Object]";
    var regexpTag3 = "[object RegExp]";
    var setTag4 = "[object Set]";
    var stringTag3 = "[object String]";
    var weakMapTag3 = "[object WeakMap]";
    var arrayBufferTag3 = "[object ArrayBuffer]";
    var dataViewTag4 = "[object DataView]";
    var float32Tag2 = "[object Float32Array]";
    var float64Tag2 = "[object Float64Array]";
    var int8Tag2 = "[object Int8Array]";
    var int16Tag2 = "[object Int16Array]";
    var int32Tag2 = "[object Int32Array]";
    var uint8Tag2 = "[object Uint8Array]";
    var uint8ClampedTag2 = "[object Uint8ClampedArray]";
    var uint16Tag2 = "[object Uint16Array]";
    var uint32Tag2 = "[object Uint32Array]";
    var typedArrayTags2 = {};
    typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
    typedArrayTags2[argsTag4] = typedArrayTags2[arrayTag3] = typedArrayTags2[arrayBufferTag3] = typedArrayTags2[boolTag3] = typedArrayTags2[dataViewTag4] = typedArrayTags2[dateTag3] = typedArrayTags2[errorTag3] = typedArrayTags2[funcTag3] = typedArrayTags2[mapTag4] = typedArrayTags2[numberTag3] = typedArrayTags2[objectTag5] = typedArrayTags2[regexpTag3] = typedArrayTags2[setTag4] = typedArrayTags2[stringTag3] = typedArrayTags2[weakMapTag3] = false;
    function baseIsTypedArray2(value) {
      return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
    }
    module2.exports = baseIsTypedArray2;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports2, module2) {
    function baseUnary2(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary2;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports2, module2) {
    var freeGlobal2 = require_freeGlobal();
    var freeExports4 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule4 = freeExports4 && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
    var freeProcess2 = moduleExports4 && freeGlobal2.process;
    var nodeUtil2 = function() {
      try {
        var types = freeModule4 && freeModule4.require && freeModule4.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
      } catch (e9) {
      }
    }();
    module2.exports = nodeUtil2;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports2, module2) {
    var baseIsTypedArray2 = require_baseIsTypedArray();
    var baseUnary2 = require_baseUnary();
    var nodeUtil2 = require_nodeUtil();
    var nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
    var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
    module2.exports = isTypedArray2;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
    var baseTimes2 = require_baseTimes();
    var isArguments2 = require_isArguments();
    var isArray2 = require_isArray();
    var isBuffer2 = require_isBuffer();
    var isIndex2 = require_isIndex();
    var isTypedArray2 = require_isTypedArray();
    var objectProto16 = Object.prototype;
    var hasOwnProperty13 = objectProto16.hasOwnProperty;
    function arrayLikeKeys2(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes2(value.length, String) : [], length3 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty13.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex2(key, length3)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys2;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports2, module2) {
    var objectProto16 = Object.prototype;
    function isPrototype2(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto16;
      return value === proto;
    }
    module2.exports = isPrototype2;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports2, module2) {
    function overArg2(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    module2.exports = overArg2;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports2, module2) {
    var overArg2 = require_overArg();
    var nativeKeys2 = overArg2(Object.keys, Object);
    module2.exports = nativeKeys2;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports2, module2) {
    var isPrototype2 = require_isPrototype();
    var nativeKeys2 = require_nativeKeys();
    var objectProto16 = Object.prototype;
    var hasOwnProperty13 = objectProto16.hasOwnProperty;
    function baseKeys2(object) {
      if (!isPrototype2(object)) {
        return nativeKeys2(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty13.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys2;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject3(value) {
      var type3 = typeof value;
      return value != null && (type3 == "object" || type3 == "function");
    }
    module2.exports = isObject3;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag2 = require_baseGetTag();
    var isObject3 = require_isObject();
    var asyncTag2 = "[object AsyncFunction]";
    var funcTag3 = "[object Function]";
    var genTag2 = "[object GeneratorFunction]";
    var proxyTag2 = "[object Proxy]";
    function isFunction2(value) {
      if (!isObject3(value)) {
        return false;
      }
      var tag = baseGetTag2(value);
      return tag == funcTag3 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
    }
    module2.exports = isFunction2;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports2, module2) {
    var isFunction2 = require_isFunction();
    var isLength2 = require_isLength();
    function isArrayLike2(value) {
      return value != null && isLength2(value.length) && !isFunction2(value);
    }
    module2.exports = isArrayLike2;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports2, module2) {
    var arrayLikeKeys2 = require_arrayLikeKeys();
    var baseKeys2 = require_baseKeys();
    var isArrayLike2 = require_isArrayLike();
    function keys2(object) {
      return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
    }
    module2.exports = keys2;
  }
});

// node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "node_modules/lodash/_baseForOwn.js"(exports2, module2) {
    var baseFor2 = require_baseFor();
    var keys2 = require_keys();
    function baseForOwn2(object, iteratee) {
      return object && baseFor2(object, iteratee, keys2);
    }
    module2.exports = baseForOwn2;
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports2, module2) {
    function identity9(value) {
      return value;
    }
    module2.exports = identity9;
  }
});

// node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  "node_modules/lodash/_castFunction.js"(exports2, module2) {
    var identity9 = require_identity();
    function castFunction2(value) {
      return typeof value == "function" ? value : identity9;
    }
    module2.exports = castFunction2;
  }
});

// node_modules/lodash/forOwn.js
var require_forOwn = __commonJS({
  "node_modules/lodash/forOwn.js"(exports2, module2) {
    var baseForOwn2 = require_baseForOwn();
    var castFunction2 = require_castFunction();
    function forOwn(object, iteratee) {
      return object && baseForOwn2(object, castFunction2(iteratee));
    }
    module2.exports = forOwn;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports2, module2) {
    var overArg2 = require_overArg();
    var getPrototype2 = overArg2(Object.getPrototypeOf, Object);
    module2.exports = getPrototype2;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports2, module2) {
    var baseGetTag2 = require_baseGetTag();
    var getPrototype2 = require_getPrototype();
    var isObjectLike2 = require_isObjectLike();
    var objectTag5 = "[object Object]";
    var funcProto4 = Function.prototype;
    var objectProto16 = Object.prototype;
    var funcToString4 = funcProto4.toString;
    var hasOwnProperty13 = objectProto16.hasOwnProperty;
    var objectCtorString2 = funcToString4.call(Object);
    function isPlainObject2(value) {
      if (!isObjectLike2(value) || baseGetTag2(value) != objectTag5) {
        return false;
      }
      var proto = getPrototype2(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty13.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString4.call(Ctor) == objectCtorString2;
    }
    module2.exports = isPlainObject2;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports2, module2) {
    function arrayMap2(array2, iteratee) {
      var index2 = -1, length3 = array2 == null ? 0 : array2.length, result = Array(length3);
      while (++index2 < length3) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    module2.exports = arrayMap2;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports2, module2) {
    function listCacheClear2() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear2;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports2, module2) {
    function eq2(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq2;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
    var eq2 = require_eq();
    function assocIndexOf2(array2, key) {
      var length3 = array2.length;
      while (length3--) {
        if (eq2(array2[length3][0], key)) {
          return length3;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf2;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
    var assocIndexOf2 = require_assocIndexOf();
    var arrayProto2 = Array.prototype;
    var splice2 = arrayProto2.splice;
    function listCacheDelete2(key) {
      var data = this.__data__, index2 = assocIndexOf2(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice2.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete2;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports2, module2) {
    var assocIndexOf2 = require_assocIndexOf();
    function listCacheGet2(key) {
      var data = this.__data__, index2 = assocIndexOf2(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    module2.exports = listCacheGet2;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports2, module2) {
    var assocIndexOf2 = require_assocIndexOf();
    function listCacheHas2(key) {
      return assocIndexOf2(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas2;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports2, module2) {
    var assocIndexOf2 = require_assocIndexOf();
    function listCacheSet2(key, value) {
      var data = this.__data__, index2 = assocIndexOf2(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet2;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports2, module2) {
    var listCacheClear2 = require_listCacheClear();
    var listCacheDelete2 = require_listCacheDelete();
    var listCacheGet2 = require_listCacheGet();
    var listCacheHas2 = require_listCacheHas();
    var listCacheSet2 = require_listCacheSet();
    function ListCache2(entries) {
      var index2 = -1, length3 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length3) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache2.prototype.clear = listCacheClear2;
    ListCache2.prototype["delete"] = listCacheDelete2;
    ListCache2.prototype.get = listCacheGet2;
    ListCache2.prototype.has = listCacheHas2;
    ListCache2.prototype.set = listCacheSet2;
    module2.exports = ListCache2;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports2, module2) {
    var ListCache2 = require_ListCache();
    function stackClear2() {
      this.__data__ = new ListCache2();
      this.size = 0;
    }
    module2.exports = stackClear2;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports2, module2) {
    function stackDelete2(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete2;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports2, module2) {
    function stackGet2(key) {
      return this.__data__.get(key);
    }
    module2.exports = stackGet2;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports2, module2) {
    function stackHas2(key) {
      return this.__data__.has(key);
    }
    module2.exports = stackHas2;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports2, module2) {
    var root3 = require_root();
    var coreJsData2 = root3["__core-js_shared__"];
    module2.exports = coreJsData2;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports2, module2) {
    var coreJsData2 = require_coreJsData();
    var maskSrcKey2 = function() {
      var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked2(func) {
      return !!maskSrcKey2 && maskSrcKey2 in func;
    }
    module2.exports = isMasked2;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports2, module2) {
    var funcProto4 = Function.prototype;
    var funcToString4 = funcProto4.toString;
    function toSource2(func) {
      if (func != null) {
        try {
          return funcToString4.call(func);
        } catch (e9) {
        }
        try {
          return func + "";
        } catch (e9) {
        }
      }
      return "";
    }
    module2.exports = toSource2;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    var isFunction2 = require_isFunction();
    var isMasked2 = require_isMasked();
    var isObject3 = require_isObject();
    var toSource2 = require_toSource();
    var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
    var funcProto4 = Function.prototype;
    var objectProto16 = Object.prototype;
    var funcToString4 = funcProto4.toString;
    var hasOwnProperty13 = objectProto16.hasOwnProperty;
    var reIsNative2 = RegExp(
      "^" + funcToString4.call(hasOwnProperty13).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative2(value) {
      if (!isObject3(value) || isMasked2(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
      return pattern.test(toSource2(value));
    }
    module2.exports = baseIsNative2;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports2, module2) {
    function getValue2(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue2;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports2, module2) {
    var baseIsNative2 = require_baseIsNative();
    var getValue2 = require_getValue();
    function getNative2(object, key) {
      var value = getValue2(object, key);
      return baseIsNative2(value) ? value : void 0;
    }
    module2.exports = getNative2;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports2, module2) {
    var getNative2 = require_getNative();
    var root3 = require_root();
    var Map3 = getNative2(root3, "Map");
    module2.exports = Map3;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports2, module2) {
    var getNative2 = require_getNative();
    var nativeCreate2 = getNative2(Object, "create");
    module2.exports = nativeCreate2;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports2, module2) {
    var nativeCreate2 = require_nativeCreate();
    function hashClear2() {
      this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear2;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports2, module2) {
    function hashDelete2(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete2;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports2, module2) {
    var nativeCreate2 = require_nativeCreate();
    var HASH_UNDEFINED4 = "__lodash_hash_undefined__";
    var objectProto16 = Object.prototype;
    var hasOwnProperty13 = objectProto16.hasOwnProperty;
    function hashGet2(key) {
      var data = this.__data__;
      if (nativeCreate2) {
        var result = data[key];
        return result === HASH_UNDEFINED4 ? void 0 : result;
      }
      return hasOwnProperty13.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet2;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports2, module2) {
    var nativeCreate2 = require_nativeCreate();
    var objectProto16 = Object.prototype;
    var hasOwnProperty13 = objectProto16.hasOwnProperty;
    function hashHas2(key) {
      var data = this.__data__;
      return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty13.call(data, key);
    }
    module2.exports = hashHas2;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports2, module2) {
    var nativeCreate2 = require_nativeCreate();
    var HASH_UNDEFINED4 = "__lodash_hash_undefined__";
    function hashSet2(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED4 : value;
      return this;
    }
    module2.exports = hashSet2;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports2, module2) {
    var hashClear2 = require_hashClear();
    var hashDelete2 = require_hashDelete();
    var hashGet2 = require_hashGet();
    var hashHas2 = require_hashHas();
    var hashSet2 = require_hashSet();
    function Hash2(entries) {
      var index2 = -1, length3 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length3) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash2.prototype.clear = hashClear2;
    Hash2.prototype["delete"] = hashDelete2;
    Hash2.prototype.get = hashGet2;
    Hash2.prototype.has = hashHas2;
    Hash2.prototype.set = hashSet2;
    module2.exports = Hash2;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
    var Hash2 = require_Hash();
    var ListCache2 = require_ListCache();
    var Map3 = require_Map();
    function mapCacheClear2() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash2(),
        "map": new (Map3 || ListCache2)(),
        "string": new Hash2()
      };
    }
    module2.exports = mapCacheClear2;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports2, module2) {
    function isKeyable2(value) {
      var type3 = typeof value;
      return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable2;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports2, module2) {
    var isKeyable2 = require_isKeyable();
    function getMapData2(map4, key) {
      var data = map4.__data__;
      return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData2;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
    var getMapData2 = require_getMapData();
    function mapCacheDelete2(key) {
      var result = getMapData2(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete2;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
    var getMapData2 = require_getMapData();
    function mapCacheGet2(key) {
      return getMapData2(this, key).get(key);
    }
    module2.exports = mapCacheGet2;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
    var getMapData2 = require_getMapData();
    function mapCacheHas2(key) {
      return getMapData2(this, key).has(key);
    }
    module2.exports = mapCacheHas2;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
    var getMapData2 = require_getMapData();
    function mapCacheSet2(key, value) {
      var data = getMapData2(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet2;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports2, module2) {
    var mapCacheClear2 = require_mapCacheClear();
    var mapCacheDelete2 = require_mapCacheDelete();
    var mapCacheGet2 = require_mapCacheGet();
    var mapCacheHas2 = require_mapCacheHas();
    var mapCacheSet2 = require_mapCacheSet();
    function MapCache2(entries) {
      var index2 = -1, length3 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length3) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache2.prototype.clear = mapCacheClear2;
    MapCache2.prototype["delete"] = mapCacheDelete2;
    MapCache2.prototype.get = mapCacheGet2;
    MapCache2.prototype.has = mapCacheHas2;
    MapCache2.prototype.set = mapCacheSet2;
    module2.exports = MapCache2;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports2, module2) {
    var ListCache2 = require_ListCache();
    var Map3 = require_Map();
    var MapCache2 = require_MapCache();
    var LARGE_ARRAY_SIZE2 = 200;
    function stackSet2(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache2) {
        var pairs2 = data.__data__;
        if (!Map3 || pairs2.length < LARGE_ARRAY_SIZE2 - 1) {
          pairs2.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache2(pairs2);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet2;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports2, module2) {
    var ListCache2 = require_ListCache();
    var stackClear2 = require_stackClear();
    var stackDelete2 = require_stackDelete();
    var stackGet2 = require_stackGet();
    var stackHas2 = require_stackHas();
    var stackSet2 = require_stackSet();
    function Stack2(entries) {
      var data = this.__data__ = new ListCache2(entries);
      this.size = data.size;
    }
    Stack2.prototype.clear = stackClear2;
    Stack2.prototype["delete"] = stackDelete2;
    Stack2.prototype.get = stackGet2;
    Stack2.prototype.has = stackHas2;
    Stack2.prototype.set = stackSet2;
    module2.exports = Stack2;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
    var HASH_UNDEFINED4 = "__lodash_hash_undefined__";
    function setCacheAdd2(value) {
      this.__data__.set(value, HASH_UNDEFINED4);
      return this;
    }
    module2.exports = setCacheAdd2;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports2, module2) {
    function setCacheHas2(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas2;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports2, module2) {
    var MapCache2 = require_MapCache();
    var setCacheAdd2 = require_setCacheAdd();
    var setCacheHas2 = require_setCacheHas();
    function SetCache2(values2) {
      var index2 = -1, length3 = values2 == null ? 0 : values2.length;
      this.__data__ = new MapCache2();
      while (++index2 < length3) {
        this.add(values2[index2]);
      }
    }
    SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
    SetCache2.prototype.has = setCacheHas2;
    module2.exports = SetCache2;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports2, module2) {
    function arraySome2(array2, predicate) {
      var index2 = -1, length3 = array2 == null ? 0 : array2.length;
      while (++index2 < length3) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome2;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports2, module2) {
    function cacheHas2(cache, key) {
      return cache.has(key);
    }
    module2.exports = cacheHas2;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports2, module2) {
    var SetCache2 = require_SetCache();
    var arraySome2 = require_arraySome();
    var cacheHas2 = require_cacheHas();
    var COMPARE_PARTIAL_FLAG7 = 1;
    var COMPARE_UNORDERED_FLAG5 = 2;
    function equalArrays2(array2, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG7, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack2.get(array2);
      var othStacked = stack2.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG5 ? new SetCache2() : void 0;
      stack2.set(array2, other);
      stack2.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack2) : customizer(arrValue, othValue, index2, array2, other, stack2);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome2(other, function(othValue2, othIndex) {
            if (!cacheHas2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
          result = false;
          break;
        }
      }
      stack2["delete"](array2);
      stack2["delete"](other);
      return result;
    }
    module2.exports = equalArrays2;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports2, module2) {
    var root3 = require_root();
    var Uint8Array3 = root3.Uint8Array;
    module2.exports = Uint8Array3;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports2, module2) {
    function mapToArray2(map4) {
      var index2 = -1, result = Array(map4.size);
      map4.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    module2.exports = mapToArray2;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports2, module2) {
    function setToArray2(set4) {
      var index2 = -1, result = Array(set4.size);
      set4.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    module2.exports = setToArray2;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports2, module2) {
    var Symbol4 = require_Symbol();
    var Uint8Array3 = require_Uint8Array();
    var eq2 = require_eq();
    var equalArrays2 = require_equalArrays();
    var mapToArray2 = require_mapToArray();
    var setToArray2 = require_setToArray();
    var COMPARE_PARTIAL_FLAG7 = 1;
    var COMPARE_UNORDERED_FLAG5 = 2;
    var boolTag3 = "[object Boolean]";
    var dateTag3 = "[object Date]";
    var errorTag3 = "[object Error]";
    var mapTag4 = "[object Map]";
    var numberTag3 = "[object Number]";
    var regexpTag3 = "[object RegExp]";
    var setTag4 = "[object Set]";
    var stringTag3 = "[object String]";
    var symbolTag3 = "[object Symbol]";
    var arrayBufferTag3 = "[object ArrayBuffer]";
    var dataViewTag4 = "[object DataView]";
    var symbolProto3 = Symbol4 ? Symbol4.prototype : void 0;
    var symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
    function equalByTag2(object, other, tag, bitmask, customizer, equalFunc, stack2) {
      switch (tag) {
        case dataViewTag4:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag3:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object), new Uint8Array3(other))) {
            return false;
          }
          return true;
        case boolTag3:
        case dateTag3:
        case numberTag3:
          return eq2(+object, +other);
        case errorTag3:
          return object.name == other.name && object.message == other.message;
        case regexpTag3:
        case stringTag3:
          return object == other + "";
        case mapTag4:
          var convert = mapToArray2;
        case setTag4:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG7;
          convert || (convert = setToArray2);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack2.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG5;
          stack2.set(object, other);
          var result = equalArrays2(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
          stack2["delete"](object);
          return result;
        case symbolTag3:
          if (symbolValueOf2) {
            return symbolValueOf2.call(object) == symbolValueOf2.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag2;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports2, module2) {
    function arrayPush2(array2, values2) {
      var index2 = -1, length3 = values2.length, offset2 = array2.length;
      while (++index2 < length3) {
        array2[offset2 + index2] = values2[index2];
      }
      return array2;
    }
    module2.exports = arrayPush2;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
    var arrayPush2 = require_arrayPush();
    var isArray2 = require_isArray();
    function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray2(object) ? result : arrayPush2(result, symbolsFunc(object));
    }
    module2.exports = baseGetAllKeys2;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports2, module2) {
    function arrayFilter2(array2, predicate) {
      var index2 = -1, length3 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length3) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter2;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports2, module2) {
    function stubArray2() {
      return [];
    }
    module2.exports = stubArray2;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports2, module2) {
    var arrayFilter2 = require_arrayFilter();
    var stubArray2 = require_stubArray();
    var objectProto16 = Object.prototype;
    var propertyIsEnumerable3 = objectProto16.propertyIsEnumerable;
    var nativeGetSymbols2 = Object.getOwnPropertySymbols;
    var getSymbols2 = !nativeGetSymbols2 ? stubArray2 : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter2(nativeGetSymbols2(object), function(symbol2) {
        return propertyIsEnumerable3.call(object, symbol2);
      });
    };
    module2.exports = getSymbols2;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports2, module2) {
    var baseGetAllKeys2 = require_baseGetAllKeys();
    var getSymbols2 = require_getSymbols();
    var keys2 = require_keys();
    function getAllKeys2(object) {
      return baseGetAllKeys2(object, keys2, getSymbols2);
    }
    module2.exports = getAllKeys2;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports2, module2) {
    var getAllKeys2 = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG7 = 1;
    var objectProto16 = Object.prototype;
    var hasOwnProperty13 = objectProto16.hasOwnProperty;
    function equalObjects2(object, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG7, objProps = getAllKeys2(object), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty13.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack2.get(object);
      var othStacked = stack2.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack2.set(object, other);
      stack2.set(other, object);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack2["delete"](object);
      stack2["delete"](other);
      return result;
    }
    module2.exports = equalObjects2;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports2, module2) {
    var getNative2 = require_getNative();
    var root3 = require_root();
    var DataView3 = getNative2(root3, "DataView");
    module2.exports = DataView3;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports2, module2) {
    var getNative2 = require_getNative();
    var root3 = require_root();
    var Promise3 = getNative2(root3, "Promise");
    module2.exports = Promise3;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports2, module2) {
    var getNative2 = require_getNative();
    var root3 = require_root();
    var Set3 = getNative2(root3, "Set");
    module2.exports = Set3;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports2, module2) {
    var getNative2 = require_getNative();
    var root3 = require_root();
    var WeakMap3 = getNative2(root3, "WeakMap");
    module2.exports = WeakMap3;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports2, module2) {
    var DataView3 = require_DataView();
    var Map3 = require_Map();
    var Promise3 = require_Promise();
    var Set3 = require_Set();
    var WeakMap3 = require_WeakMap();
    var baseGetTag2 = require_baseGetTag();
    var toSource2 = require_toSource();
    var mapTag4 = "[object Map]";
    var objectTag5 = "[object Object]";
    var promiseTag2 = "[object Promise]";
    var setTag4 = "[object Set]";
    var weakMapTag3 = "[object WeakMap]";
    var dataViewTag4 = "[object DataView]";
    var dataViewCtorString2 = toSource2(DataView3);
    var mapCtorString2 = toSource2(Map3);
    var promiseCtorString2 = toSource2(Promise3);
    var setCtorString2 = toSource2(Set3);
    var weakMapCtorString2 = toSource2(WeakMap3);
    var getTag2 = baseGetTag2;
    if (DataView3 && getTag2(new DataView3(new ArrayBuffer(1))) != dataViewTag4 || Map3 && getTag2(new Map3()) != mapTag4 || Promise3 && getTag2(Promise3.resolve()) != promiseTag2 || Set3 && getTag2(new Set3()) != setTag4 || WeakMap3 && getTag2(new WeakMap3()) != weakMapTag3) {
      getTag2 = function(value) {
        var result = baseGetTag2(value), Ctor = result == objectTag5 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString2:
              return dataViewTag4;
            case mapCtorString2:
              return mapTag4;
            case promiseCtorString2:
              return promiseTag2;
            case setCtorString2:
              return setTag4;
            case weakMapCtorString2:
              return weakMapTag3;
          }
        }
        return result;
      };
    }
    module2.exports = getTag2;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
    var Stack2 = require_Stack();
    var equalArrays2 = require_equalArrays();
    var equalByTag2 = require_equalByTag();
    var equalObjects2 = require_equalObjects();
    var getTag2 = require_getTag();
    var isArray2 = require_isArray();
    var isBuffer2 = require_isBuffer();
    var isTypedArray2 = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG7 = 1;
    var argsTag4 = "[object Arguments]";
    var arrayTag3 = "[object Array]";
    var objectTag5 = "[object Object]";
    var objectProto16 = Object.prototype;
    var hasOwnProperty13 = objectProto16.hasOwnProperty;
    function baseIsEqualDeep2(object, other, bitmask, customizer, equalFunc, stack2) {
      var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag3 : getTag2(object), othTag = othIsArr ? arrayTag3 : getTag2(other);
      objTag = objTag == argsTag4 ? objectTag5 : objTag;
      othTag = othTag == argsTag4 ? objectTag5 : othTag;
      var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer2(object)) {
        if (!isBuffer2(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack2 || (stack2 = new Stack2());
        return objIsArr || isTypedArray2(object) ? equalArrays2(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag2(object, other, objTag, bitmask, customizer, equalFunc, stack2);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG7)) {
        var objIsWrapped = objIsObj && hasOwnProperty13.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty13.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack2 || (stack2 = new Stack2());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack2 || (stack2 = new Stack2());
      return equalObjects2(object, other, bitmask, customizer, equalFunc, stack2);
    }
    module2.exports = baseIsEqualDeep2;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
    var baseIsEqualDeep2 = require_baseIsEqualDeep();
    var isObjectLike2 = require_isObjectLike();
    function baseIsEqual2(value, other, bitmask, customizer, stack2) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep2(value, other, bitmask, customizer, baseIsEqual2, stack2);
    }
    module2.exports = baseIsEqual2;
  }
});

// node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
    var Stack2 = require_Stack();
    var baseIsEqual2 = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG7 = 1;
    var COMPARE_UNORDERED_FLAG5 = 2;
    function baseIsMatch2(object, source, matchData, customizer) {
      var index2 = matchData.length, length3 = index2, noCustomizer = !customizer;
      if (object == null) {
        return !length3;
      }
      object = Object(object);
      while (index2--) {
        var data = matchData[index2];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index2 < length3) {
        data = matchData[index2];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack2 = new Stack2();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack2);
          }
          if (!(result === void 0 ? baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG7 | COMPARE_UNORDERED_FLAG5, customizer, stack2) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module2.exports = baseIsMatch2;
  }
});

// node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
    var isObject3 = require_isObject();
    function isStrictComparable2(value) {
      return value === value && !isObject3(value);
    }
    module2.exports = isStrictComparable2;
  }
});

// node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "node_modules/lodash/_getMatchData.js"(exports2, module2) {
    var isStrictComparable2 = require_isStrictComparable();
    var keys2 = require_keys();
    function getMatchData2(object) {
      var result = keys2(object), length3 = result.length;
      while (length3--) {
        var key = result[length3], value = object[key];
        result[length3] = [key, value, isStrictComparable2(value)];
      }
      return result;
    }
    module2.exports = getMatchData2;
  }
});

// node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
    function matchesStrictComparable2(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    module2.exports = matchesStrictComparable2;
  }
});

// node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "node_modules/lodash/_baseMatches.js"(exports2, module2) {
    var baseIsMatch2 = require_baseIsMatch();
    var getMatchData2 = require_getMatchData();
    var matchesStrictComparable2 = require_matchesStrictComparable();
    function baseMatches2(source) {
      var matchData = getMatchData2(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable2(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch2(object, source, matchData);
      };
    }
    module2.exports = baseMatches2;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports2, module2) {
    var baseGetTag2 = require_baseGetTag();
    var isObjectLike2 = require_isObjectLike();
    var symbolTag3 = "[object Symbol]";
    function isSymbol3(value) {
      return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag3;
    }
    module2.exports = isSymbol3;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var isSymbol3 = require_isSymbol();
    var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp2 = /^\w*$/;
    function isKey2(value, object) {
      if (isArray2(value)) {
        return false;
      }
      var type3 = typeof value;
      if (type3 == "number" || type3 == "symbol" || type3 == "boolean" || value == null || isSymbol3(value)) {
        return true;
      }
      return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object != null && value in Object(object);
    }
    module2.exports = isKey2;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports2, module2) {
    var MapCache2 = require_MapCache();
    var FUNC_ERROR_TEXT4 = "Expected a function";
    function memoize2(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT4);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize2.Cache || MapCache2)();
      return memoized;
    }
    memoize2.Cache = MapCache2;
    module2.exports = memoize2;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
    var memoize2 = require_memoize();
    var MAX_MEMOIZE_SIZE2 = 500;
    function memoizeCapped2(func) {
      var result = memoize2(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE2) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module2.exports = memoizeCapped2;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports2, module2) {
    var memoizeCapped2 = require_memoizeCapped();
    var rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar2 = /\\(\\)?/g;
    var stringToPath2 = memoizeCapped2(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName2, function(match, number6, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar2, "$1") : number6 || match);
      });
      return result;
    });
    module2.exports = stringToPath2;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports2, module2) {
    var Symbol4 = require_Symbol();
    var arrayMap2 = require_arrayMap();
    var isArray2 = require_isArray();
    var isSymbol3 = require_isSymbol();
    var INFINITY3 = 1 / 0;
    var symbolProto3 = Symbol4 ? Symbol4.prototype : void 0;
    var symbolToString2 = symbolProto3 ? symbolProto3.toString : void 0;
    function baseToString2(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray2(value)) {
        return arrayMap2(value, baseToString2) + "";
      }
      if (isSymbol3(value)) {
        return symbolToString2 ? symbolToString2.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY3 ? "-0" : result;
    }
    module2.exports = baseToString2;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports2, module2) {
    var baseToString2 = require_baseToString();
    function toString3(value) {
      return value == null ? "" : baseToString2(value);
    }
    module2.exports = toString3;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var isKey2 = require_isKey();
    var stringToPath2 = require_stringToPath();
    var toString3 = require_toString();
    function castPath2(value, object) {
      if (isArray2(value)) {
        return value;
      }
      return isKey2(value, object) ? [value] : stringToPath2(toString3(value));
    }
    module2.exports = castPath2;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports2, module2) {
    var isSymbol3 = require_isSymbol();
    var INFINITY3 = 1 / 0;
    function toKey2(value) {
      if (typeof value == "string" || isSymbol3(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY3 ? "-0" : result;
    }
    module2.exports = toKey2;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports2, module2) {
    var castPath2 = require_castPath();
    var toKey2 = require_toKey();
    function baseGet2(object, path2) {
      path2 = castPath2(path2, object);
      var index2 = 0, length3 = path2.length;
      while (object != null && index2 < length3) {
        object = object[toKey2(path2[index2++])];
      }
      return index2 && index2 == length3 ? object : void 0;
    }
    module2.exports = baseGet2;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports2, module2) {
    var baseGet2 = require_baseGet();
    function get7(object, path2, defaultValue) {
      var result = object == null ? void 0 : baseGet2(object, path2);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get7;
  }
});

// node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/lodash/_baseHasIn.js"(exports2, module2) {
    function baseHasIn2(object, key) {
      return object != null && key in Object(object);
    }
    module2.exports = baseHasIn2;
  }
});

// node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/lodash/_hasPath.js"(exports2, module2) {
    var castPath2 = require_castPath();
    var isArguments2 = require_isArguments();
    var isArray2 = require_isArray();
    var isIndex2 = require_isIndex();
    var isLength2 = require_isLength();
    var toKey2 = require_toKey();
    function hasPath2(object, path2, hasFunc) {
      path2 = castPath2(path2, object);
      var index2 = -1, length3 = path2.length, result = false;
      while (++index2 < length3) {
        var key = toKey2(path2[index2]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index2 != length3) {
        return result;
      }
      length3 = object == null ? 0 : object.length;
      return !!length3 && isLength2(length3) && isIndex2(key, length3) && (isArray2(object) || isArguments2(object));
    }
    module2.exports = hasPath2;
  }
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/lodash/hasIn.js"(exports2, module2) {
    var baseHasIn2 = require_baseHasIn();
    var hasPath2 = require_hasPath();
    function hasIn2(object, path2) {
      return object != null && hasPath2(object, path2, baseHasIn2);
    }
    module2.exports = hasIn2;
  }
});

// node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
    var baseIsEqual2 = require_baseIsEqual();
    var get7 = require_get();
    var hasIn2 = require_hasIn();
    var isKey2 = require_isKey();
    var isStrictComparable2 = require_isStrictComparable();
    var matchesStrictComparable2 = require_matchesStrictComparable();
    var toKey2 = require_toKey();
    var COMPARE_PARTIAL_FLAG7 = 1;
    var COMPARE_UNORDERED_FLAG5 = 2;
    function baseMatchesProperty2(path2, srcValue) {
      if (isKey2(path2) && isStrictComparable2(srcValue)) {
        return matchesStrictComparable2(toKey2(path2), srcValue);
      }
      return function(object) {
        var objValue = get7(object, path2);
        return objValue === void 0 && objValue === srcValue ? hasIn2(object, path2) : baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG7 | COMPARE_UNORDERED_FLAG5);
      };
    }
    module2.exports = baseMatchesProperty2;
  }
});

// node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/lodash/_baseProperty.js"(exports2, module2) {
    function baseProperty2(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    module2.exports = baseProperty2;
  }
});

// node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
    var baseGet2 = require_baseGet();
    function basePropertyDeep2(path2) {
      return function(object) {
        return baseGet2(object, path2);
      };
    }
    module2.exports = basePropertyDeep2;
  }
});

// node_modules/lodash/property.js
var require_property = __commonJS({
  "node_modules/lodash/property.js"(exports2, module2) {
    var baseProperty2 = require_baseProperty();
    var basePropertyDeep2 = require_basePropertyDeep();
    var isKey2 = require_isKey();
    var toKey2 = require_toKey();
    function property2(path2) {
      return isKey2(path2) ? baseProperty2(toKey2(path2)) : basePropertyDeep2(path2);
    }
    module2.exports = property2;
  }
});

// node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "node_modules/lodash/_baseIteratee.js"(exports2, module2) {
    var baseMatches2 = require_baseMatches();
    var baseMatchesProperty2 = require_baseMatchesProperty();
    var identity9 = require_identity();
    var isArray2 = require_isArray();
    var property2 = require_property();
    function baseIteratee2(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity9;
      }
      if (typeof value == "object") {
        return isArray2(value) ? baseMatchesProperty2(value[0], value[1]) : baseMatches2(value);
      }
      return property2(value);
    }
    module2.exports = baseIteratee2;
  }
});

// node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "node_modules/lodash/_createBaseEach.js"(exports2, module2) {
    var isArrayLike2 = require_isArrayLike();
    function createBaseEach2(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike2(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length3 = collection.length, index2 = fromRight ? length3 : -1, iterable = Object(collection);
        while (fromRight ? index2-- : ++index2 < length3) {
          if (iteratee(iterable[index2], index2, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module2.exports = createBaseEach2;
  }
});

// node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "node_modules/lodash/_baseEach.js"(exports2, module2) {
    var baseForOwn2 = require_baseForOwn();
    var createBaseEach2 = require_createBaseEach();
    var baseEach2 = createBaseEach2(baseForOwn2);
    module2.exports = baseEach2;
  }
});

// node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "node_modules/lodash/_baseMap.js"(exports2, module2) {
    var baseEach2 = require_baseEach();
    var isArrayLike2 = require_isArrayLike();
    function baseMap2(collection, iteratee) {
      var index2 = -1, result = isArrayLike2(collection) ? Array(collection.length) : [];
      baseEach2(collection, function(value, key, collection2) {
        result[++index2] = iteratee(value, key, collection2);
      });
      return result;
    }
    module2.exports = baseMap2;
  }
});

// node_modules/lodash/map.js
var require_map = __commonJS({
  "node_modules/lodash/map.js"(exports2, module2) {
    var arrayMap2 = require_arrayMap();
    var baseIteratee2 = require_baseIteratee();
    var baseMap2 = require_baseMap();
    var isArray2 = require_isArray();
    function map4(collection, iteratee) {
      var func = isArray2(collection) ? arrayMap2 : baseMap2;
      return func(collection, baseIteratee2(iteratee, 3));
    }
    module2.exports = map4;
  }
});

// node_modules/reactcss/lib/flattenNames.js
var require_flattenNames = __commonJS({
  "node_modules/reactcss/lib/flattenNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.flattenNames = void 0;
    var _isString2 = require_isString();
    var _isString3 = _interopRequireDefault(_isString2);
    var _forOwn2 = require_forOwn();
    var _forOwn3 = _interopRequireDefault(_forOwn2);
    var _isPlainObject2 = require_isPlainObject();
    var _isPlainObject3 = _interopRequireDefault(_isPlainObject2);
    var _map2 = require_map();
    var _map3 = _interopRequireDefault(_map2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var flattenNames = exports2.flattenNames = function flattenNames2() {
      var things = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var names2 = [];
      (0, _map3.default)(things, function(thing) {
        if (Array.isArray(thing)) {
          flattenNames2(thing).map(function(name) {
            return names2.push(name);
          });
        } else if ((0, _isPlainObject3.default)(thing)) {
          (0, _forOwn3.default)(thing, function(value, key) {
            value === true && names2.push(key);
            names2.push(key + "-" + value);
          });
        } else if ((0, _isString3.default)(thing)) {
          names2.push(thing);
        }
      });
      return names2;
    };
    exports2.default = flattenNames;
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports2, module2) {
    function arrayEach2(array2, iteratee) {
      var index2 = -1, length3 = array2 == null ? 0 : array2.length;
      while (++index2 < length3) {
        if (iteratee(array2[index2], index2, array2) === false) {
          break;
        }
      }
      return array2;
    }
    module2.exports = arrayEach2;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports2, module2) {
    var getNative2 = require_getNative();
    var defineProperty2 = function() {
      try {
        var func = getNative2(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e9) {
      }
    }();
    module2.exports = defineProperty2;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports2, module2) {
    var defineProperty2 = require_defineProperty();
    function baseAssignValue2(object, key, value) {
      if (key == "__proto__" && defineProperty2) {
        defineProperty2(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module2.exports = baseAssignValue2;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports2, module2) {
    var baseAssignValue2 = require_baseAssignValue();
    var eq2 = require_eq();
    var objectProto16 = Object.prototype;
    var hasOwnProperty13 = objectProto16.hasOwnProperty;
    function assignValue2(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty13.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue2(object, key, value);
      }
    }
    module2.exports = assignValue2;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports2, module2) {
    var assignValue2 = require_assignValue();
    var baseAssignValue2 = require_baseAssignValue();
    function copyObject2(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index2 = -1, length3 = props.length;
      while (++index2 < length3) {
        var key = props[index2];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue2(object, key, newValue);
        } else {
          assignValue2(object, key, newValue);
        }
      }
      return object;
    }
    module2.exports = copyObject2;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports2, module2) {
    var copyObject2 = require_copyObject();
    var keys2 = require_keys();
    function baseAssign(object, source) {
      return object && copyObject2(source, keys2(source), object);
    }
    module2.exports = baseAssign;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports2, module2) {
    function nativeKeysIn2(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = nativeKeysIn2;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports2, module2) {
    var isObject3 = require_isObject();
    var isPrototype2 = require_isPrototype();
    var nativeKeysIn2 = require_nativeKeysIn();
    var objectProto16 = Object.prototype;
    var hasOwnProperty13 = objectProto16.hasOwnProperty;
    function baseKeysIn2(object) {
      if (!isObject3(object)) {
        return nativeKeysIn2(object);
      }
      var isProto = isPrototype2(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty13.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeysIn2;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports2, module2) {
    var arrayLikeKeys2 = require_arrayLikeKeys();
    var baseKeysIn2 = require_baseKeysIn();
    var isArrayLike2 = require_isArrayLike();
    function keysIn2(object) {
      return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn2(object);
    }
    module2.exports = keysIn2;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports2, module2) {
    var copyObject2 = require_copyObject();
    var keysIn2 = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject2(source, keysIn2(source), object);
    }
    module2.exports = baseAssignIn;
  }
});

// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/lodash/_cloneBuffer.js"(exports2, module2) {
    var root3 = require_root();
    var freeExports4 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule4 = freeExports4 && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
    var Buffer4 = moduleExports4 ? root3.Buffer : void 0;
    var allocUnsafe2 = Buffer4 ? Buffer4.allocUnsafe : void 0;
    function cloneBuffer2(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length3 = buffer.length, result = allocUnsafe2 ? allocUnsafe2(length3) : new buffer.constructor(length3);
      buffer.copy(result);
      return result;
    }
    module2.exports = cloneBuffer2;
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports2, module2) {
    function copyArray2(source, array2) {
      var index2 = -1, length3 = source.length;
      array2 || (array2 = Array(length3));
      while (++index2 < length3) {
        array2[index2] = source[index2];
      }
      return array2;
    }
    module2.exports = copyArray2;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports2, module2) {
    var copyObject2 = require_copyObject();
    var getSymbols2 = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject2(source, getSymbols2(source), object);
    }
    module2.exports = copySymbols;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports2, module2) {
    var arrayPush2 = require_arrayPush();
    var getPrototype2 = require_getPrototype();
    var getSymbols2 = require_getSymbols();
    var stubArray2 = require_stubArray();
    var nativeGetSymbols2 = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols2 ? stubArray2 : function(object) {
      var result = [];
      while (object) {
        arrayPush2(result, getSymbols2(object));
        object = getPrototype2(object);
      }
      return result;
    };
    module2.exports = getSymbolsIn;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports2, module2) {
    var copyObject2 = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject2(source, getSymbolsIn(source), object);
    }
    module2.exports = copySymbolsIn;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports2, module2) {
    var baseGetAllKeys2 = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn2 = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys2(object, keysIn2, getSymbolsIn);
    }
    module2.exports = getAllKeysIn;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports2, module2) {
    var objectProto16 = Object.prototype;
    var hasOwnProperty13 = objectProto16.hasOwnProperty;
    function initCloneArray(array2) {
      var length3 = array2.length, result = new array2.constructor(length3);
      if (length3 && typeof array2[0] == "string" && hasOwnProperty13.call(array2, "index")) {
        result.index = array2.index;
        result.input = array2.input;
      }
      return result;
    }
    module2.exports = initCloneArray;
  }
});

// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/lodash/_cloneArrayBuffer.js"(exports2, module2) {
    var Uint8Array3 = require_Uint8Array();
    function cloneArrayBuffer2(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array3(result).set(new Uint8Array3(arrayBuffer));
      return result;
    }
    module2.exports = cloneArrayBuffer2;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports2, module2) {
    var cloneArrayBuffer2 = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module2.exports = cloneDataView;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports2, module2) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module2.exports = cloneRegExp;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports2, module2) {
    var Symbol4 = require_Symbol();
    var symbolProto3 = Symbol4 ? Symbol4.prototype : void 0;
    var symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
    function cloneSymbol(symbol2) {
      return symbolValueOf2 ? Object(symbolValueOf2.call(symbol2)) : {};
    }
    module2.exports = cloneSymbol;
  }
});

// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/lodash/_cloneTypedArray.js"(exports2, module2) {
    var cloneArrayBuffer2 = require_cloneArrayBuffer();
    function cloneTypedArray2(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module2.exports = cloneTypedArray2;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports2, module2) {
    var cloneArrayBuffer2 = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray2 = require_cloneTypedArray();
    var boolTag3 = "[object Boolean]";
    var dateTag3 = "[object Date]";
    var mapTag4 = "[object Map]";
    var numberTag3 = "[object Number]";
    var regexpTag3 = "[object RegExp]";
    var setTag4 = "[object Set]";
    var stringTag3 = "[object String]";
    var symbolTag3 = "[object Symbol]";
    var arrayBufferTag3 = "[object ArrayBuffer]";
    var dataViewTag4 = "[object DataView]";
    var float32Tag2 = "[object Float32Array]";
    var float64Tag2 = "[object Float64Array]";
    var int8Tag2 = "[object Int8Array]";
    var int16Tag2 = "[object Int16Array]";
    var int32Tag2 = "[object Int32Array]";
    var uint8Tag2 = "[object Uint8Array]";
    var uint8ClampedTag2 = "[object Uint8ClampedArray]";
    var uint16Tag2 = "[object Uint16Array]";
    var uint32Tag2 = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag3:
          return cloneArrayBuffer2(object);
        case boolTag3:
        case dateTag3:
          return new Ctor(+object);
        case dataViewTag4:
          return cloneDataView(object, isDeep);
        case float32Tag2:
        case float64Tag2:
        case int8Tag2:
        case int16Tag2:
        case int32Tag2:
        case uint8Tag2:
        case uint8ClampedTag2:
        case uint16Tag2:
        case uint32Tag2:
          return cloneTypedArray2(object, isDeep);
        case mapTag4:
          return new Ctor();
        case numberTag3:
        case stringTag3:
          return new Ctor(object);
        case regexpTag3:
          return cloneRegExp(object);
        case setTag4:
          return new Ctor();
        case symbolTag3:
          return cloneSymbol(object);
      }
    }
    module2.exports = initCloneByTag;
  }
});

// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/lodash/_baseCreate.js"(exports2, module2) {
    var isObject3 = require_isObject();
    var objectCreate2 = Object.create;
    var baseCreate2 = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject3(proto)) {
          return {};
        }
        if (objectCreate2) {
          return objectCreate2(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module2.exports = baseCreate2;
  }
});

// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/lodash/_initCloneObject.js"(exports2, module2) {
    var baseCreate2 = require_baseCreate();
    var getPrototype2 = require_getPrototype();
    var isPrototype2 = require_isPrototype();
    function initCloneObject2(object) {
      return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate2(getPrototype2(object)) : {};
    }
    module2.exports = initCloneObject2;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports2, module2) {
    var getTag2 = require_getTag();
    var isObjectLike2 = require_isObjectLike();
    var mapTag4 = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike2(value) && getTag2(value) == mapTag4;
    }
    module2.exports = baseIsMap;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports2, module2) {
    var baseIsMap = require_baseIsMap();
    var baseUnary2 = require_baseUnary();
    var nodeUtil2 = require_nodeUtil();
    var nodeIsMap = nodeUtil2 && nodeUtil2.isMap;
    var isMap = nodeIsMap ? baseUnary2(nodeIsMap) : baseIsMap;
    module2.exports = isMap;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports2, module2) {
    var getTag2 = require_getTag();
    var isObjectLike2 = require_isObjectLike();
    var setTag4 = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike2(value) && getTag2(value) == setTag4;
    }
    module2.exports = baseIsSet;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports2, module2) {
    var baseIsSet = require_baseIsSet();
    var baseUnary2 = require_baseUnary();
    var nodeUtil2 = require_nodeUtil();
    var nodeIsSet = nodeUtil2 && nodeUtil2.isSet;
    var isSet = nodeIsSet ? baseUnary2(nodeIsSet) : baseIsSet;
    module2.exports = isSet;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports2, module2) {
    var Stack2 = require_Stack();
    var arrayEach2 = require_arrayEach();
    var assignValue2 = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer2 = require_cloneBuffer();
    var copyArray2 = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys2 = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag2 = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject2 = require_initCloneObject();
    var isArray2 = require_isArray();
    var isBuffer2 = require_isBuffer();
    var isMap = require_isMap();
    var isObject3 = require_isObject();
    var isSet = require_isSet();
    var keys2 = require_keys();
    var keysIn2 = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag4 = "[object Arguments]";
    var arrayTag3 = "[object Array]";
    var boolTag3 = "[object Boolean]";
    var dateTag3 = "[object Date]";
    var errorTag3 = "[object Error]";
    var funcTag3 = "[object Function]";
    var genTag2 = "[object GeneratorFunction]";
    var mapTag4 = "[object Map]";
    var numberTag3 = "[object Number]";
    var objectTag5 = "[object Object]";
    var regexpTag3 = "[object RegExp]";
    var setTag4 = "[object Set]";
    var stringTag3 = "[object String]";
    var symbolTag3 = "[object Symbol]";
    var weakMapTag3 = "[object WeakMap]";
    var arrayBufferTag3 = "[object ArrayBuffer]";
    var dataViewTag4 = "[object DataView]";
    var float32Tag2 = "[object Float32Array]";
    var float64Tag2 = "[object Float64Array]";
    var int8Tag2 = "[object Int8Array]";
    var int16Tag2 = "[object Int16Array]";
    var int32Tag2 = "[object Int32Array]";
    var uint8Tag2 = "[object Uint8Array]";
    var uint8ClampedTag2 = "[object Uint8ClampedArray]";
    var uint16Tag2 = "[object Uint16Array]";
    var uint32Tag2 = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag4] = cloneableTags[arrayTag3] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag2] = cloneableTags[float64Tag2] = cloneableTags[int8Tag2] = cloneableTags[int16Tag2] = cloneableTags[int32Tag2] = cloneableTags[mapTag4] = cloneableTags[numberTag3] = cloneableTags[objectTag5] = cloneableTags[regexpTag3] = cloneableTags[setTag4] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag2] = cloneableTags[uint8ClampedTag2] = cloneableTags[uint16Tag2] = cloneableTags[uint32Tag2] = true;
    cloneableTags[errorTag3] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
    function baseClone(value, bitmask, customizer, key, object, stack2) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack2) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject3(value)) {
        return value;
      }
      var isArr = isArray2(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray2(value, result);
        }
      } else {
        var tag = getTag2(value), isFunc = tag == funcTag3 || tag == genTag2;
        if (isBuffer2(value)) {
          return cloneBuffer2(value, isDeep);
        }
        if (tag == objectTag5 || tag == argsTag4 || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject2(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack2 || (stack2 = new Stack2());
      var stacked = stack2.get(value);
      if (stacked) {
        return stacked;
      }
      stack2.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys2 : isFlat ? keysIn2 : keys2;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach2(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue2(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
      });
      return result;
    }
    module2.exports = baseClone;
  }
});

// node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/lodash/cloneDeep.js"(exports2, module2) {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module2.exports = cloneDeep;
  }
});

// node_modules/reactcss/lib/mergeClasses.js
var require_mergeClasses = __commonJS({
  "node_modules/reactcss/lib/mergeClasses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.mergeClasses = void 0;
    var _forOwn2 = require_forOwn();
    var _forOwn3 = _interopRequireDefault(_forOwn2);
    var _cloneDeep2 = require_cloneDeep();
    var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);
    var _extends10 = Object.assign || function(target) {
      for (var i6 = 1; i6 < arguments.length; i6++) {
        var source = arguments[i6];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var mergeClasses = exports2.mergeClasses = function mergeClasses2(classes) {
      var activeNames = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var styles2 = classes.default && (0, _cloneDeep3.default)(classes.default) || {};
      activeNames.map(function(name) {
        var toMerge = classes[name];
        if (toMerge) {
          (0, _forOwn3.default)(toMerge, function(value, key) {
            if (!styles2[key]) {
              styles2[key] = {};
            }
            styles2[key] = _extends10({}, styles2[key], toMerge[key]);
          });
        }
        return name;
      });
      return styles2;
    };
    exports2.default = mergeClasses;
  }
});

// node_modules/reactcss/lib/autoprefix.js
var require_autoprefix = __commonJS({
  "node_modules/reactcss/lib/autoprefix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.autoprefix = void 0;
    var _forOwn2 = require_forOwn();
    var _forOwn3 = _interopRequireDefault(_forOwn2);
    var _extends10 = Object.assign || function(target) {
      for (var i6 = 1; i6 < arguments.length; i6++) {
        var source = arguments[i6];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var transforms = {
      borderRadius: function borderRadius(value) {
        return {
          msBorderRadius: value,
          MozBorderRadius: value,
          OBorderRadius: value,
          WebkitBorderRadius: value,
          borderRadius: value
        };
      },
      boxShadow: function boxShadow(value) {
        return {
          msBoxShadow: value,
          MozBoxShadow: value,
          OBoxShadow: value,
          WebkitBoxShadow: value,
          boxShadow: value
        };
      },
      userSelect: function userSelect(value) {
        return {
          WebkitTouchCallout: value,
          KhtmlUserSelect: value,
          MozUserSelect: value,
          msUserSelect: value,
          WebkitUserSelect: value,
          userSelect: value
        };
      },
      flex: function flex(value) {
        return {
          WebkitBoxFlex: value,
          MozBoxFlex: value,
          WebkitFlex: value,
          msFlex: value,
          flex: value
        };
      },
      flexBasis: function flexBasis(value) {
        return {
          WebkitFlexBasis: value,
          flexBasis: value
        };
      },
      justifyContent: function justifyContent(value) {
        return {
          WebkitJustifyContent: value,
          justifyContent: value
        };
      },
      transition: function transition2(value) {
        return {
          msTransition: value,
          MozTransition: value,
          OTransition: value,
          WebkitTransition: value,
          transition: value
        };
      },
      transform: function transform2(value) {
        return {
          msTransform: value,
          MozTransform: value,
          OTransform: value,
          WebkitTransform: value,
          transform: value
        };
      },
      absolute: function absolute(value) {
        var direction = value && value.split(" ");
        return {
          position: "absolute",
          top: direction && direction[0],
          right: direction && direction[1],
          bottom: direction && direction[2],
          left: direction && direction[3]
        };
      },
      extend: function extend2(name, otherElementStyles) {
        var otherStyle = otherElementStyles[name];
        if (otherStyle) {
          return otherStyle;
        }
        return {
          "extend": name
        };
      }
    };
    var autoprefix = exports2.autoprefix = function autoprefix2(elements) {
      var prefixed = {};
      (0, _forOwn3.default)(elements, function(styles2, element) {
        var expanded = {};
        (0, _forOwn3.default)(styles2, function(value, key) {
          var transform2 = transforms[key];
          if (transform2) {
            expanded = _extends10({}, expanded, transform2(value));
          } else {
            expanded[key] = value;
          }
        });
        prefixed[element] = expanded;
      });
      return prefixed;
    };
    exports2.default = autoprefix;
  }
});

// node_modules/reactcss/lib/components/hover.js
var require_hover = __commonJS({
  "node_modules/reactcss/lib/components/hover.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.hover = void 0;
    var _extends10 = Object.assign || function(target) {
      for (var i6 = 1; i6 < arguments.length; i6++) {
        var source = arguments[i6];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _react = (init_react(), __toCommonJS(react_exports));
    var _react2 = _interopRequireDefault(_react);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck9(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn9(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits9(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var hover = exports2.hover = function hover2(Component) {
      var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
      return function(_React$Component) {
        _inherits9(Hover, _React$Component);
        function Hover() {
          var _ref;
          var _temp, _this, _ret;
          _classCallCheck9(this, Hover);
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return _ret = (_temp = (_this = _possibleConstructorReturn9(this, (_ref = Hover.__proto__ || Object.getPrototypeOf(Hover)).call.apply(_ref, [this].concat(args))), _this), _this.state = { hover: false }, _this.handleMouseOver = function() {
            return _this.setState({ hover: true });
          }, _this.handleMouseOut = function() {
            return _this.setState({ hover: false });
          }, _this.render = function() {
            return _react2.default.createElement(
              Span,
              { onMouseOver: _this.handleMouseOver, onMouseOut: _this.handleMouseOut },
              _react2.default.createElement(Component, _extends10({}, _this.props, _this.state))
            );
          }, _temp), _possibleConstructorReturn9(_this, _ret);
        }
        return Hover;
      }(_react2.default.Component);
    };
    exports2.default = hover;
  }
});

// node_modules/reactcss/lib/components/active.js
var require_active = __commonJS({
  "node_modules/reactcss/lib/components/active.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.active = void 0;
    var _extends10 = Object.assign || function(target) {
      for (var i6 = 1; i6 < arguments.length; i6++) {
        var source = arguments[i6];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _react = (init_react(), __toCommonJS(react_exports));
    var _react2 = _interopRequireDefault(_react);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck9(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn9(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits9(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var active = exports2.active = function active2(Component) {
      var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
      return function(_React$Component) {
        _inherits9(Active, _React$Component);
        function Active() {
          var _ref;
          var _temp, _this, _ret;
          _classCallCheck9(this, Active);
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return _ret = (_temp = (_this = _possibleConstructorReturn9(this, (_ref = Active.__proto__ || Object.getPrototypeOf(Active)).call.apply(_ref, [this].concat(args))), _this), _this.state = { active: false }, _this.handleMouseDown = function() {
            return _this.setState({ active: true });
          }, _this.handleMouseUp = function() {
            return _this.setState({ active: false });
          }, _this.render = function() {
            return _react2.default.createElement(
              Span,
              { onMouseDown: _this.handleMouseDown, onMouseUp: _this.handleMouseUp },
              _react2.default.createElement(Component, _extends10({}, _this.props, _this.state))
            );
          }, _temp), _possibleConstructorReturn9(_this, _ret);
        }
        return Active;
      }(_react2.default.Component);
    };
    exports2.default = active;
  }
});

// node_modules/reactcss/lib/loop.js
var require_loop = __commonJS({
  "node_modules/reactcss/lib/loop.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var loopable = function loopable2(i6, length3) {
      var props = {};
      var setProp = function setProp2(name) {
        var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        props[name] = value;
      };
      i6 === 0 && setProp("first-child");
      i6 === length3 - 1 && setProp("last-child");
      (i6 === 0 || i6 % 2 === 0) && setProp("even");
      Math.abs(i6 % 2) === 1 && setProp("odd");
      setProp("nth-child", i6);
      return props;
    };
    exports2.default = loopable;
  }
});

// node_modules/reactcss/lib/index.js
var require_lib = __commonJS({
  "node_modules/reactcss/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ReactCSS = exports2.loop = exports2.handleActive = exports2.handleHover = exports2.hover = void 0;
    var _flattenNames = require_flattenNames();
    var _flattenNames2 = _interopRequireDefault(_flattenNames);
    var _mergeClasses = require_mergeClasses();
    var _mergeClasses2 = _interopRequireDefault(_mergeClasses);
    var _autoprefix = require_autoprefix();
    var _autoprefix2 = _interopRequireDefault(_autoprefix);
    var _hover2 = require_hover();
    var _hover3 = _interopRequireDefault(_hover2);
    var _active = require_active();
    var _active2 = _interopRequireDefault(_active);
    var _loop2 = require_loop();
    var _loop3 = _interopRequireDefault(_loop2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.hover = _hover3.default;
    exports2.handleHover = _hover3.default;
    exports2.handleActive = _active2.default;
    exports2.loop = _loop3.default;
    var ReactCSS = exports2.ReactCSS = function ReactCSS2(classes) {
      for (var _len = arguments.length, activations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        activations[_key - 1] = arguments[_key];
      }
      var activeNames = (0, _flattenNames2.default)(activations);
      var merged = (0, _mergeClasses2.default)(classes, activeNames);
      return (0, _autoprefix2.default)(merged);
    };
    exports2.default = ReactCSS;
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type3) {
          return typeof type3 === "string" || typeof type3 === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type3 === REACT_FRAGMENT_TYPE || type3 === REACT_CONCURRENT_MODE_TYPE || type3 === REACT_PROFILER_TYPE || type3 === REACT_STRICT_MODE_TYPE || type3 === REACT_SUSPENSE_TYPE || type3 === REACT_SUSPENSE_LIST_TYPE || typeof type3 === "object" && type3 !== null && (type3.$$typeof === REACT_LAZY_TYPE || type3.$$typeof === REACT_MEMO_TYPE || type3.$$typeof === REACT_PROVIDER_TYPE || type3.$$typeof === REACT_CONTEXT_TYPE || type3.$$typeof === REACT_FORWARD_REF_TYPE || type3.$$typeof === REACT_FUNDAMENTAL_TYPE || type3.$$typeof === REACT_RESPONDER_TYPE || type3.$$typeof === REACT_SCOPE_TYPE || type3.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type3 = object.type;
                switch (type3) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type3;
                  default:
                    var $$typeofType = type3 && type3.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports2.AsyncMode = AsyncMode;
        exports2.ConcurrentMode = ConcurrentMode;
        exports2.ContextConsumer = ContextConsumer;
        exports2.ContextProvider = ContextProvider;
        exports2.Element = Element;
        exports2.ForwardRef = ForwardRef;
        exports2.Fragment = Fragment;
        exports2.Lazy = Lazy;
        exports2.Memo = Memo;
        exports2.Portal = Portal;
        exports2.Profiler = Profiler;
        exports2.StrictMode = StrictMode;
        exports2.Suspense = Suspense;
        exports2.isAsyncMode = isAsyncMode;
        exports2.isConcurrentMode = isConcurrentMode;
        exports2.isContextConsumer = isContextConsumer;
        exports2.isContextProvider = isContextProvider;
        exports2.isElement = isElement;
        exports2.isForwardRef = isForwardRef;
        exports2.isFragment = isFragment;
        exports2.isLazy = isLazy;
        exports2.isMemo = isMemo;
        exports2.isPortal = isPortal;
        exports2.isProfiler = isProfiler;
        exports2.isStrictMode = isStrictMode;
        exports2.isSuspense = isSuspense;
        exports2.isValidElementType = isValidElementType;
        exports2.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports2, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty13 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i6 = 0; i6 < 10; i6++) {
          test2["_" + String.fromCharCode(i6)] = i6;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n9) {
          return test2[n9];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to2 = toObject(target);
      var symbols2;
      for (var s8 = 1; s8 < arguments.length; s8++) {
        from = Object(arguments[s8]);
        for (var key in from) {
          if (hasOwnProperty13.call(from, key)) {
            to2[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols2 = getOwnPropertySymbols(from);
          for (var i6 = 0; i6 < symbols2.length; i6++) {
            if (propIsEnumerable.call(from, symbols2[i6])) {
              to2[symbols2[i6]] = from[symbols2[i6]];
            }
          }
        }
      }
      return to2;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports2, module2) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module2.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports2, module2) {
    module2.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports2, module2) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text2) {
        var message = "Warning: " + text2;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x6) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values2, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack2 = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack2 != null ? stack2 : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module2.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports2, module2) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text2) {
        var message = "Warning: " + text2;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x6) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module2.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x6, y5) {
        if (x6 === y5) {
          return x6 !== 0 || 1 / x6 === 1 / y5;
        } else {
          return x6 !== x6 && y5 !== y5;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i6 = 0; i6 < propValue.length; i6++) {
            var error = typeChecker(propValue, i6, componentName, location, propFullName + "[" + i6 + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i6 = 0; i6 < expectedValues.length; i6++) {
            if (is(propValue, expectedValues[i6])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type3 = getPreciseType(value);
            if (type3 === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i6 = 0; i6 < arrayOfTypeCheckers.length; i6++) {
          var checker = arrayOfTypeCheckers[i6];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i6 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i7 = 0; i7 < arrayOfTypeCheckers.length; i7++) {
            var checker2 = arrayOfTypeCheckers[i7];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type3) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type3 + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol3(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol3(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type3 = getPreciseType(value);
        switch (type3) {
          case "array":
          case "object":
            return "an " + type3;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type3;
          default:
            return type3;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports2, module2) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module2.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module2.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/@icons/material/UnfoldMoreHorizontalIcon.js
var require_UnfoldMoreHorizontalIcon = __commonJS({
  "node_modules/@icons/material/UnfoldMoreHorizontalIcon.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _extends10 = Object.assign || function(target) {
      for (var i6 = 1; i6 < arguments.length; i6++) {
        var source = arguments[i6];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _react = (init_react(), __toCommonJS(react_exports));
    var _react2 = _interopRequireDefault(_react);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutProperties(obj, keys2) {
      var target = {};
      for (var i6 in obj) {
        if (keys2.indexOf(i6) >= 0)
          continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i6))
          continue;
        target[i6] = obj[i6];
      }
      return target;
    }
    var DEFAULT_SIZE = 24;
    exports2.default = function(_ref) {
      var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE : _ref$height, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties(_ref, ["fill", "width", "height", "style"]);
      return _react2.default.createElement(
        "svg",
        _extends10({
          viewBox: "0 0 " + DEFAULT_SIZE + " " + DEFAULT_SIZE,
          style: _extends10({ fill, width, height }, style)
        }, props),
        _react2.default.createElement("path", { d: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z" })
      );
    };
  }
});

// node_modules/@icons/material/CheckIcon.js
var require_CheckIcon = __commonJS({
  "node_modules/@icons/material/CheckIcon.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _extends10 = Object.assign || function(target) {
      for (var i6 = 1; i6 < arguments.length; i6++) {
        var source = arguments[i6];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _react = (init_react(), __toCommonJS(react_exports));
    var _react2 = _interopRequireDefault(_react);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutProperties(obj, keys2) {
      var target = {};
      for (var i6 in obj) {
        if (keys2.indexOf(i6) >= 0)
          continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i6))
          continue;
        target[i6] = obj[i6];
      }
      return target;
    }
    var DEFAULT_SIZE = 24;
    exports2.default = function(_ref) {
      var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE : _ref$height, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties(_ref, ["fill", "width", "height", "style"]);
      return _react2.default.createElement(
        "svg",
        _extends10({
          viewBox: "0 0 " + DEFAULT_SIZE + " " + DEFAULT_SIZE,
          style: _extends10({ fill, width, height }, style)
        }, props),
        _react2.default.createElement("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" })
      );
    };
  }
});

// node_modules/@lit/reactive-element/css-tag.js
var t = window;
var e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s = Symbol();
var n = /* @__PURE__ */ new WeakMap();
var o = class {
  constructor(t6, e9, n9) {
    if (this._$cssResult$ = true, n9 !== s)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t6, this.t = e9;
  }
  get styleSheet() {
    let t6 = this.o;
    const s8 = this.t;
    if (e && void 0 === t6) {
      const e9 = void 0 !== s8 && 1 === s8.length;
      e9 && (t6 = n.get(s8)), void 0 === t6 && ((this.o = t6 = new CSSStyleSheet()).replaceSync(this.cssText), e9 && n.set(s8, t6));
    }
    return t6;
  }
  toString() {
    return this.cssText;
  }
};
var r = (t6) => new o("string" == typeof t6 ? t6 : t6 + "", void 0, s);
var i = (t6, ...e9) => {
  const n9 = 1 === t6.length ? t6[0] : e9.reduce((e11, s8, n10) => e11 + ((t7) => {
    if (true === t7._$cssResult$)
      return t7.cssText;
    if ("number" == typeof t7)
      return t7;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t7 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s8) + t6[n10 + 1], t6[0]);
  return new o(n9, t6, s);
};
var S = (s8, n9) => {
  e ? s8.adoptedStyleSheets = n9.map((t6) => t6 instanceof CSSStyleSheet ? t6 : t6.styleSheet) : n9.forEach((e9) => {
    const n10 = document.createElement("style"), o8 = t.litNonce;
    void 0 !== o8 && n10.setAttribute("nonce", o8), n10.textContent = e9.cssText, s8.appendChild(n10);
  });
};
var c = e ? (t6) => t6 : (t6) => t6 instanceof CSSStyleSheet ? ((t7) => {
  let e9 = "";
  for (const s8 of t7.cssRules)
    e9 += s8.cssText;
  return r(e9);
})(t6) : t6;

// node_modules/@lit/reactive-element/reactive-element.js
var s2;
var e2 = window;
var r2 = e2.trustedTypes;
var h = r2 ? r2.emptyScript : "";
var o2 = e2.reactiveElementPolyfillSupport;
var n2 = { toAttribute(t6, i6) {
  switch (i6) {
    case Boolean:
      t6 = t6 ? h : null;
      break;
    case Object:
    case Array:
      t6 = null == t6 ? t6 : JSON.stringify(t6);
  }
  return t6;
}, fromAttribute(t6, i6) {
  let s8 = t6;
  switch (i6) {
    case Boolean:
      s8 = null !== t6;
      break;
    case Number:
      s8 = null === t6 ? null : Number(t6);
      break;
    case Object:
    case Array:
      try {
        s8 = JSON.parse(t6);
      } catch (t7) {
        s8 = null;
      }
  }
  return s8;
} };
var a = (t6, i6) => i6 !== t6 && (i6 == i6 || t6 == t6);
var l = { attribute: true, type: String, converter: n2, reflect: false, hasChanged: a };
var d = "finalized";
var u = class extends HTMLElement {
  constructor() {
    super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$El = null, this.u();
  }
  static addInitializer(t6) {
    var i6;
    this.finalize(), (null !== (i6 = this.h) && void 0 !== i6 ? i6 : this.h = []).push(t6);
  }
  static get observedAttributes() {
    this.finalize();
    const t6 = [];
    return this.elementProperties.forEach((i6, s8) => {
      const e9 = this._$Ep(s8, i6);
      void 0 !== e9 && (this._$Ev.set(e9, s8), t6.push(e9));
    }), t6;
  }
  static createProperty(t6, i6 = l) {
    if (i6.state && (i6.attribute = false), this.finalize(), this.elementProperties.set(t6, i6), !i6.noAccessor && !this.prototype.hasOwnProperty(t6)) {
      const s8 = "symbol" == typeof t6 ? Symbol() : "__" + t6, e9 = this.getPropertyDescriptor(t6, s8, i6);
      void 0 !== e9 && Object.defineProperty(this.prototype, t6, e9);
    }
  }
  static getPropertyDescriptor(t6, i6, s8) {
    return { get() {
      return this[i6];
    }, set(e9) {
      const r6 = this[t6];
      this[i6] = e9, this.requestUpdate(t6, r6, s8);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t6) {
    return this.elementProperties.get(t6) || l;
  }
  static finalize() {
    if (this.hasOwnProperty(d))
      return false;
    this[d] = true;
    const t6 = Object.getPrototypeOf(this);
    if (t6.finalize(), void 0 !== t6.h && (this.h = [...t6.h]), this.elementProperties = new Map(t6.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const t7 = this.properties, i6 = [...Object.getOwnPropertyNames(t7), ...Object.getOwnPropertySymbols(t7)];
      for (const s8 of i6)
        this.createProperty(s8, t7[s8]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), true;
  }
  static finalizeStyles(i6) {
    const s8 = [];
    if (Array.isArray(i6)) {
      const e9 = new Set(i6.flat(1 / 0).reverse());
      for (const i7 of e9)
        s8.unshift(c(i7));
    } else
      void 0 !== i6 && s8.push(c(i6));
    return s8;
  }
  static _$Ep(t6, i6) {
    const s8 = i6.attribute;
    return false === s8 ? void 0 : "string" == typeof s8 ? s8 : "string" == typeof t6 ? t6.toLowerCase() : void 0;
  }
  u() {
    var t6;
    this._$E_ = new Promise((t7) => this.enableUpdating = t7), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), null === (t6 = this.constructor.h) || void 0 === t6 || t6.forEach((t7) => t7(this));
  }
  addController(t6) {
    var i6, s8;
    (null !== (i6 = this._$ES) && void 0 !== i6 ? i6 : this._$ES = []).push(t6), void 0 !== this.renderRoot && this.isConnected && (null === (s8 = t6.hostConnected) || void 0 === s8 || s8.call(t6));
  }
  removeController(t6) {
    var i6;
    null === (i6 = this._$ES) || void 0 === i6 || i6.splice(this._$ES.indexOf(t6) >>> 0, 1);
  }
  _$Eg() {
    this.constructor.elementProperties.forEach((t6, i6) => {
      this.hasOwnProperty(i6) && (this._$Ei.set(i6, this[i6]), delete this[i6]);
    });
  }
  createRenderRoot() {
    var t6;
    const s8 = null !== (t6 = this.shadowRoot) && void 0 !== t6 ? t6 : this.attachShadow(this.constructor.shadowRootOptions);
    return S(s8, this.constructor.elementStyles), s8;
  }
  connectedCallback() {
    var t6;
    void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), null === (t6 = this._$ES) || void 0 === t6 || t6.forEach((t7) => {
      var i6;
      return null === (i6 = t7.hostConnected) || void 0 === i6 ? void 0 : i6.call(t7);
    });
  }
  enableUpdating(t6) {
  }
  disconnectedCallback() {
    var t6;
    null === (t6 = this._$ES) || void 0 === t6 || t6.forEach((t7) => {
      var i6;
      return null === (i6 = t7.hostDisconnected) || void 0 === i6 ? void 0 : i6.call(t7);
    });
  }
  attributeChangedCallback(t6, i6, s8) {
    this._$AK(t6, s8);
  }
  _$EO(t6, i6, s8 = l) {
    var e9;
    const r6 = this.constructor._$Ep(t6, s8);
    if (void 0 !== r6 && true === s8.reflect) {
      const h5 = (void 0 !== (null === (e9 = s8.converter) || void 0 === e9 ? void 0 : e9.toAttribute) ? s8.converter : n2).toAttribute(i6, s8.type);
      this._$El = t6, null == h5 ? this.removeAttribute(r6) : this.setAttribute(r6, h5), this._$El = null;
    }
  }
  _$AK(t6, i6) {
    var s8;
    const e9 = this.constructor, r6 = e9._$Ev.get(t6);
    if (void 0 !== r6 && this._$El !== r6) {
      const t7 = e9.getPropertyOptions(r6), h5 = "function" == typeof t7.converter ? { fromAttribute: t7.converter } : void 0 !== (null === (s8 = t7.converter) || void 0 === s8 ? void 0 : s8.fromAttribute) ? t7.converter : n2;
      this._$El = r6, this[r6] = h5.fromAttribute(i6, t7.type), this._$El = null;
    }
  }
  requestUpdate(t6, i6, s8) {
    let e9 = true;
    void 0 !== t6 && (((s8 = s8 || this.constructor.getPropertyOptions(t6)).hasChanged || a)(this[t6], i6) ? (this._$AL.has(t6) || this._$AL.set(t6, i6), true === s8.reflect && this._$El !== t6 && (void 0 === this._$EC && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t6, s8))) : e9 = false), !this.isUpdatePending && e9 && (this._$E_ = this._$Ej());
  }
  async _$Ej() {
    this.isUpdatePending = true;
    try {
      await this._$E_;
    } catch (t7) {
      Promise.reject(t7);
    }
    const t6 = this.scheduleUpdate();
    return null != t6 && await t6, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t6;
    if (!this.isUpdatePending)
      return;
    this.hasUpdated, this._$Ei && (this._$Ei.forEach((t7, i7) => this[i7] = t7), this._$Ei = void 0);
    let i6 = false;
    const s8 = this._$AL;
    try {
      i6 = this.shouldUpdate(s8), i6 ? (this.willUpdate(s8), null === (t6 = this._$ES) || void 0 === t6 || t6.forEach((t7) => {
        var i7;
        return null === (i7 = t7.hostUpdate) || void 0 === i7 ? void 0 : i7.call(t7);
      }), this.update(s8)) : this._$Ek();
    } catch (t7) {
      throw i6 = false, this._$Ek(), t7;
    }
    i6 && this._$AE(s8);
  }
  willUpdate(t6) {
  }
  _$AE(t6) {
    var i6;
    null === (i6 = this._$ES) || void 0 === i6 || i6.forEach((t7) => {
      var i7;
      return null === (i7 = t7.hostUpdated) || void 0 === i7 ? void 0 : i7.call(t7);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t6)), this.updated(t6);
  }
  _$Ek() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$E_;
  }
  shouldUpdate(t6) {
    return true;
  }
  update(t6) {
    void 0 !== this._$EC && (this._$EC.forEach((t7, i6) => this._$EO(i6, this[i6], t7)), this._$EC = void 0), this._$Ek();
  }
  updated(t6) {
  }
  firstUpdated(t6) {
  }
};
u[d] = true, u.elementProperties = /* @__PURE__ */ new Map(), u.elementStyles = [], u.shadowRootOptions = { mode: "open" }, null == o2 || o2({ ReactiveElement: u }), (null !== (s2 = e2.reactiveElementVersions) && void 0 !== s2 ? s2 : e2.reactiveElementVersions = []).push("1.6.2");

// node_modules/lit-html/lit-html.js
var t2;
var i2 = window;
var s3 = i2.trustedTypes;
var e3 = s3 ? s3.createPolicy("lit-html", { createHTML: (t6) => t6 }) : void 0;
var o3 = "$lit$";
var n3 = `lit$${(Math.random() + "").slice(9)}$`;
var l2 = "?" + n3;
var h2 = `<${l2}>`;
var r3 = document;
var d2 = () => r3.createComment("");
var u2 = (t6) => null === t6 || "object" != typeof t6 && "function" != typeof t6;
var c2 = Array.isArray;
var v = (t6) => c2(t6) || "function" == typeof (null == t6 ? void 0 : t6[Symbol.iterator]);
var a2 = "[ 	\n\f\r]";
var f = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var _ = /-->/g;
var m = />/g;
var p = RegExp(`>|${a2}(?:([^\\s"'>=/]+)(${a2}*=${a2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var g = /'/g;
var $2 = /"/g;
var y = /^(?:script|style|textarea|title)$/i;
var w = (t6) => (i6, ...s8) => ({ _$litType$: t6, strings: i6, values: s8 });
var x = w(1);
var b = w(2);
var T = Symbol.for("lit-noChange");
var A = Symbol.for("lit-nothing");
var E = /* @__PURE__ */ new WeakMap();
var C = r3.createTreeWalker(r3, 129, null, false);
var P = (t6, i6) => {
  const s8 = t6.length - 1, l7 = [];
  let r6, d6 = 2 === i6 ? "<svg>" : "", u5 = f;
  for (let i7 = 0; i7 < s8; i7++) {
    const s9 = t6[i7];
    let e9, c10, v4 = -1, a7 = 0;
    for (; a7 < s9.length && (u5.lastIndex = a7, c10 = u5.exec(s9), null !== c10); )
      a7 = u5.lastIndex, u5 === f ? "!--" === c10[1] ? u5 = _ : void 0 !== c10[1] ? u5 = m : void 0 !== c10[2] ? (y.test(c10[2]) && (r6 = RegExp("</" + c10[2], "g")), u5 = p) : void 0 !== c10[3] && (u5 = p) : u5 === p ? ">" === c10[0] ? (u5 = null != r6 ? r6 : f, v4 = -1) : void 0 === c10[1] ? v4 = -2 : (v4 = u5.lastIndex - c10[2].length, e9 = c10[1], u5 = void 0 === c10[3] ? p : '"' === c10[3] ? $2 : g) : u5 === $2 || u5 === g ? u5 = p : u5 === _ || u5 === m ? u5 = f : (u5 = p, r6 = void 0);
    const w5 = u5 === p && t6[i7 + 1].startsWith("/>") ? " " : "";
    d6 += u5 === f ? s9 + h2 : v4 >= 0 ? (l7.push(e9), s9.slice(0, v4) + o3 + s9.slice(v4) + n3 + w5) : s9 + n3 + (-2 === v4 ? (l7.push(void 0), i7) : w5);
  }
  const c9 = d6 + (t6[s8] || "<?>") + (2 === i6 ? "</svg>" : "");
  if (!Array.isArray(t6) || !t6.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return [void 0 !== e3 ? e3.createHTML(c9) : c9, l7];
};
var V = class _V {
  constructor({ strings: t6, _$litType$: i6 }, e9) {
    let h5;
    this.parts = [];
    let r6 = 0, u5 = 0;
    const c9 = t6.length - 1, v4 = this.parts, [a7, f4] = P(t6, i6);
    if (this.el = _V.createElement(a7, e9), C.currentNode = this.el.content, 2 === i6) {
      const t7 = this.el.content, i7 = t7.firstChild;
      i7.remove(), t7.append(...i7.childNodes);
    }
    for (; null !== (h5 = C.nextNode()) && v4.length < c9; ) {
      if (1 === h5.nodeType) {
        if (h5.hasAttributes()) {
          const t7 = [];
          for (const i7 of h5.getAttributeNames())
            if (i7.endsWith(o3) || i7.startsWith(n3)) {
              const s8 = f4[u5++];
              if (t7.push(i7), void 0 !== s8) {
                const t8 = h5.getAttribute(s8.toLowerCase() + o3).split(n3), i8 = /([.?@])?(.*)/.exec(s8);
                v4.push({ type: 1, index: r6, name: i8[2], strings: t8, ctor: "." === i8[1] ? k : "?" === i8[1] ? I : "@" === i8[1] ? L : R });
              } else
                v4.push({ type: 6, index: r6 });
            }
          for (const i7 of t7)
            h5.removeAttribute(i7);
        }
        if (y.test(h5.tagName)) {
          const t7 = h5.textContent.split(n3), i7 = t7.length - 1;
          if (i7 > 0) {
            h5.textContent = s3 ? s3.emptyScript : "";
            for (let s8 = 0; s8 < i7; s8++)
              h5.append(t7[s8], d2()), C.nextNode(), v4.push({ type: 2, index: ++r6 });
            h5.append(t7[i7], d2());
          }
        }
      } else if (8 === h5.nodeType)
        if (h5.data === l2)
          v4.push({ type: 2, index: r6 });
        else {
          let t7 = -1;
          for (; -1 !== (t7 = h5.data.indexOf(n3, t7 + 1)); )
            v4.push({ type: 7, index: r6 }), t7 += n3.length - 1;
        }
      r6++;
    }
  }
  static createElement(t6, i6) {
    const s8 = r3.createElement("template");
    return s8.innerHTML = t6, s8;
  }
};
function N(t6, i6, s8 = t6, e9) {
  var o8, n9, l7, h5;
  if (i6 === T)
    return i6;
  let r6 = void 0 !== e9 ? null === (o8 = s8._$Co) || void 0 === o8 ? void 0 : o8[e9] : s8._$Cl;
  const d6 = u2(i6) ? void 0 : i6._$litDirective$;
  return (null == r6 ? void 0 : r6.constructor) !== d6 && (null === (n9 = null == r6 ? void 0 : r6._$AO) || void 0 === n9 || n9.call(r6, false), void 0 === d6 ? r6 = void 0 : (r6 = new d6(t6), r6._$AT(t6, s8, e9)), void 0 !== e9 ? (null !== (l7 = (h5 = s8)._$Co) && void 0 !== l7 ? l7 : h5._$Co = [])[e9] = r6 : s8._$Cl = r6), void 0 !== r6 && (i6 = N(t6, r6._$AS(t6, i6.values), r6, e9)), i6;
}
var S2 = class {
  constructor(t6, i6) {
    this._$AV = [], this._$AN = void 0, this._$AD = t6, this._$AM = i6;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t6) {
    var i6;
    const { el: { content: s8 }, parts: e9 } = this._$AD, o8 = (null !== (i6 = null == t6 ? void 0 : t6.creationScope) && void 0 !== i6 ? i6 : r3).importNode(s8, true);
    C.currentNode = o8;
    let n9 = C.nextNode(), l7 = 0, h5 = 0, d6 = e9[0];
    for (; void 0 !== d6; ) {
      if (l7 === d6.index) {
        let i7;
        2 === d6.type ? i7 = new M(n9, n9.nextSibling, this, t6) : 1 === d6.type ? i7 = new d6.ctor(n9, d6.name, d6.strings, this, t6) : 6 === d6.type && (i7 = new z(n9, this, t6)), this._$AV.push(i7), d6 = e9[++h5];
      }
      l7 !== (null == d6 ? void 0 : d6.index) && (n9 = C.nextNode(), l7++);
    }
    return C.currentNode = r3, o8;
  }
  v(t6) {
    let i6 = 0;
    for (const s8 of this._$AV)
      void 0 !== s8 && (void 0 !== s8.strings ? (s8._$AI(t6, s8, i6), i6 += s8.strings.length - 2) : s8._$AI(t6[i6])), i6++;
  }
};
var M = class _M {
  constructor(t6, i6, s8, e9) {
    var o8;
    this.type = 2, this._$AH = A, this._$AN = void 0, this._$AA = t6, this._$AB = i6, this._$AM = s8, this.options = e9, this._$Cp = null === (o8 = null == e9 ? void 0 : e9.isConnected) || void 0 === o8 || o8;
  }
  get _$AU() {
    var t6, i6;
    return null !== (i6 = null === (t6 = this._$AM) || void 0 === t6 ? void 0 : t6._$AU) && void 0 !== i6 ? i6 : this._$Cp;
  }
  get parentNode() {
    let t6 = this._$AA.parentNode;
    const i6 = this._$AM;
    return void 0 !== i6 && 11 === (null == t6 ? void 0 : t6.nodeType) && (t6 = i6.parentNode), t6;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t6, i6 = this) {
    t6 = N(this, t6, i6), u2(t6) ? t6 === A || null == t6 || "" === t6 ? (this._$AH !== A && this._$AR(), this._$AH = A) : t6 !== this._$AH && t6 !== T && this._(t6) : void 0 !== t6._$litType$ ? this.g(t6) : void 0 !== t6.nodeType ? this.$(t6) : v(t6) ? this.T(t6) : this._(t6);
  }
  k(t6) {
    return this._$AA.parentNode.insertBefore(t6, this._$AB);
  }
  $(t6) {
    this._$AH !== t6 && (this._$AR(), this._$AH = this.k(t6));
  }
  _(t6) {
    this._$AH !== A && u2(this._$AH) ? this._$AA.nextSibling.data = t6 : this.$(r3.createTextNode(t6)), this._$AH = t6;
  }
  g(t6) {
    var i6;
    const { values: s8, _$litType$: e9 } = t6, o8 = "number" == typeof e9 ? this._$AC(t6) : (void 0 === e9.el && (e9.el = V.createElement(e9.h, this.options)), e9);
    if ((null === (i6 = this._$AH) || void 0 === i6 ? void 0 : i6._$AD) === o8)
      this._$AH.v(s8);
    else {
      const t7 = new S2(o8, this), i7 = t7.u(this.options);
      t7.v(s8), this.$(i7), this._$AH = t7;
    }
  }
  _$AC(t6) {
    let i6 = E.get(t6.strings);
    return void 0 === i6 && E.set(t6.strings, i6 = new V(t6)), i6;
  }
  T(t6) {
    c2(this._$AH) || (this._$AH = [], this._$AR());
    const i6 = this._$AH;
    let s8, e9 = 0;
    for (const o8 of t6)
      e9 === i6.length ? i6.push(s8 = new _M(this.k(d2()), this.k(d2()), this, this.options)) : s8 = i6[e9], s8._$AI(o8), e9++;
    e9 < i6.length && (this._$AR(s8 && s8._$AB.nextSibling, e9), i6.length = e9);
  }
  _$AR(t6 = this._$AA.nextSibling, i6) {
    var s8;
    for (null === (s8 = this._$AP) || void 0 === s8 || s8.call(this, false, true, i6); t6 && t6 !== this._$AB; ) {
      const i7 = t6.nextSibling;
      t6.remove(), t6 = i7;
    }
  }
  setConnected(t6) {
    var i6;
    void 0 === this._$AM && (this._$Cp = t6, null === (i6 = this._$AP) || void 0 === i6 || i6.call(this, t6));
  }
};
var R = class {
  constructor(t6, i6, s8, e9, o8) {
    this.type = 1, this._$AH = A, this._$AN = void 0, this.element = t6, this.name = i6, this._$AM = e9, this.options = o8, s8.length > 2 || "" !== s8[0] || "" !== s8[1] ? (this._$AH = Array(s8.length - 1).fill(new String()), this.strings = s8) : this._$AH = A;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t6, i6 = this, s8, e9) {
    const o8 = this.strings;
    let n9 = false;
    if (void 0 === o8)
      t6 = N(this, t6, i6, 0), n9 = !u2(t6) || t6 !== this._$AH && t6 !== T, n9 && (this._$AH = t6);
    else {
      const e11 = t6;
      let l7, h5;
      for (t6 = o8[0], l7 = 0; l7 < o8.length - 1; l7++)
        h5 = N(this, e11[s8 + l7], i6, l7), h5 === T && (h5 = this._$AH[l7]), n9 || (n9 = !u2(h5) || h5 !== this._$AH[l7]), h5 === A ? t6 = A : t6 !== A && (t6 += (null != h5 ? h5 : "") + o8[l7 + 1]), this._$AH[l7] = h5;
    }
    n9 && !e9 && this.j(t6);
  }
  j(t6) {
    t6 === A ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t6 ? t6 : "");
  }
};
var k = class extends R {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t6) {
    this.element[this.name] = t6 === A ? void 0 : t6;
  }
};
var H = s3 ? s3.emptyScript : "";
var I = class extends R {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t6) {
    t6 && t6 !== A ? this.element.setAttribute(this.name, H) : this.element.removeAttribute(this.name);
  }
};
var L = class extends R {
  constructor(t6, i6, s8, e9, o8) {
    super(t6, i6, s8, e9, o8), this.type = 5;
  }
  _$AI(t6, i6 = this) {
    var s8;
    if ((t6 = null !== (s8 = N(this, t6, i6, 0)) && void 0 !== s8 ? s8 : A) === T)
      return;
    const e9 = this._$AH, o8 = t6 === A && e9 !== A || t6.capture !== e9.capture || t6.once !== e9.once || t6.passive !== e9.passive, n9 = t6 !== A && (e9 === A || o8);
    o8 && this.element.removeEventListener(this.name, this, e9), n9 && this.element.addEventListener(this.name, this, t6), this._$AH = t6;
  }
  handleEvent(t6) {
    var i6, s8;
    "function" == typeof this._$AH ? this._$AH.call(null !== (s8 = null === (i6 = this.options) || void 0 === i6 ? void 0 : i6.host) && void 0 !== s8 ? s8 : this.element, t6) : this._$AH.handleEvent(t6);
  }
};
var z = class {
  constructor(t6, i6, s8) {
    this.element = t6, this.type = 6, this._$AN = void 0, this._$AM = i6, this.options = s8;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t6) {
    N(this, t6);
  }
};
var j = i2.litHtmlPolyfillSupport;
null == j || j(V, M), (null !== (t2 = i2.litHtmlVersions) && void 0 !== t2 ? t2 : i2.litHtmlVersions = []).push("2.7.4");
var B = (t6, i6, s8) => {
  var e9, o8;
  const n9 = null !== (e9 = null == s8 ? void 0 : s8.renderBefore) && void 0 !== e9 ? e9 : i6;
  let l7 = n9._$litPart$;
  if (void 0 === l7) {
    const t7 = null !== (o8 = null == s8 ? void 0 : s8.renderBefore) && void 0 !== o8 ? o8 : null;
    n9._$litPart$ = l7 = new M(i6.insertBefore(d2(), t7), t7, void 0, null != s8 ? s8 : {});
  }
  return l7._$AI(t6), l7;
};

// node_modules/lit-element/lit-element.js
var l3;
var o4;
var s4 = class extends u {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t6, e9;
    const i6 = super.createRenderRoot();
    return null !== (t6 = (e9 = this.renderOptions).renderBefore) && void 0 !== t6 || (e9.renderBefore = i6.firstChild), i6;
  }
  update(t6) {
    const i6 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t6), this._$Do = B(i6, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t6;
    super.connectedCallback(), null === (t6 = this._$Do) || void 0 === t6 || t6.setConnected(true);
  }
  disconnectedCallback() {
    var t6;
    super.disconnectedCallback(), null === (t6 = this._$Do) || void 0 === t6 || t6.setConnected(false);
  }
  render() {
    return T;
  }
};
s4.finalized = true, s4._$litElement$ = true, null === (l3 = globalThis.litElementHydrateSupport) || void 0 === l3 || l3.call(globalThis, { LitElement: s4 });
var n4 = globalThis.litElementPolyfillSupport;
null == n4 || n4({ LitElement: s4 });
(null !== (o4 = globalThis.litElementVersions) && void 0 !== o4 ? o4 : globalThis.litElementVersions = []).push("3.3.2");

// src/collapsible.ts
var dirToIcon = {
  right: "\u25BA",
  left: "\u25C0\uFE0E",
  bottom: "\u25B2",
  top: "\u25B2"
};
var horizontalCollapseStyles = i`
  .horizontal .content {
    max-width: 100vw;
    transition: max-width var(--transition), transform var(--transition),
      padding-inline var(--transition);
  }

  .horizontal .content > * {
    min-width: 0;
  }

  .horizontal .toggle {
    padding-inline: var(--size-xs);
  }

  .horizontal.closed .toggle > .icon {
    transform: scaleX(-1);
  }

  .horizontal.closed .content {
    max-width: 0;
    transform: scaleX(0);
    padding-inline: 0;
  }
`;
var toLeftCollapseStyles = i`
  .left .content {
    transform-origin: left;
  }

  .left .toggle {
    top: var(--size-xs);
    right: var(--space-small);
    width: var(--toggle-size);
    height: auto;
  }
`;
var toRightCollapseStyles = i`
  .right .content {
    transform-origin: left;
  }

  .right .toggle {
    order: -1;
    top: var(--size-xs);
    right: 0;
    width: var(--toggle-size);
    height: auto;
  }
`;
var verticalCollapseStyles = i`
  .vertical {
    flex-direction: column;
  }

  .vertical > .content {
    max-height: 100vh;
    transition: max-height var(--transition), transform var(--transition),
      padding-block var(--transition);
  }

  .vertical > .toggle {
    min-height: var(--size-l);
  }

  .vertical .toggle > .icon {
    position: absolute;
    right: var(--space-x-small);
  }

  .vertical.closed .toggle > .icon {
    transform: rotate(180deg);
  }

  .vertical.content > ::slotted(*) {
    min-height: 0;
  }

  .vertical.closed .content {
    transform: scaleY(0);
    max-height: 0;
    padding-block: 0;
  }
`;
var toBottomCollapseStyles = i`
  .bottom .toggle {
    order: -1;
    right: var(--space-medium);
    bottom: 0;
  }
`;
var toTopCollapseStyles = i`
  .top .toggle {
    right: var(--size-xs);
  }
`;
var Collapsible = class extends s4 {
  constructor() {
    super();
    this.start_state = "open";
    this.opened = null;
    this.dir = "top";
    this.label = null;
  }
  static {
    this.properties = {
      label: {},
      opened: { type: "boolean" },
      start_state: {},
      dir: {}
    };
  }
  static {
    // Styles are scoped to this element: they won't conflict with styles
    // on the main page or in other components. Styling API can be exposed
    // via CSS custom properties.
    this.styles = [
      i`
      :host {
        --transition: 0.4s var(--ease-3);
        --toggle-size: 20px;
        --accent-color: var(--stone-3);

        display: block;
        font-family: var(--font-family, sans-serif);
        position: relative;
        outline: 1px solid var(--accent-color, pink);
        margin: var(--size-s);
        border-radius: var(--radius-s);
      }

      .container {
        display: flex;
      }

      .content {
        overflow: auto;
        transition: transform var(--transition);
        padding: var(--size-fluid-1);
      }

      .toggle {
        background-color: var(--accent-color);
        font-size: var(--font-size-m);
        display: grid;
        place-content: center;
        cursor: pointer;
      }

      .toggle > .icon {
        transition: transform var(--transition);
        user-select: none;
        color: var(--color-action);
      }
    `,
      horizontalCollapseStyles,
      toRightCollapseStyles,
      toLeftCollapseStyles,
      verticalCollapseStyles,
      toBottomCollapseStyles,
      toTopCollapseStyles
    ];
  }
  render() {
    return x`
      <div
        class="container ${this.dir} ${this.dir === "bottom" || this.dir === "top" ? "vertical" : "horizontal"} ${this.isOpen ? "open" : "closed"}"
      >
        <div class="content">
          <slot></slot>
        </div>
        <div
          class="toggle"
          @click=${this.toggleOpen}
          title=${this.isOpen ? "Close collapsible" : "Open collapsible"}
        >
          ${this.label ? x`<span>${this.label}</span>` : ""}
          <span class="icon"> ${dirToIcon[this.dir]} </span>
        </div>
      </div>
    `;
  }
  get isOpen() {
    if (this.opened === null) {
      return this.start_state === "open";
    }
    return this.opened;
  }
  toggleOpen() {
    if (this.opened === null) {
      this.opened = this.start_state !== "open";
      return;
    }
    this.opened = !this.opened;
    window.dispatchEvent(new Event("resize"));
  }
};
customElements.define("shiny-collapsible", Collapsible);

// src/color-picker.tsx
init_react();

// node_modules/react-color/es/components/alpha/Alpha.js
init_react();
var import_reactcss9 = __toESM(require_lib());

// node_modules/react-color/es/components/common/Alpha.js
init_react();
var import_reactcss2 = __toESM(require_lib());

// node_modules/react-color/es/helpers/alpha.js
var calculateChange = function calculateChange2(e9, hsl3, direction, initialA, container) {
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x6 = typeof e9.pageX === "number" ? e9.pageX : e9.touches[0].pageX;
  var y5 = typeof e9.pageY === "number" ? e9.pageY : e9.touches[0].pageY;
  var left2 = x6 - (container.getBoundingClientRect().left + window.pageXOffset);
  var top2 = y5 - (container.getBoundingClientRect().top + window.pageYOffset);
  if (direction === "vertical") {
    var a7 = void 0;
    if (top2 < 0) {
      a7 = 0;
    } else if (top2 > containerHeight) {
      a7 = 1;
    } else {
      a7 = Math.round(top2 * 100 / containerHeight) / 100;
    }
    if (hsl3.a !== a7) {
      return {
        h: hsl3.h,
        s: hsl3.s,
        l: hsl3.l,
        a: a7,
        source: "rgb"
      };
    }
  } else {
    var _a = void 0;
    if (left2 < 0) {
      _a = 0;
    } else if (left2 > containerWidth) {
      _a = 1;
    } else {
      _a = Math.round(left2 * 100 / containerWidth) / 100;
    }
    if (initialA !== _a) {
      return {
        h: hsl3.h,
        s: hsl3.s,
        l: hsl3.l,
        a: _a,
        source: "rgb"
      };
    }
  }
  return null;
};

// node_modules/react-color/es/components/common/Checkboard.js
init_react();
var import_reactcss = __toESM(require_lib());

// node_modules/react-color/es/helpers/checkboard.js
var checkboardCache = {};
var render = function render2(c12, c23, size, serverCanvas) {
  if (typeof document === "undefined" && !serverCanvas) {
    return null;
  }
  var canvas = serverCanvas ? new serverCanvas() : document.createElement("canvas");
  canvas.width = size * 2;
  canvas.height = size * 2;
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return null;
  }
  ctx.fillStyle = c12;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = c23;
  ctx.fillRect(0, 0, size, size);
  ctx.translate(size, size);
  ctx.fillRect(0, 0, size, size);
  return canvas.toDataURL();
};
var get = function get2(c12, c23, size, serverCanvas) {
  var key = c12 + "-" + c23 + "-" + size + (serverCanvas ? "-server" : "");
  if (checkboardCache[key]) {
    return checkboardCache[key];
  }
  var checkboard = render(c12, c23, size, serverCanvas);
  checkboardCache[key] = checkboard;
  return checkboard;
};

// node_modules/react-color/es/components/common/Checkboard.js
var _extends = Object.assign || function(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var Checkboard = function Checkboard2(_ref) {
  var white2 = _ref.white, grey = _ref.grey, size = _ref.size, renderers = _ref.renderers, borderRadius = _ref.borderRadius, boxShadow = _ref.boxShadow, children2 = _ref.children;
  var styles2 = (0, import_reactcss.default)({
    "default": {
      grid: {
        borderRadius,
        boxShadow,
        absolute: "0px 0px 0px 0px",
        background: "url(" + get(white2, grey, size, renderers.canvas) + ") center left"
      }
    }
  });
  return an(children2) ? Cn.cloneElement(children2, _extends({}, children2.props, { style: _extends({}, children2.props.style, styles2.grid) })) : Cn.createElement("div", { style: styles2.grid });
};
Checkboard.defaultProps = {
  size: 8,
  white: "transparent",
  grey: "rgba(0,0,0,.08)",
  renderers: {}
};
var Checkboard_default = Checkboard;

// node_modules/react-color/es/components/common/Alpha.js
var _extends2 = Object.assign || function(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass = function() {
  function defineProperties(target, props) {
    for (var i6 = 0; i6 < props.length; i6++) {
      var descriptor = props[i6];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Alpha = function(_ref) {
  _inherits(Alpha2, _ref);
  function Alpha2() {
    var _ref2;
    var _temp, _this, _ret;
    _classCallCheck(this, Alpha2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = Alpha2.__proto__ || Object.getPrototypeOf(Alpha2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e9) {
      var change = calculateChange(e9, _this.props.hsl, _this.props.direction, _this.props.a, _this.container);
      change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e9);
    }, _this.handleMouseDown = function(e9) {
      _this.handleChange(e9);
      window.addEventListener("mousemove", _this.handleChange);
      window.addEventListener("mouseup", _this.handleMouseUp);
    }, _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    }, _this.unbindEventListeners = function() {
      window.removeEventListener("mousemove", _this.handleChange);
      window.removeEventListener("mouseup", _this.handleMouseUp);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }
  _createClass(Alpha2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var rgb2 = this.props.rgb;
      var styles2 = (0, import_reactcss2.default)({
        "default": {
          alpha: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius
          },
          checkboard: {
            absolute: "0px 0px 0px 0px",
            overflow: "hidden",
            borderRadius: this.props.radius
          },
          gradient: {
            absolute: "0px 0px 0px 0px",
            background: "linear-gradient(to right, rgba(" + rgb2.r + "," + rgb2.g + "," + rgb2.b + ", 0) 0%,\n           rgba(" + rgb2.r + "," + rgb2.g + "," + rgb2.b + ", 1) 100%)",
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          container: {
            position: "relative",
            height: "100%",
            margin: "0 3px"
          },
          pointer: {
            position: "absolute",
            left: rgb2.a * 100 + "%"
          },
          slider: {
            width: "4px",
            borderRadius: "1px",
            height: "8px",
            boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
            background: "#fff",
            marginTop: "1px",
            transform: "translateX(-2px)"
          }
        },
        "vertical": {
          gradient: {
            background: "linear-gradient(to bottom, rgba(" + rgb2.r + "," + rgb2.g + "," + rgb2.b + ", 0) 0%,\n           rgba(" + rgb2.r + "," + rgb2.g + "," + rgb2.b + ", 1) 100%)"
          },
          pointer: {
            left: 0,
            top: rgb2.a * 100 + "%"
          }
        },
        "overwrite": _extends2({}, this.props.style)
      }, {
        vertical: this.props.direction === "vertical",
        overwrite: true
      });
      return Cn.createElement(
        "div",
        { style: styles2.alpha },
        Cn.createElement(
          "div",
          { style: styles2.checkboard },
          Cn.createElement(Checkboard_default, { renderers: this.props.renderers })
        ),
        Cn.createElement("div", { style: styles2.gradient }),
        Cn.createElement(
          "div",
          {
            style: styles2.container,
            ref: function ref(container) {
              return _this2.container = container;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          Cn.createElement(
            "div",
            { style: styles2.pointer },
            this.props.pointer ? Cn.createElement(this.props.pointer, this.props) : Cn.createElement("div", { style: styles2.slider })
          )
        )
      );
    }
  }]);
  return Alpha2;
}(w4 || b2);
var Alpha_default = Alpha;

// node_modules/react-color/es/components/common/EditableInput.js
init_react();
var import_reactcss3 = __toESM(require_lib());
var _createClass2 = function() {
  function defineProperties(target, props) {
    for (var i6 = 0; i6 < props.length; i6++) {
      var descriptor = props[i6];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn2(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var DEFAULT_ARROW_OFFSET = 1;
var UP_KEY_CODE = 38;
var DOWN_KEY_CODE = 40;
var VALID_KEY_CODES = [UP_KEY_CODE, DOWN_KEY_CODE];
var isValidKeyCode = function isValidKeyCode2(keyCode) {
  return VALID_KEY_CODES.indexOf(keyCode) > -1;
};
var getNumberValue = function getNumberValue2(value) {
  return Number(String(value).replace(/%/g, ""));
};
var idCounter = 1;
var EditableInput = function(_ref) {
  _inherits2(EditableInput2, _ref);
  function EditableInput2(props) {
    _classCallCheck2(this, EditableInput2);
    var _this = _possibleConstructorReturn2(this, (EditableInput2.__proto__ || Object.getPrototypeOf(EditableInput2)).call(this));
    _this.handleBlur = function() {
      if (_this.state.blurValue) {
        _this.setState({ value: _this.state.blurValue, blurValue: null });
      }
    };
    _this.handleChange = function(e9) {
      _this.setUpdatedValue(e9.target.value, e9);
    };
    _this.handleKeyDown = function(e9) {
      var value = getNumberValue(e9.target.value);
      if (!isNaN(value) && isValidKeyCode(e9.keyCode)) {
        var offset2 = _this.getArrowOffset();
        var updatedValue = e9.keyCode === UP_KEY_CODE ? value + offset2 : value - offset2;
        _this.setUpdatedValue(updatedValue, e9);
      }
    };
    _this.handleDrag = function(e9) {
      if (_this.props.dragLabel) {
        var newValue = Math.round(_this.props.value + e9.movementX);
        if (newValue >= 0 && newValue <= _this.props.dragMax) {
          _this.props.onChange && _this.props.onChange(_this.getValueObjectWithLabel(newValue), e9);
        }
      }
    };
    _this.handleMouseDown = function(e9) {
      if (_this.props.dragLabel) {
        e9.preventDefault();
        _this.handleDrag(e9);
        window.addEventListener("mousemove", _this.handleDrag);
        window.addEventListener("mouseup", _this.handleMouseUp);
      }
    };
    _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    };
    _this.unbindEventListeners = function() {
      window.removeEventListener("mousemove", _this.handleDrag);
      window.removeEventListener("mouseup", _this.handleMouseUp);
    };
    _this.state = {
      value: String(props.value).toUpperCase(),
      blurValue: String(props.value).toUpperCase()
    };
    _this.inputId = "rc-editable-input-" + idCounter++;
    return _this;
  }
  _createClass2(EditableInput2, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.props.value !== this.state.value && (prevProps.value !== this.props.value || prevState.value !== this.state.value)) {
        if (this.input === document.activeElement) {
          this.setState({ blurValue: String(this.props.value).toUpperCase() });
        } else {
          this.setState({ value: String(this.props.value).toUpperCase(), blurValue: !this.state.blurValue && String(this.props.value).toUpperCase() });
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "getValueObjectWithLabel",
    value: function getValueObjectWithLabel(value) {
      return _defineProperty({}, this.props.label, value);
    }
  }, {
    key: "getArrowOffset",
    value: function getArrowOffset() {
      return this.props.arrowOffset || DEFAULT_ARROW_OFFSET;
    }
  }, {
    key: "setUpdatedValue",
    value: function setUpdatedValue(value, e9) {
      var onChangeValue = this.props.label ? this.getValueObjectWithLabel(value) : value;
      this.props.onChange && this.props.onChange(onChangeValue, e9);
      this.setState({ value });
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var styles2 = (0, import_reactcss3.default)({
        "default": {
          wrap: {
            position: "relative"
          }
        },
        "user-override": {
          wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
          input: this.props.style && this.props.style.input ? this.props.style.input : {},
          label: this.props.style && this.props.style.label ? this.props.style.label : {}
        },
        "dragLabel-true": {
          label: {
            cursor: "ew-resize"
          }
        }
      }, {
        "user-override": true
      }, this.props);
      return Cn.createElement(
        "div",
        { style: styles2.wrap },
        Cn.createElement("input", {
          id: this.inputId,
          style: styles2.input,
          ref: function ref(input) {
            return _this2.input = input;
          },
          value: this.state.value,
          onKeyDown: this.handleKeyDown,
          onChange: this.handleChange,
          onBlur: this.handleBlur,
          placeholder: this.props.placeholder,
          spellCheck: "false"
        }),
        this.props.label && !this.props.hideLabel ? Cn.createElement(
          "label",
          {
            htmlFor: this.inputId,
            style: styles2.label,
            onMouseDown: this.handleMouseDown
          },
          this.props.label
        ) : null
      );
    }
  }]);
  return EditableInput2;
}(w4 || b2);
var EditableInput_default = EditableInput;

// node_modules/react-color/es/components/common/Hue.js
init_react();
var import_reactcss4 = __toESM(require_lib());

// node_modules/react-color/es/helpers/hue.js
var calculateChange3 = function calculateChange4(e9, direction, hsl3, container) {
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x6 = typeof e9.pageX === "number" ? e9.pageX : e9.touches[0].pageX;
  var y5 = typeof e9.pageY === "number" ? e9.pageY : e9.touches[0].pageY;
  var left2 = x6 - (container.getBoundingClientRect().left + window.pageXOffset);
  var top2 = y5 - (container.getBoundingClientRect().top + window.pageYOffset);
  if (direction === "vertical") {
    var h5 = void 0;
    if (top2 < 0) {
      h5 = 359;
    } else if (top2 > containerHeight) {
      h5 = 0;
    } else {
      var percent = -(top2 * 100 / containerHeight) + 100;
      h5 = 360 * percent / 100;
    }
    if (hsl3.h !== h5) {
      return {
        h: h5,
        s: hsl3.s,
        l: hsl3.l,
        a: hsl3.a,
        source: "hsl"
      };
    }
  } else {
    var _h = void 0;
    if (left2 < 0) {
      _h = 0;
    } else if (left2 > containerWidth) {
      _h = 359;
    } else {
      var _percent = left2 * 100 / containerWidth;
      _h = 360 * _percent / 100;
    }
    if (hsl3.h !== _h) {
      return {
        h: _h,
        s: hsl3.s,
        l: hsl3.l,
        a: hsl3.a,
        source: "hsl"
      };
    }
  }
  return null;
};

// node_modules/react-color/es/components/common/Hue.js
var _createClass3 = function() {
  function defineProperties(target, props) {
    for (var i6 = 0; i6 < props.length; i6++) {
      var descriptor = props[i6];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn3(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Hue = function(_ref) {
  _inherits3(Hue2, _ref);
  function Hue2() {
    var _ref2;
    var _temp, _this, _ret;
    _classCallCheck3(this, Hue2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = _possibleConstructorReturn3(this, (_ref2 = Hue2.__proto__ || Object.getPrototypeOf(Hue2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e9) {
      var change = calculateChange3(e9, _this.props.direction, _this.props.hsl, _this.container);
      change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e9);
    }, _this.handleMouseDown = function(e9) {
      _this.handleChange(e9);
      window.addEventListener("mousemove", _this.handleChange);
      window.addEventListener("mouseup", _this.handleMouseUp);
    }, _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    }, _temp), _possibleConstructorReturn3(_this, _ret);
  }
  _createClass3(Hue2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "unbindEventListeners",
    value: function unbindEventListeners() {
      window.removeEventListener("mousemove", this.handleChange);
      window.removeEventListener("mouseup", this.handleMouseUp);
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var _props$direction = this.props.direction, direction = _props$direction === void 0 ? "horizontal" : _props$direction;
      var styles2 = (0, import_reactcss4.default)({
        "default": {
          hue: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius,
            boxShadow: this.props.shadow
          },
          container: {
            padding: "0 2px",
            position: "relative",
            height: "100%",
            borderRadius: this.props.radius
          },
          pointer: {
            position: "absolute",
            left: this.props.hsl.h * 100 / 360 + "%"
          },
          slider: {
            marginTop: "1px",
            width: "4px",
            borderRadius: "1px",
            height: "8px",
            boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
            background: "#fff",
            transform: "translateX(-2px)"
          }
        },
        "vertical": {
          pointer: {
            left: "0px",
            top: -(this.props.hsl.h * 100 / 360) + 100 + "%"
          }
        }
      }, { vertical: direction === "vertical" });
      return Cn.createElement(
        "div",
        { style: styles2.hue },
        Cn.createElement(
          "div",
          {
            className: "hue-" + direction,
            style: styles2.container,
            ref: function ref(container) {
              return _this2.container = container;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          Cn.createElement(
            "style",
            null,
            "\n            .hue-horizontal {\n              background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0\n                33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to right, #f00 0%, #ff0\n                17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n\n            .hue-vertical {\n              background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,\n                #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%,\n                #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n          "
          ),
          Cn.createElement(
            "div",
            { style: styles2.pointer },
            this.props.pointer ? Cn.createElement(this.props.pointer, this.props) : Cn.createElement("div", { style: styles2.slider })
          )
        )
      );
    }
  }]);
  return Hue2;
}(w4 || b2);
var Hue_default = Hue;

// node_modules/react-color/es/components/common/Raised.js
init_react();
var import_prop_types = __toESM(require_prop_types());
var import_reactcss5 = __toESM(require_lib());

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array2, key) {
  var length3 = array2.length;
  while (length3--) {
    if (eq_default(array2[length3][0], key)) {
      return length3;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index2 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length3) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e9) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type3 = typeof value;
  return value != null && (type3 == "object" || type3 == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e9) {
    }
    try {
      return func + "";
    } catch (e9) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty3.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty4.call(data, key);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index2 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length3) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type3 = typeof value;
  return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map4, key) {
  var data = map4.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index2 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length3) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs2 = data.__data__;
    if (!Map_default || pairs2.length < LARGE_ARRAY_SIZE - 1) {
      pairs2.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs2);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e9) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq_default(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignMergeValue_default = assignMergeValue;

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length3 = props.length;
    while (length3--) {
      var key = props[fromRight ? length3 : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_cloneBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length3 = buffer.length, result = allocUnsafe ? allocUnsafe(length3) : new buffer.constructor(length3);
  buffer.copy(result);
  return result;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
  return result;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_copyArray.js
function copyArray(source, array2) {
  var index2 = -1, length3 = source.length;
  array2 || (array2 = Array(length3));
  while (++index2 < length3) {
    array2[index2] = source[index2];
  }
  return array2;
}
var copyArray_default = copyArray;

// node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/_isPrototype.js
var objectProto6 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto6;
  return value === proto;
}
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
var propertyIsEnumerable = objectProto7.propertyIsEnumerable;
var isArguments = baseIsArguments_default(function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty5.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var Buffer3 = moduleExports2 ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/isPlainObject.js
var objectTag = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto8 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty6.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag2 = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag2] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var freeProcess = moduleExports3 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule3 && freeModule3.require && freeModule3.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e9) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_safeGet.js
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var safeGet_default = safeGet;

// node_modules/lodash-es/_assignValue.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty7.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length3 = props.length;
  while (++index2 < length3) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n9, iteratee) {
  var index2 = -1, result = Array(n9);
  while (++index2 < n9) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length3) {
  var type3 = typeof value;
  length3 = length3 == null ? MAX_SAFE_INTEGER2 : length3;
  return !!length3 && (type3 == "number" || type3 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length3);
}
var isIndex_default = isIndex;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length3 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty8.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length3)))) {
      result.push(key);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty9.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// node_modules/lodash-es/toPlainObject.js
function toPlainObject(value) {
  return copyObject_default(value, keysIn_default(value));
}
var toPlainObject_default = toPlainObject;

// node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
  var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack2.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack2.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
    stack2["delete"](srcValue);
  }
  assignMergeValue_default(object, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// node_modules/lodash-es/_baseMerge.js
function baseMerge(object, source, srcIndex, customizer, stack2) {
  if (object === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack2 || (stack2 = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack2);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack2) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default = identity;

// node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply;

// node_modules/lodash-es/_overRest.js
var nativeMax = Math.max;
function overRest(func, start2, transform2) {
  start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length3 = nativeMax(args.length - start2, 0), array2 = Array(length3);
    while (++index2 < length3) {
      array2[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform2(array2);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default = constant;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func, string2) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string2),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start2) {
  return setToString_default(overRest_default(func, start2, identity_default), func + "");
}
var baseRest_default = baseRest;

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index2, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type3 = typeof index2;
  if (type3 == "number" ? isArrayLike_default(object) && isIndex_default(index2, object.length) : type3 == "string" && index2 in object) {
    return eq_default(object[index2], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources) {
    var index2 = -1, length3 = sources.length, customizer = length3 > 1 ? sources[length3 - 1] : void 0, guard = length3 > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length3--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length3 < 3 ? void 0 : customizer;
      length3 = 1;
    }
    object = Object(object);
    while (++index2 < length3) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var createAssigner_default = createAssigner;

// node_modules/lodash-es/merge.js
var merge = createAssigner_default(function(object, source, srcIndex) {
  baseMerge_default(object, source, srcIndex);
});
var merge_default = merge;

// node_modules/react-color/es/components/common/Raised.js
var Raised = function Raised2(_ref) {
  var zDepth = _ref.zDepth, radius2 = _ref.radius, background = _ref.background, children2 = _ref.children, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles;
  var styles2 = (0, import_reactcss5.default)(merge_default({
    "default": {
      wrap: {
        position: "relative",
        display: "inline-block"
      },
      content: {
        position: "relative"
      },
      bg: {
        absolute: "0px 0px 0px 0px",
        boxShadow: "0 " + zDepth + "px " + zDepth * 4 + "px rgba(0,0,0,.24)",
        borderRadius: radius2,
        background
      }
    },
    "zDepth-0": {
      bg: {
        boxShadow: "none"
      }
    },
    "zDepth-1": {
      bg: {
        boxShadow: "0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)"
      }
    },
    "zDepth-2": {
      bg: {
        boxShadow: "0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)"
      }
    },
    "zDepth-3": {
      bg: {
        boxShadow: "0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)"
      }
    },
    "zDepth-4": {
      bg: {
        boxShadow: "0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)"
      }
    },
    "zDepth-5": {
      bg: {
        boxShadow: "0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)"
      }
    },
    "square": {
      bg: {
        borderRadius: "0"
      }
    },
    "circle": {
      bg: {
        borderRadius: "50%"
      }
    }
  }, passedStyles), { "zDepth-1": zDepth === 1 });
  return Cn.createElement(
    "div",
    { style: styles2.wrap },
    Cn.createElement("div", { style: styles2.bg }),
    Cn.createElement(
      "div",
      { style: styles2.content },
      children2
    )
  );
};
Raised.propTypes = {
  background: import_prop_types.default.string,
  zDepth: import_prop_types.default.oneOf([0, 1, 2, 3, 4, 5]),
  radius: import_prop_types.default.number,
  styles: import_prop_types.default.object
};
Raised.defaultProps = {
  background: "#fff",
  zDepth: 1,
  radius: 2,
  styles: {}
};
var Raised_default = Raised;

// node_modules/react-color/es/components/common/Saturation.js
init_react();
var import_reactcss6 = __toESM(require_lib());

// node_modules/lodash-es/now.js
var now = function() {
  return root_default.Date.now();
};
var now_default = now;

// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string2) {
  var index2 = string2.length;
  while (index2-- && reWhitespace.test(string2.charAt(index2))) {
  }
  return index2;
}
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string2) {
  return string2 ? string2.slice(0, trimmedEndIndex_default(string2) + 1).replace(reTrimStart, "") : string2;
}
var baseTrim_default = baseTrim;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

// node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax2 = Math.max;
var nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax2(toNumber_default(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time2) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time2;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time2) {
    lastInvokeTime = time2;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time2) : result;
  }
  function remainingWait(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time2 = now_default();
    if (shouldInvoke(time2)) {
      return trailingEdge(time2);
    }
    timerId = setTimeout(timerExpired, remainingWait(time2));
  }
  function trailingEdge(time2) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time2);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now_default());
  }
  function debounced() {
    var time2 = now_default(), isInvoking = shouldInvoke(time2);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time2;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_default = debounce;

// node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT2 = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  if (isObject_default(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce_default(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_default = throttle;

// node_modules/react-color/es/helpers/saturation.js
var calculateChange5 = function calculateChange6(e9, hsl3, container) {
  var _container$getBoundin = container.getBoundingClientRect(), containerWidth = _container$getBoundin.width, containerHeight = _container$getBoundin.height;
  var x6 = typeof e9.pageX === "number" ? e9.pageX : e9.touches[0].pageX;
  var y5 = typeof e9.pageY === "number" ? e9.pageY : e9.touches[0].pageY;
  var left2 = x6 - (container.getBoundingClientRect().left + window.pageXOffset);
  var top2 = y5 - (container.getBoundingClientRect().top + window.pageYOffset);
  if (left2 < 0) {
    left2 = 0;
  } else if (left2 > containerWidth) {
    left2 = containerWidth;
  }
  if (top2 < 0) {
    top2 = 0;
  } else if (top2 > containerHeight) {
    top2 = containerHeight;
  }
  var saturation = left2 / containerWidth;
  var bright = 1 - top2 / containerHeight;
  return {
    h: hsl3.h,
    s: saturation,
    v: bright,
    a: hsl3.a,
    source: "hsv"
  };
};

// node_modules/react-color/es/components/common/Saturation.js
var _createClass4 = function() {
  function defineProperties(target, props) {
    for (var i6 = 0; i6 < props.length; i6++) {
      var descriptor = props[i6];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn4(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Saturation = function(_ref) {
  _inherits4(Saturation2, _ref);
  function Saturation2(props) {
    _classCallCheck4(this, Saturation2);
    var _this = _possibleConstructorReturn4(this, (Saturation2.__proto__ || Object.getPrototypeOf(Saturation2)).call(this, props));
    _this.handleChange = function(e9) {
      typeof _this.props.onChange === "function" && _this.throttle(_this.props.onChange, calculateChange5(e9, _this.props.hsl, _this.container), e9);
    };
    _this.handleMouseDown = function(e9) {
      _this.handleChange(e9);
      var renderWindow = _this.getContainerRenderWindow();
      renderWindow.addEventListener("mousemove", _this.handleChange);
      renderWindow.addEventListener("mouseup", _this.handleMouseUp);
    };
    _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    };
    _this.throttle = throttle_default(function(fn2, data, e9) {
      fn2(data, e9);
    }, 50);
    return _this;
  }
  _createClass4(Saturation2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.throttle.cancel();
      this.unbindEventListeners();
    }
  }, {
    key: "getContainerRenderWindow",
    value: function getContainerRenderWindow() {
      var container = this.container;
      var renderWindow = window;
      while (!renderWindow.document.contains(container) && renderWindow.parent !== renderWindow) {
        renderWindow = renderWindow.parent;
      }
      return renderWindow;
    }
  }, {
    key: "unbindEventListeners",
    value: function unbindEventListeners() {
      var renderWindow = this.getContainerRenderWindow();
      renderWindow.removeEventListener("mousemove", this.handleChange);
      renderWindow.removeEventListener("mouseup", this.handleMouseUp);
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var _ref2 = this.props.style || {}, color3 = _ref2.color, white2 = _ref2.white, black = _ref2.black, pointer2 = _ref2.pointer, circle = _ref2.circle;
      var styles2 = (0, import_reactcss6.default)({
        "default": {
          color: {
            absolute: "0px 0px 0px 0px",
            background: "hsl(" + this.props.hsl.h + ",100%, 50%)",
            borderRadius: this.props.radius
          },
          white: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius
          },
          black: {
            absolute: "0px 0px 0px 0px",
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          pointer: {
            position: "absolute",
            top: -(this.props.hsv.v * 100) + 100 + "%",
            left: this.props.hsv.s * 100 + "%",
            cursor: "default"
          },
          circle: {
            width: "4px",
            height: "4px",
            boxShadow: "0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),\n            0 0 1px 2px rgba(0,0,0,.4)",
            borderRadius: "50%",
            cursor: "hand",
            transform: "translate(-2px, -2px)"
          }
        },
        "custom": {
          color: color3,
          white: white2,
          black,
          pointer: pointer2,
          circle
        }
      }, { "custom": !!this.props.style });
      return Cn.createElement(
        "div",
        {
          style: styles2.color,
          ref: function ref(container) {
            return _this2.container = container;
          },
          onMouseDown: this.handleMouseDown,
          onTouchMove: this.handleChange,
          onTouchStart: this.handleChange
        },
        Cn.createElement(
          "style",
          null,
          "\n          .saturation-white {\n            background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0));\n            background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n          }\n          .saturation-black {\n            background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0));\n            background: linear-gradient(to top, #000, rgba(0,0,0,0));\n          }\n        "
        ),
        Cn.createElement(
          "div",
          { style: styles2.white, className: "saturation-white" },
          Cn.createElement("div", { style: styles2.black, className: "saturation-black" }),
          Cn.createElement(
            "div",
            { style: styles2.pointer },
            this.props.pointer ? Cn.createElement(this.props.pointer, this.props) : Cn.createElement("div", { style: styles2.circle })
          )
        )
      );
    }
  }]);
  return Saturation2;
}(w4 || b2);
var Saturation_default = Saturation;

// node_modules/react-color/es/components/common/ColorWrap.js
init_react();

// node_modules/lodash-es/_arrayEach.js
function arrayEach(array2, iteratee) {
  var index2 = -1, length3 = array2 == null ? 0 : array2.length;
  while (++index2 < length3) {
    if (iteratee(array2[index2], index2, array2) === false) {
      break;
    }
  }
  return array2;
}
var arrayEach_default = arrayEach;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto12 = Object.prototype;
var hasOwnProperty10 = objectProto12.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty10.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee) {
  return object && baseFor_default(object, iteratee, keys_default);
}
var baseForOwn_default = baseForOwn;

// node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length3 = collection.length, index2 = fromRight ? length3 : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length3) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// node_modules/lodash-es/_castFunction.js
function castFunction(value) {
  return typeof value == "function" ? value : identity_default;
}
var castFunction_default = castFunction;

// node_modules/lodash-es/forEach.js
function forEach(collection, iteratee) {
  var func = isArray_default(collection) ? arrayEach_default : baseEach_default;
  return func(collection, castFunction_default(iteratee));
}
var forEach_default = forEach;

// node_modules/tinycolor2/esm/tinycolor.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color3, opts) {
  color3 = color3 ? color3 : "";
  opts = opts || {};
  if (color3 instanceof tinycolor) {
    return color3;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color3, opts);
  }
  var rgb2 = inputToRGB(color3);
  this._originalInput = color3, this._r = rgb2.r, this._g = rgb2.g, this._b = rgb2.b, this._a = rgb2.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb2.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1)
    this._r = Math.round(this._r);
  if (this._g < 1)
    this._g = Math.round(this._g);
  if (this._b < 1)
    this._b = Math.round(this._b);
  this._ok = rgb2.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb2 = this.toRgb();
    return (rgb2.r * 299 + rgb2.g * 587 + rgb2.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb2 = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R3, G3, B6;
    RsRGB = rgb2.r / 255;
    GsRGB = rgb2.g / 255;
    BsRGB = rgb2.b / 255;
    if (RsRGB <= 0.03928)
      R3 = RsRGB / 12.92;
    else
      R3 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928)
      G3 = GsRGB / 12.92;
    else
      G3 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928)
      B6 = BsRGB / 12.92;
    else
      B6 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R3 + 0.7152 * G3 + 0.0722 * B6;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h5 = Math.round(hsv.h * 360), s8 = Math.round(hsv.s * 100), v4 = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h5 + ", " + s8 + "%, " + v4 + "%)" : "hsva(" + h5 + ", " + s8 + "%, " + v4 + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl3 = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl3.h * 360,
      s: hsl3.s,
      l: hsl3.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl3 = rgbToHsl(this._r, this._g, this._b);
    var h5 = Math.round(hsl3.h * 360), s8 = Math.round(hsl3.s * 100), l7 = Math.round(hsl3.l * 100);
    return this._a == 1 ? "hsl(" + h5 + ", " + s8 + "%, " + l7 + "%)" : "hsla(" + h5 + ", " + s8 + "%, " + l7 + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s8 = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s8._r, s8._g, s8._b, s8._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format3) {
    var formatSet = !!format3;
    format3 = format3 || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format3 === "hex" || format3 === "hex6" || format3 === "hex3" || format3 === "hex4" || format3 === "hex8" || format3 === "name");
    if (needsAlphaFormat) {
      if (format3 === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format3 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format3 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format3 === "hex" || format3 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format3 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format3 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format3 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format3 === "name") {
      formattedString = this.toName();
    }
    if (format3 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format3 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn2, args) {
    var color3 = fn2.apply(null, [this].concat([].slice.call(args)));
    this._r = color3._r;
    this._g = color3._g;
    this._b = color3._b;
    this.setAlpha(color3._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn2, args) {
    return fn2.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color3, opts) {
  if (_typeof(color3) == "object") {
    var newColor = {};
    for (var i6 in color3) {
      if (color3.hasOwnProperty(i6)) {
        if (i6 === "a") {
          newColor[i6] = color3[i6];
        } else {
          newColor[i6] = convertToPercentage(color3[i6]);
        }
      }
    }
    color3 = newColor;
  }
  return tinycolor(color3, opts);
};
function inputToRGB(color3) {
  var rgb2 = {
    r: 0,
    g: 0,
    b: 0
  };
  var a7 = 1;
  var s8 = null;
  var v4 = null;
  var l7 = null;
  var ok = false;
  var format3 = false;
  if (typeof color3 == "string") {
    color3 = stringInputToObject(color3);
  }
  if (_typeof(color3) == "object") {
    if (isValidCSSUnit(color3.r) && isValidCSSUnit(color3.g) && isValidCSSUnit(color3.b)) {
      rgb2 = rgbToRgb(color3.r, color3.g, color3.b);
      ok = true;
      format3 = String(color3.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color3.h) && isValidCSSUnit(color3.s) && isValidCSSUnit(color3.v)) {
      s8 = convertToPercentage(color3.s);
      v4 = convertToPercentage(color3.v);
      rgb2 = hsvToRgb(color3.h, s8, v4);
      ok = true;
      format3 = "hsv";
    } else if (isValidCSSUnit(color3.h) && isValidCSSUnit(color3.s) && isValidCSSUnit(color3.l)) {
      s8 = convertToPercentage(color3.s);
      l7 = convertToPercentage(color3.l);
      rgb2 = hslToRgb(color3.h, s8, l7);
      ok = true;
      format3 = "hsl";
    }
    if (color3.hasOwnProperty("a")) {
      a7 = color3.a;
    }
  }
  a7 = boundAlpha(a7);
  return {
    ok,
    format: color3.format || format3,
    r: Math.min(255, Math.max(rgb2.r, 0)),
    g: Math.min(255, Math.max(rgb2.g, 0)),
    b: Math.min(255, Math.max(rgb2.b, 0)),
    a: a7
  };
}
function rgbToRgb(r6, g6, b5) {
  return {
    r: bound01(r6, 255) * 255,
    g: bound01(g6, 255) * 255,
    b: bound01(b5, 255) * 255
  };
}
function rgbToHsl(r6, g6, b5) {
  r6 = bound01(r6, 255);
  g6 = bound01(g6, 255);
  b5 = bound01(b5, 255);
  var max4 = Math.max(r6, g6, b5), min4 = Math.min(r6, g6, b5);
  var h5, s8, l7 = (max4 + min4) / 2;
  if (max4 == min4) {
    h5 = s8 = 0;
  } else {
    var d6 = max4 - min4;
    s8 = l7 > 0.5 ? d6 / (2 - max4 - min4) : d6 / (max4 + min4);
    switch (max4) {
      case r6:
        h5 = (g6 - b5) / d6 + (g6 < b5 ? 6 : 0);
        break;
      case g6:
        h5 = (b5 - r6) / d6 + 2;
        break;
      case b5:
        h5 = (r6 - g6) / d6 + 4;
        break;
    }
    h5 /= 6;
  }
  return {
    h: h5,
    s: s8,
    l: l7
  };
}
function hslToRgb(h5, s8, l7) {
  var r6, g6, b5;
  h5 = bound01(h5, 360);
  s8 = bound01(s8, 100);
  l7 = bound01(l7, 100);
  function hue2rgb(p6, q5, t6) {
    if (t6 < 0)
      t6 += 1;
    if (t6 > 1)
      t6 -= 1;
    if (t6 < 1 / 6)
      return p6 + (q5 - p6) * 6 * t6;
    if (t6 < 1 / 2)
      return q5;
    if (t6 < 2 / 3)
      return p6 + (q5 - p6) * (2 / 3 - t6) * 6;
    return p6;
  }
  if (s8 === 0) {
    r6 = g6 = b5 = l7;
  } else {
    var q4 = l7 < 0.5 ? l7 * (1 + s8) : l7 + s8 - l7 * s8;
    var p5 = 2 * l7 - q4;
    r6 = hue2rgb(p5, q4, h5 + 1 / 3);
    g6 = hue2rgb(p5, q4, h5);
    b5 = hue2rgb(p5, q4, h5 - 1 / 3);
  }
  return {
    r: r6 * 255,
    g: g6 * 255,
    b: b5 * 255
  };
}
function rgbToHsv(r6, g6, b5) {
  r6 = bound01(r6, 255);
  g6 = bound01(g6, 255);
  b5 = bound01(b5, 255);
  var max4 = Math.max(r6, g6, b5), min4 = Math.min(r6, g6, b5);
  var h5, s8, v4 = max4;
  var d6 = max4 - min4;
  s8 = max4 === 0 ? 0 : d6 / max4;
  if (max4 == min4) {
    h5 = 0;
  } else {
    switch (max4) {
      case r6:
        h5 = (g6 - b5) / d6 + (g6 < b5 ? 6 : 0);
        break;
      case g6:
        h5 = (b5 - r6) / d6 + 2;
        break;
      case b5:
        h5 = (r6 - g6) / d6 + 4;
        break;
    }
    h5 /= 6;
  }
  return {
    h: h5,
    s: s8,
    v: v4
  };
}
function hsvToRgb(h5, s8, v4) {
  h5 = bound01(h5, 360) * 6;
  s8 = bound01(s8, 100);
  v4 = bound01(v4, 100);
  var i6 = Math.floor(h5), f4 = h5 - i6, p5 = v4 * (1 - s8), q4 = v4 * (1 - f4 * s8), t6 = v4 * (1 - (1 - f4) * s8), mod = i6 % 6, r6 = [v4, q4, p5, p5, t6, v4][mod], g6 = [t6, v4, v4, q4, p5, p5][mod], b5 = [p5, p5, t6, v4, v4, q4][mod];
  return {
    r: r6 * 255,
    g: g6 * 255,
    b: b5 * 255
  };
}
function rgbToHex(r6, g6, b5, allow3Char) {
  var hex2 = [pad2(Math.round(r6).toString(16)), pad2(Math.round(g6).toString(16)), pad2(Math.round(b5).toString(16))];
  if (allow3Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1)) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function rgbaToHex(r6, g6, b5, a7, allow4Char) {
  var hex2 = [pad2(Math.round(r6).toString(16)), pad2(Math.round(g6).toString(16)), pad2(Math.round(b5).toString(16)), pad2(convertDecimalToHex(a7))];
  if (allow4Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1) && hex2[3].charAt(0) == hex2[3].charAt(1)) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
  }
  return hex2.join("");
}
function rgbaToArgbHex(r6, g6, b5, a7) {
  var hex2 = [pad2(convertDecimalToHex(a7)), pad2(Math.round(r6).toString(16)), pad2(Math.round(g6).toString(16)), pad2(Math.round(b5).toString(16))];
  return hex2.join("");
}
tinycolor.equals = function(color1, color22) {
  if (!color1 || !color22)
    return false;
  return tinycolor(color1).toRgbString() == tinycolor(color22).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl3 = tinycolor(color3).toHsl();
  hsl3.s -= amount / 100;
  hsl3.s = clamp01(hsl3.s);
  return tinycolor(hsl3);
}
function _saturate(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl3 = tinycolor(color3).toHsl();
  hsl3.s += amount / 100;
  hsl3.s = clamp01(hsl3.s);
  return tinycolor(hsl3);
}
function _greyscale(color3) {
  return tinycolor(color3).desaturate(100);
}
function _lighten(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl3 = tinycolor(color3).toHsl();
  hsl3.l += amount / 100;
  hsl3.l = clamp01(hsl3.l);
  return tinycolor(hsl3);
}
function _brighten(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb2 = tinycolor(color3).toRgb();
  rgb2.r = Math.max(0, Math.min(255, rgb2.r - Math.round(255 * -(amount / 100))));
  rgb2.g = Math.max(0, Math.min(255, rgb2.g - Math.round(255 * -(amount / 100))));
  rgb2.b = Math.max(0, Math.min(255, rgb2.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb2);
}
function _darken(color3, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl3 = tinycolor(color3).toHsl();
  hsl3.l -= amount / 100;
  hsl3.l = clamp01(hsl3.l);
  return tinycolor(hsl3);
}
function _spin(color3, amount) {
  var hsl3 = tinycolor(color3).toHsl();
  var hue2 = (hsl3.h + amount) % 360;
  hsl3.h = hue2 < 0 ? 360 + hue2 : hue2;
  return tinycolor(hsl3);
}
function _complement(color3) {
  var hsl3 = tinycolor(color3).toHsl();
  hsl3.h = (hsl3.h + 180) % 360;
  return tinycolor(hsl3);
}
function polyad(color3, number6) {
  if (isNaN(number6) || number6 <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl3 = tinycolor(color3).toHsl();
  var result = [tinycolor(color3)];
  var step = 360 / number6;
  for (var i6 = 1; i6 < number6; i6++) {
    result.push(tinycolor({
      h: (hsl3.h + i6 * step) % 360,
      s: hsl3.s,
      l: hsl3.l
    }));
  }
  return result;
}
function _splitcomplement(color3) {
  var hsl3 = tinycolor(color3).toHsl();
  var h5 = hsl3.h;
  return [tinycolor(color3), tinycolor({
    h: (h5 + 72) % 360,
    s: hsl3.s,
    l: hsl3.l
  }), tinycolor({
    h: (h5 + 216) % 360,
    s: hsl3.s,
    l: hsl3.l
  })];
}
function _analogous(color3, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl3 = tinycolor(color3).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color3)];
  for (hsl3.h = (hsl3.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl3.h = (hsl3.h + part) % 360;
    ret.push(tinycolor(hsl3));
  }
  return ret;
}
function _monochromatic(color3, results) {
  results = results || 6;
  var hsv = tinycolor(color3).toHsv();
  var h5 = hsv.h, s8 = hsv.s, v4 = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h5,
      s: s8,
      v: v4
    }));
    v4 = (v4 + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color22, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color22).toRgb();
  var p5 = amount / 100;
  var rgba2 = {
    r: (rgb2.r - rgb1.r) * p5 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p5 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p5 + rgb1.b,
    a: (rgb2.a - rgb1.a) * p5 + rgb1.a
  };
  return tinycolor(rgba2);
};
tinycolor.readability = function(color1, color22) {
  var c12 = tinycolor(color1);
  var c23 = tinycolor(color22);
  return (Math.max(c12.getLuminance(), c23.getLuminance()) + 0.05) / (Math.min(c12.getLuminance(), c23.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color22, wcag2) {
  var readability = tinycolor.readability(color1, color22);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i6 = 0; i6 < colorList.length; i6++) {
    readability = tinycolor.readability(baseColor, colorList[i6]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i6]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o8) {
  var flipped = {};
  for (var i6 in o8) {
    if (o8.hasOwnProperty(i6)) {
      flipped[o8[i6]] = i6;
    }
  }
  return flipped;
}
function boundAlpha(a7) {
  a7 = parseFloat(a7);
  if (isNaN(a7) || a7 < 0 || a7 > 1) {
    a7 = 1;
  }
  return a7;
}
function bound01(n9, max4) {
  if (isOnePointZero(n9))
    n9 = "100%";
  var processPercent = isPercentage(n9);
  n9 = Math.min(max4, Math.max(0, parseFloat(n9)));
  if (processPercent) {
    n9 = parseInt(n9 * max4, 10) / 100;
  }
  if (Math.abs(n9 - max4) < 1e-6) {
    return 1;
  }
  return n9 % max4 / parseFloat(max4);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n9) {
  return typeof n9 == "string" && n9.indexOf(".") != -1 && parseFloat(n9) === 1;
}
function isPercentage(n9) {
  return typeof n9 === "string" && n9.indexOf("%") != -1;
}
function pad2(c9) {
  return c9.length == 1 ? "0" + c9 : "" + c9;
}
function convertToPercentage(n9) {
  if (n9 <= 1) {
    n9 = n9 * 100 + "%";
  }
  return n9;
}
function convertDecimalToHex(d6) {
  return Math.round(parseFloat(d6) * 255).toString(16);
}
function convertHexToDecimal(h5) {
  return parseIntFromHex(h5) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color3) {
  return !!matchers.CSS_UNIT.exec(color3);
}
function stringInputToObject(color3) {
  color3 = color3.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named3 = false;
  if (names[color3]) {
    color3 = names[color3];
    named3 = true;
  } else if (color3 == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color3)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color3)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color3)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color3)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named3 ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color3)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named3 ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color3)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named3 ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color3)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named3 ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level,
    size
  };
}

// node_modules/react-color/es/helpers/color.js
var simpleCheckForValidColor = function simpleCheckForValidColor2(data) {
  var keysToCheck = ["r", "g", "b", "a", "h", "s", "l", "v"];
  var checked = 0;
  var passed = 0;
  forEach_default(keysToCheck, function(letter) {
    if (data[letter]) {
      checked += 1;
      if (!isNaN(data[letter])) {
        passed += 1;
      }
      if (letter === "s" || letter === "l") {
        var percentPatt = /^\d+%$/;
        if (percentPatt.test(data[letter])) {
          passed += 1;
        }
      }
    }
  });
  return checked === passed ? data : false;
};
var toState = function toState2(data, oldHue) {
  var color3 = data.hex ? tinycolor(data.hex) : tinycolor(data);
  var hsl3 = color3.toHsl();
  var hsv = color3.toHsv();
  var rgb2 = color3.toRgb();
  var hex2 = color3.toHex();
  if (hsl3.s === 0) {
    hsl3.h = oldHue || 0;
    hsv.h = oldHue || 0;
  }
  var transparent = hex2 === "000000" && rgb2.a === 0;
  return {
    hsl: hsl3,
    hex: transparent ? "transparent" : "#" + hex2,
    rgb: rgb2,
    hsv,
    oldHue: data.h || oldHue || hsl3.h,
    source: data.source
  };
};
var isValidHex = function isValidHex2(hex2) {
  if (hex2 === "transparent") {
    return true;
  }
  var lh = String(hex2).charAt(0) === "#" ? 1 : 0;
  return hex2.length !== 4 + lh && hex2.length < 7 + lh && tinycolor(hex2).isValid();
};
var getContrastingColor = function getContrastingColor2(data) {
  if (!data) {
    return "#fff";
  }
  var col = toState(data);
  if (col.hex === "transparent") {
    return "rgba(0,0,0,0.4)";
  }
  var yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1e3;
  return yiq >= 128 ? "#000" : "#fff";
};
var isvalidColorString = function isvalidColorString2(string2, type3) {
  var stringWithoutDegree = string2.replace("\xB0", "");
  return tinycolor(type3 + " (" + stringWithoutDegree + ")")._ok;
};

// node_modules/react-color/es/components/common/ColorWrap.js
var _extends3 = Object.assign || function(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass5 = function() {
  function defineProperties(target, props) {
    for (var i6 = 0; i6 < props.length; i6++) {
      var descriptor = props[i6];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn5(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ColorWrap = function ColorWrap2(Picker) {
  var ColorPicker2 = function(_ref) {
    _inherits5(ColorPicker3, _ref);
    function ColorPicker3(props) {
      _classCallCheck5(this, ColorPicker3);
      var _this = _possibleConstructorReturn5(this, (ColorPicker3.__proto__ || Object.getPrototypeOf(ColorPicker3)).call(this));
      _this.handleChange = function(data, event) {
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors2 = toState(data, data.h || _this.state.oldHue);
          _this.setState(colors2);
          _this.props.onChangeComplete && _this.debounce(_this.props.onChangeComplete, colors2, event);
          _this.props.onChange && _this.props.onChange(colors2, event);
        }
      };
      _this.handleSwatchHover = function(data, event) {
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors2 = toState(data, data.h || _this.state.oldHue);
          _this.props.onSwatchHover && _this.props.onSwatchHover(colors2, event);
        }
      };
      _this.state = _extends3({}, toState(props.color, 0));
      _this.debounce = debounce_default(function(fn2, data, event) {
        fn2(data, event);
      }, 100);
      return _this;
    }
    _createClass5(ColorPicker3, [{
      key: "render",
      value: function render3() {
        var optionalEvents = {};
        if (this.props.onSwatchHover) {
          optionalEvents.onSwatchHover = this.handleSwatchHover;
        }
        return Cn.createElement(Picker, _extends3({}, this.props, this.state, {
          onChange: this.handleChange
        }, optionalEvents));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(nextProps, state) {
        return _extends3({}, toState(nextProps.color, state.oldHue));
      }
    }]);
    return ColorPicker3;
  }(w4 || b2);
  ColorPicker2.propTypes = _extends3({}, Picker.propTypes);
  ColorPicker2.defaultProps = _extends3({}, Picker.defaultProps, {
    color: {
      h: 250,
      s: 0.5,
      l: 0.2,
      a: 1
    }
  });
  return ColorPicker2;
};
var ColorWrap_default = ColorWrap;

// node_modules/react-color/es/components/common/Swatch.js
init_react();
var import_reactcss7 = __toESM(require_lib());

// node_modules/react-color/es/helpers/interaction.js
init_react();
var _extends4 = Object.assign || function(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass6 = function() {
  function defineProperties(target, props) {
    for (var i6 = 0; i6 < props.length; i6++) {
      var descriptor = props[i6];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn6(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var handleFocus = function handleFocus2(Component) {
  var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
  return function(_React$Component) {
    _inherits6(Focus, _React$Component);
    function Focus() {
      var _ref;
      var _temp, _this, _ret;
      _classCallCheck6(this, Focus);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _ret = (_temp = (_this = _possibleConstructorReturn6(this, (_ref = Focus.__proto__ || Object.getPrototypeOf(Focus)).call.apply(_ref, [this].concat(args))), _this), _this.state = { focus: false }, _this.handleFocus = function() {
        return _this.setState({ focus: true });
      }, _this.handleBlur = function() {
        return _this.setState({ focus: false });
      }, _temp), _possibleConstructorReturn6(_this, _ret);
    }
    _createClass6(Focus, [{
      key: "render",
      value: function render3() {
        return Cn.createElement(
          Span,
          { onFocus: this.handleFocus, onBlur: this.handleBlur },
          Cn.createElement(Component, _extends4({}, this.props, this.state))
        );
      }
    }]);
    return Focus;
  }(Cn.Component);
};

// node_modules/react-color/es/components/common/Swatch.js
var _extends5 = Object.assign || function(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var ENTER = 13;
var Swatch = function Swatch2(_ref) {
  var color3 = _ref.color, style = _ref.style, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onHover = _ref.onHover, _ref$title = _ref.title, title = _ref$title === void 0 ? color3 : _ref$title, children2 = _ref.children, focus = _ref.focus, _ref$focusStyle = _ref.focusStyle, focusStyle = _ref$focusStyle === void 0 ? {} : _ref$focusStyle;
  var transparent = color3 === "transparent";
  var styles2 = (0, import_reactcss7.default)({
    default: {
      swatch: _extends5({
        background: color3,
        height: "100%",
        width: "100%",
        cursor: "pointer",
        position: "relative",
        outline: "none"
      }, style, focus ? focusStyle : {})
    }
  });
  var handleClick = function handleClick2(e9) {
    return onClick(color3, e9);
  };
  var handleKeyDown = function handleKeyDown2(e9) {
    return e9.keyCode === ENTER && onClick(color3, e9);
  };
  var handleHover3 = function handleHover4(e9) {
    return onHover(color3, e9);
  };
  var optionalEvents = {};
  if (onHover) {
    optionalEvents.onMouseOver = handleHover3;
  }
  return Cn.createElement(
    "div",
    _extends5({
      style: styles2.swatch,
      onClick: handleClick,
      title,
      tabIndex: 0,
      onKeyDown: handleKeyDown
    }, optionalEvents),
    children2,
    transparent && Cn.createElement(Checkboard_default, {
      borderRadius: styles2.swatch.borderRadius,
      boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
    })
  );
};
var Swatch_default = handleFocus(Swatch);

// node_modules/react-color/es/components/alpha/AlphaPointer.js
init_react();
var import_reactcss8 = __toESM(require_lib());
var AlphaPointer = function AlphaPointer2(_ref) {
  var direction = _ref.direction;
  var styles2 = (0, import_reactcss8.default)({
    "default": {
      picker: {
        width: "18px",
        height: "18px",
        borderRadius: "50%",
        transform: "translate(-9px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    },
    "vertical": {
      picker: {
        transform: "translate(-3px, -9px)"
      }
    }
  }, { vertical: direction === "vertical" });
  return Cn.createElement("div", { style: styles2.picker });
};
var AlphaPointer_default = AlphaPointer;

// node_modules/react-color/es/components/alpha/Alpha.js
var _extends6 = Object.assign || function(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var AlphaPicker = function AlphaPicker2(_ref) {
  var rgb2 = _ref.rgb, hsl3 = _ref.hsl, width = _ref.width, height = _ref.height, onChange = _ref.onChange, direction = _ref.direction, style = _ref.style, renderers = _ref.renderers, pointer2 = _ref.pointer, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = (0, import_reactcss9.default)({
    "default": {
      picker: {
        position: "relative",
        width,
        height
      },
      alpha: {
        radius: "2px",
        style
      }
    }
  });
  return Cn.createElement(
    "div",
    { style: styles2.picker, className: "alpha-picker " + className },
    Cn.createElement(Alpha_default, _extends6({}, styles2.alpha, {
      rgb: rgb2,
      hsl: hsl3,
      pointer: pointer2,
      renderers,
      onChange,
      direction
    }))
  );
};
AlphaPicker.defaultProps = {
  width: "316px",
  height: "16px",
  direction: "horizontal",
  pointer: AlphaPointer_default
};
var Alpha_default2 = ColorWrap_default(AlphaPicker);

// node_modules/react-color/es/components/block/Block.js
init_react();
var import_prop_types2 = __toESM(require_prop_types());
var import_reactcss11 = __toESM(require_lib());

// node_modules/react-color/es/components/block/BlockSwatches.js
init_react();
var import_reactcss10 = __toESM(require_lib());

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array2, iteratee) {
  var index2 = -1, length3 = array2 == null ? 0 : array2.length, result = Array(length3);
  while (++index2 < length3) {
    result[index2] = iteratee(array2[index2], index2, array2);
  }
  return result;
}
var arrayMap_default = arrayMap;

// node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;

// node_modules/lodash-es/_SetCache.js
function SetCache(values2) {
  var index2 = -1, length3 = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache_default();
  while (++index2 < length3) {
    this.add(values2[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/lodash-es/_arraySome.js
function arraySome(array2, predicate) {
  var index2 = -1, length3 = array2 == null ? 0 : array2.length;
  while (++index2 < length3) {
    if (predicate(array2[index2], index2, array2)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// node_modules/lodash-es/_cacheHas.js
function cacheHas(cache, key) {
  return cache.has(key);
}
var cacheHas_default = cacheHas;

// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack2.get(array2);
  var othStacked = stack2.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array2;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack2.set(array2, other);
  stack2.set(other, array2);
  while (++index2 < arrLength) {
    var arrValue = array2[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack2) : customizer(arrValue, othValue, index2, array2, other, stack2);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
      result = false;
      break;
    }
  }
  stack2["delete"](array2);
  stack2["delete"](other);
  return result;
}
var equalArrays_default = equalArrays;

// node_modules/lodash-es/_mapToArray.js
function mapToArray(map4) {
  var index2 = -1, result = Array(map4.size);
  map4.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var mapToArray_default = mapToArray;

// node_modules/lodash-es/_setToArray.js
function setToArray(set4) {
  var index2 = -1, result = Array(set4.size);
  set4.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var setToArray_default = setToArray;

// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var mapTag2 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag2 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag2 = "[object DataView]";
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
  switch (tag) {
    case dataViewTag2:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag2:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag2:
    case dateTag2:
    case numberTag2:
      return eq_default(+object, +other);
    case errorTag2:
      return object.name == other.name && object.message == other.message;
    case regexpTag2:
    case stringTag2:
      return object == other + "";
    case mapTag2:
      var convert = mapToArray_default;
    case setTag2:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack2.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack2.set(object, other);
      var result = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
      stack2["delete"](object);
      return result;
    case symbolTag2:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array2, values2) {
  var index2 = -1, length3 = values2.length, offset2 = array2.length;
  while (++index2 < length3) {
    array2[offset2 + index2] = values2[index2];
  }
  return array2;
}
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array2, predicate) {
  var index2 = -1, length3 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index2 < length3) {
    var value = array2[index2];
    if (predicate(value, index2, array2)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto13 = Object.prototype;
var propertyIsEnumerable2 = objectProto13.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol2) {
    return propertyIsEnumerable2.call(object, symbol2);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto14 = Object.prototype;
var hasOwnProperty11 = objectProto14.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty11.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack2.get(object);
  var othStacked = stack2.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack2.set(object, other);
  stack2.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack2["delete"](object);
  stack2["delete"](other);
  return result;
}
var equalObjects_default = equalObjects;

// node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default, "DataView");
var DataView_default = DataView2;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// node_modules/lodash-es/_getTag.js
var mapTag3 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag3 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag3 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag3 || Map_default && getTag(new Map_default()) != mapTag3 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag3 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag3;
        case mapCtorString:
          return mapTag3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag3;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag_default = getTag;

// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var objectTag4 = "[object Object]";
var objectProto15 = Object.prototype;
var hasOwnProperty12 = objectProto15.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag2 : getTag_default(object), othTag = othIsArr ? arrayTag2 : getTag_default(other);
  objTag = objTag == argsTag3 ? objectTag4 : objTag;
  othTag = othTag == argsTag3 ? objectTag4 : othTag;
  var objIsObj = objTag == objectTag4, othIsObj = othTag == objectTag4, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack2 || (stack2 = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack2);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty12.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty12.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack2 || (stack2 = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack2 || (stack2 = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack2);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack2) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack2);
}
var baseIsEqual_default = baseIsEqual;

// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index2 = matchData.length, length3 = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length3;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length3) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack2 = new Stack_default();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack2);
      }
      if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack2) : result)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable;

// node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result = keys_default(object), length3 = result.length;
  while (length3--) {
    var key = result[length3], value = object[key];
    result[length3] = [key, value, isStrictComparable_default(value)];
  }
  return result;
}
var getMatchData_default = getMatchData;

// node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
var baseMatches_default = baseMatches;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type3 = typeof value;
  if (type3 == "number" || type3 == "symbol" || type3 == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT3 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName, function(match, number6, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number6 || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto2 ? symbolProto2.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;

// node_modules/lodash-es/toString.js
function toString2(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString2;

// node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
var INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path2) {
  path2 = castPath_default(path2, object);
  var index2 = 0, length3 = path2.length;
  while (object != null && index2 < length3) {
    object = object[toKey_default(path2[index2++])];
  }
  return index2 && index2 == length3 ? object : void 0;
}
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get3(object, path2, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path2);
  return result === void 0 ? defaultValue : result;
}
var get_default = get3;

// node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var baseHasIn_default = baseHasIn;

// node_modules/lodash-es/_hasPath.js
function hasPath(object, path2, hasFunc) {
  path2 = castPath_default(path2, object);
  var index2 = -1, length3 = path2.length, result = false;
  while (++index2 < length3) {
    var key = toKey_default(path2[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length3) {
    return result;
  }
  length3 = object == null ? 0 : object.length;
  return !!length3 && isLength_default(length3) && isIndex_default(key, length3) && (isArray_default(object) || isArguments_default(object));
}
var hasPath_default = hasPath;

// node_modules/lodash-es/hasIn.js
function hasIn(object, path2) {
  return object != null && hasPath_default(object, path2, baseHasIn_default);
}
var hasIn_default = hasIn;

// node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path2, srcValue) {
  if (isKey_default(path2) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path2), srcValue);
  }
  return function(object) {
    var objValue = get_default(object, path2);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path2) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var baseProperty_default = baseProperty;

// node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path2) {
  return function(object) {
    return baseGet_default(object, path2);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// node_modules/lodash-es/property.js
function property(path2) {
  return isKey_default(path2) ? baseProperty_default(toKey_default(path2)) : basePropertyDeep_default(path2);
}
var property_default = property;

// node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
var baseIteratee_default = baseIteratee;

// node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
var baseMap_default = baseMap;

// node_modules/lodash-es/map.js
function map(collection, iteratee) {
  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
  return func(collection, baseIteratee_default(iteratee, 3));
}
var map_default = map;

// node_modules/react-color/es/components/block/BlockSwatches.js
var BlockSwatches = function BlockSwatches2(_ref) {
  var colors2 = _ref.colors, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
  var styles2 = (0, import_reactcss10.default)({
    "default": {
      swatches: {
        marginRight: "-10px"
      },
      swatch: {
        width: "22px",
        height: "22px",
        float: "left",
        marginRight: "10px",
        marginBottom: "10px",
        borderRadius: "4px"
      },
      clear: {
        clear: "both"
      }
    }
  });
  return Cn.createElement(
    "div",
    { style: styles2.swatches },
    map_default(colors2, function(c9) {
      return Cn.createElement(Swatch_default, {
        key: c9,
        color: c9,
        style: styles2.swatch,
        onClick,
        onHover: onSwatchHover,
        focusStyle: {
          boxShadow: "0 0 4px " + c9
        }
      });
    }),
    Cn.createElement("div", { style: styles2.clear })
  );
};
var BlockSwatches_default = BlockSwatches;

// node_modules/react-color/es/components/block/Block.js
var Block = function Block2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex2 = _ref.hex, colors2 = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var transparent = hex2 === "transparent";
  var handleChange = function handleChange2(hexCode, e9) {
    isValidHex(hexCode) && onChange({
      hex: hexCode,
      source: "hex"
    }, e9);
  };
  var styles2 = (0, import_reactcss11.default)(merge_default({
    "default": {
      card: {
        width,
        background: "#fff",
        boxShadow: "0 1px rgba(0,0,0,.1)",
        borderRadius: "6px",
        position: "relative"
      },
      head: {
        height: "110px",
        background: hex2,
        borderRadius: "6px 6px 0 0",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        position: "relative"
      },
      body: {
        padding: "10px"
      },
      label: {
        fontSize: "18px",
        color: getContrastingColor(hex2),
        position: "relative"
      },
      triangle: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 10px 10px 10px",
        borderColor: "transparent transparent " + hex2 + " transparent",
        position: "absolute",
        top: "-10px",
        left: "50%",
        marginLeft: "-10px"
      },
      input: {
        width: "100%",
        fontSize: "12px",
        color: "#666",
        border: "0px",
        outline: "none",
        height: "22px",
        boxShadow: "inset 0 0 0 1px #ddd",
        borderRadius: "4px",
        padding: "0 7px",
        boxSizing: "border-box"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      }
    }
  }, passedStyles), { "hide-triangle": triangle === "hide" });
  return Cn.createElement(
    "div",
    { style: styles2.card, className: "block-picker " + className },
    Cn.createElement("div", { style: styles2.triangle }),
    Cn.createElement(
      "div",
      { style: styles2.head },
      transparent && Cn.createElement(Checkboard_default, { borderRadius: "6px 6px 0 0" }),
      Cn.createElement(
        "div",
        { style: styles2.label },
        hex2
      )
    ),
    Cn.createElement(
      "div",
      { style: styles2.body },
      Cn.createElement(BlockSwatches_default, { colors: colors2, onClick: handleChange, onSwatchHover }),
      Cn.createElement(EditableInput_default, {
        style: { input: styles2.input },
        value: hex2,
        onChange: handleChange
      })
    )
  );
};
Block.propTypes = {
  width: import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.number]),
  colors: import_prop_types2.default.arrayOf(import_prop_types2.default.string),
  triangle: import_prop_types2.default.oneOf(["top", "hide"]),
  styles: import_prop_types2.default.object
};
Block.defaultProps = {
  width: 170,
  colors: ["#D9E3F0", "#F47373", "#697689", "#37D67A", "#2CCCE4", "#555555", "#dce775", "#ff8a65", "#ba68c8"],
  triangle: "top",
  styles: {}
};
var Block_default = ColorWrap_default(Block);

// node_modules/react-color/es/components/circle/Circle.js
init_react();
var import_prop_types3 = __toESM(require_prop_types());
var import_reactcss13 = __toESM(require_lib());

// node_modules/material-colors/dist/colors.es2015.js
var red = { "50": "#ffebee", "100": "#ffcdd2", "200": "#ef9a9a", "300": "#e57373", "400": "#ef5350", "500": "#f44336", "600": "#e53935", "700": "#d32f2f", "800": "#c62828", "900": "#b71c1c", "a100": "#ff8a80", "a200": "#ff5252", "a400": "#ff1744", "a700": "#d50000" };
var pink = { "50": "#fce4ec", "100": "#f8bbd0", "200": "#f48fb1", "300": "#f06292", "400": "#ec407a", "500": "#e91e63", "600": "#d81b60", "700": "#c2185b", "800": "#ad1457", "900": "#880e4f", "a100": "#ff80ab", "a200": "#ff4081", "a400": "#f50057", "a700": "#c51162" };
var purple = { "50": "#f3e5f5", "100": "#e1bee7", "200": "#ce93d8", "300": "#ba68c8", "400": "#ab47bc", "500": "#9c27b0", "600": "#8e24aa", "700": "#7b1fa2", "800": "#6a1b9a", "900": "#4a148c", "a100": "#ea80fc", "a200": "#e040fb", "a400": "#d500f9", "a700": "#aa00ff" };
var deepPurple = { "50": "#ede7f6", "100": "#d1c4e9", "200": "#b39ddb", "300": "#9575cd", "400": "#7e57c2", "500": "#673ab7", "600": "#5e35b1", "700": "#512da8", "800": "#4527a0", "900": "#311b92", "a100": "#b388ff", "a200": "#7c4dff", "a400": "#651fff", "a700": "#6200ea" };
var indigo = { "50": "#e8eaf6", "100": "#c5cae9", "200": "#9fa8da", "300": "#7986cb", "400": "#5c6bc0", "500": "#3f51b5", "600": "#3949ab", "700": "#303f9f", "800": "#283593", "900": "#1a237e", "a100": "#8c9eff", "a200": "#536dfe", "a400": "#3d5afe", "a700": "#304ffe" };
var blue = { "50": "#e3f2fd", "100": "#bbdefb", "200": "#90caf9", "300": "#64b5f6", "400": "#42a5f5", "500": "#2196f3", "600": "#1e88e5", "700": "#1976d2", "800": "#1565c0", "900": "#0d47a1", "a100": "#82b1ff", "a200": "#448aff", "a400": "#2979ff", "a700": "#2962ff" };
var lightBlue = { "50": "#e1f5fe", "100": "#b3e5fc", "200": "#81d4fa", "300": "#4fc3f7", "400": "#29b6f6", "500": "#03a9f4", "600": "#039be5", "700": "#0288d1", "800": "#0277bd", "900": "#01579b", "a100": "#80d8ff", "a200": "#40c4ff", "a400": "#00b0ff", "a700": "#0091ea" };
var cyan = { "50": "#e0f7fa", "100": "#b2ebf2", "200": "#80deea", "300": "#4dd0e1", "400": "#26c6da", "500": "#00bcd4", "600": "#00acc1", "700": "#0097a7", "800": "#00838f", "900": "#006064", "a100": "#84ffff", "a200": "#18ffff", "a400": "#00e5ff", "a700": "#00b8d4" };
var teal = { "50": "#e0f2f1", "100": "#b2dfdb", "200": "#80cbc4", "300": "#4db6ac", "400": "#26a69a", "500": "#009688", "600": "#00897b", "700": "#00796b", "800": "#00695c", "900": "#004d40", "a100": "#a7ffeb", "a200": "#64ffda", "a400": "#1de9b6", "a700": "#00bfa5" };
var green = { "50": "#e8f5e9", "100": "#c8e6c9", "200": "#a5d6a7", "300": "#81c784", "400": "#66bb6a", "500": "#4caf50", "600": "#43a047", "700": "#388e3c", "800": "#2e7d32", "900": "#1b5e20", "a100": "#b9f6ca", "a200": "#69f0ae", "a400": "#00e676", "a700": "#00c853" };
var lightGreen = { "50": "#f1f8e9", "100": "#dcedc8", "200": "#c5e1a5", "300": "#aed581", "400": "#9ccc65", "500": "#8bc34a", "600": "#7cb342", "700": "#689f38", "800": "#558b2f", "900": "#33691e", "a100": "#ccff90", "a200": "#b2ff59", "a400": "#76ff03", "a700": "#64dd17" };
var lime = { "50": "#f9fbe7", "100": "#f0f4c3", "200": "#e6ee9c", "300": "#dce775", "400": "#d4e157", "500": "#cddc39", "600": "#c0ca33", "700": "#afb42b", "800": "#9e9d24", "900": "#827717", "a100": "#f4ff81", "a200": "#eeff41", "a400": "#c6ff00", "a700": "#aeea00" };
var yellow = { "50": "#fffde7", "100": "#fff9c4", "200": "#fff59d", "300": "#fff176", "400": "#ffee58", "500": "#ffeb3b", "600": "#fdd835", "700": "#fbc02d", "800": "#f9a825", "900": "#f57f17", "a100": "#ffff8d", "a200": "#ffff00", "a400": "#ffea00", "a700": "#ffd600" };
var amber = { "50": "#fff8e1", "100": "#ffecb3", "200": "#ffe082", "300": "#ffd54f", "400": "#ffca28", "500": "#ffc107", "600": "#ffb300", "700": "#ffa000", "800": "#ff8f00", "900": "#ff6f00", "a100": "#ffe57f", "a200": "#ffd740", "a400": "#ffc400", "a700": "#ffab00" };
var orange = { "50": "#fff3e0", "100": "#ffe0b2", "200": "#ffcc80", "300": "#ffb74d", "400": "#ffa726", "500": "#ff9800", "600": "#fb8c00", "700": "#f57c00", "800": "#ef6c00", "900": "#e65100", "a100": "#ffd180", "a200": "#ffab40", "a400": "#ff9100", "a700": "#ff6d00" };
var deepOrange = { "50": "#fbe9e7", "100": "#ffccbc", "200": "#ffab91", "300": "#ff8a65", "400": "#ff7043", "500": "#ff5722", "600": "#f4511e", "700": "#e64a19", "800": "#d84315", "900": "#bf360c", "a100": "#ff9e80", "a200": "#ff6e40", "a400": "#ff3d00", "a700": "#dd2c00" };
var brown = { "50": "#efebe9", "100": "#d7ccc8", "200": "#bcaaa4", "300": "#a1887f", "400": "#8d6e63", "500": "#795548", "600": "#6d4c41", "700": "#5d4037", "800": "#4e342e", "900": "#3e2723" };
var blueGrey = { "50": "#eceff1", "100": "#cfd8dc", "200": "#b0bec5", "300": "#90a4ae", "400": "#78909c", "500": "#607d8b", "600": "#546e7a", "700": "#455a64", "800": "#37474f", "900": "#263238" };

// node_modules/react-color/es/components/circle/CircleSwatch.js
init_react();
var import_reactcss12 = __toESM(require_lib());
var CircleSwatch = function CircleSwatch2(_ref) {
  var color3 = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, hover = _ref.hover, active = _ref.active, circleSize = _ref.circleSize, circleSpacing = _ref.circleSpacing;
  var styles2 = (0, import_reactcss12.default)({
    "default": {
      swatch: {
        width: circleSize,
        height: circleSize,
        marginRight: circleSpacing,
        marginBottom: circleSpacing,
        transform: "scale(1)",
        transition: "100ms transform ease"
      },
      Swatch: {
        borderRadius: "50%",
        background: "transparent",
        boxShadow: "inset 0 0 0 " + (circleSize / 2 + 1) + "px " + color3,
        transition: "100ms box-shadow ease"
      }
    },
    "hover": {
      swatch: {
        transform: "scale(1.2)"
      }
    },
    "active": {
      Swatch: {
        boxShadow: "inset 0 0 0 3px " + color3
      }
    }
  }, { hover, active });
  return Cn.createElement(
    "div",
    { style: styles2.swatch },
    Cn.createElement(Swatch_default, {
      style: styles2.Swatch,
      color: color3,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: styles2.Swatch.boxShadow + ", 0 0 5px " + color3 }
    })
  );
};
CircleSwatch.defaultProps = {
  circleSize: 28,
  circleSpacing: 14
};
var CircleSwatch_default = (0, import_reactcss12.handleHover)(CircleSwatch);

// node_modules/react-color/es/components/circle/Circle.js
var Circle = function Circle2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors2 = _ref.colors, hex2 = _ref.hex, circleSize = _ref.circleSize, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, circleSpacing = _ref.circleSpacing, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = (0, import_reactcss13.default)(merge_default({
    "default": {
      card: {
        width,
        display: "flex",
        flexWrap: "wrap",
        marginRight: -circleSpacing,
        marginBottom: -circleSpacing
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(hexCode, e9) {
    return onChange({ hex: hexCode, source: "hex" }, e9);
  };
  return Cn.createElement(
    "div",
    { style: styles2.card, className: "circle-picker " + className },
    map_default(colors2, function(c9) {
      return Cn.createElement(CircleSwatch_default, {
        key: c9,
        color: c9,
        onClick: handleChange,
        onSwatchHover,
        active: hex2 === c9.toLowerCase(),
        circleSize,
        circleSpacing
      });
    })
  );
};
Circle.propTypes = {
  width: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.number]),
  circleSize: import_prop_types3.default.number,
  circleSpacing: import_prop_types3.default.number,
  styles: import_prop_types3.default.object
};
Circle.defaultProps = {
  width: 252,
  circleSize: 28,
  circleSpacing: 14,
  colors: [red["500"], pink["500"], purple["500"], deepPurple["500"], indigo["500"], blue["500"], lightBlue["500"], cyan["500"], teal["500"], green["500"], lightGreen["500"], lime["500"], yellow["500"], amber["500"], orange["500"], deepOrange["500"], brown["500"], blueGrey["500"]],
  styles: {}
};
var Circle_default = ColorWrap_default(Circle);

// node_modules/react-color/es/components/chrome/Chrome.js
init_react();
var import_prop_types4 = __toESM(require_prop_types());
var import_reactcss17 = __toESM(require_lib());

// node_modules/react-color/es/components/chrome/ChromeFields.js
init_react();
var import_reactcss14 = __toESM(require_lib());

// node_modules/lodash-es/isUndefined.js
function isUndefined(value) {
  return value === void 0;
}
var isUndefined_default = isUndefined;

// node_modules/react-color/es/components/chrome/ChromeFields.js
var import_UnfoldMoreHorizontalIcon = __toESM(require_UnfoldMoreHorizontalIcon());
var _createClass7 = function() {
  function defineProperties(target, props) {
    for (var i6 = 0; i6 < props.length; i6++) {
      var descriptor = props[i6];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn7(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ChromeFields = function(_React$Component) {
  _inherits7(ChromeFields2, _React$Component);
  function ChromeFields2(props) {
    _classCallCheck7(this, ChromeFields2);
    var _this = _possibleConstructorReturn7(this, (ChromeFields2.__proto__ || Object.getPrototypeOf(ChromeFields2)).call(this));
    _this.toggleViews = function() {
      if (_this.state.view === "hex") {
        _this.setState({ view: "rgb" });
      } else if (_this.state.view === "rgb") {
        _this.setState({ view: "hsl" });
      } else if (_this.state.view === "hsl") {
        if (_this.props.hsl.a === 1) {
          _this.setState({ view: "hex" });
        } else {
          _this.setState({ view: "rgb" });
        }
      }
    };
    _this.handleChange = function(data, e9) {
      if (data.hex) {
        isValidHex(data.hex) && _this.props.onChange({
          hex: data.hex,
          source: "hex"
        }, e9);
      } else if (data.r || data.g || data.b) {
        _this.props.onChange({
          r: data.r || _this.props.rgb.r,
          g: data.g || _this.props.rgb.g,
          b: data.b || _this.props.rgb.b,
          source: "rgb"
        }, e9);
      } else if (data.a) {
        if (data.a < 0) {
          data.a = 0;
        } else if (data.a > 1) {
          data.a = 1;
        }
        _this.props.onChange({
          h: _this.props.hsl.h,
          s: _this.props.hsl.s,
          l: _this.props.hsl.l,
          a: Math.round(data.a * 100) / 100,
          source: "rgb"
        }, e9);
      } else if (data.h || data.s || data.l) {
        if (typeof data.s === "string" && data.s.includes("%")) {
          data.s = data.s.replace("%", "");
        }
        if (typeof data.l === "string" && data.l.includes("%")) {
          data.l = data.l.replace("%", "");
        }
        if (data.s == 1) {
          data.s = 0.01;
        } else if (data.l == 1) {
          data.l = 0.01;
        }
        _this.props.onChange({
          h: data.h || _this.props.hsl.h,
          s: Number(!isUndefined_default(data.s) ? data.s : _this.props.hsl.s),
          l: Number(!isUndefined_default(data.l) ? data.l : _this.props.hsl.l),
          source: "hsl"
        }, e9);
      }
    };
    _this.showHighlight = function(e9) {
      e9.currentTarget.style.background = "#eee";
    };
    _this.hideHighlight = function(e9) {
      e9.currentTarget.style.background = "transparent";
    };
    if (props.hsl.a !== 1 && props.view === "hex") {
      _this.state = {
        view: "rgb"
      };
    } else {
      _this.state = {
        view: props.view
      };
    }
    return _this;
  }
  _createClass7(ChromeFields2, [{
    key: "render",
    value: function render3() {
      var _this2 = this;
      var styles2 = (0, import_reactcss14.default)({
        "default": {
          wrap: {
            paddingTop: "16px",
            display: "flex"
          },
          fields: {
            flex: "1",
            display: "flex",
            marginLeft: "-6px"
          },
          field: {
            paddingLeft: "6px",
            width: "100%"
          },
          alpha: {
            paddingLeft: "6px",
            width: "100%"
          },
          toggle: {
            width: "32px",
            textAlign: "right",
            position: "relative"
          },
          icon: {
            marginRight: "-4px",
            marginTop: "12px",
            cursor: "pointer",
            position: "relative"
          },
          iconHighlight: {
            position: "absolute",
            width: "24px",
            height: "28px",
            background: "#eee",
            borderRadius: "4px",
            top: "10px",
            left: "12px",
            display: "none"
          },
          input: {
            fontSize: "11px",
            color: "#333",
            width: "100%",
            borderRadius: "2px",
            border: "none",
            boxShadow: "inset 0 0 0 1px #dadada",
            height: "21px",
            textAlign: "center"
          },
          label: {
            textTransform: "uppercase",
            fontSize: "11px",
            lineHeight: "11px",
            color: "#969696",
            textAlign: "center",
            display: "block",
            marginTop: "12px"
          },
          svg: {
            fill: "#333",
            width: "24px",
            height: "24px",
            border: "1px transparent solid",
            borderRadius: "5px"
          }
        },
        "disableAlpha": {
          alpha: {
            display: "none"
          }
        }
      }, this.props, this.state);
      var fields = void 0;
      if (this.state.view === "hex") {
        fields = Cn.createElement(
          "div",
          { style: styles2.fields, className: "flexbox-fix" },
          Cn.createElement(
            "div",
            { style: styles2.field },
            Cn.createElement(EditableInput_default, {
              style: { input: styles2.input, label: styles2.label },
              label: "hex",
              value: this.props.hex,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === "rgb") {
        fields = Cn.createElement(
          "div",
          { style: styles2.fields, className: "flexbox-fix" },
          Cn.createElement(
            "div",
            { style: styles2.field },
            Cn.createElement(EditableInput_default, {
              style: { input: styles2.input, label: styles2.label },
              label: "r",
              value: this.props.rgb.r,
              onChange: this.handleChange
            })
          ),
          Cn.createElement(
            "div",
            { style: styles2.field },
            Cn.createElement(EditableInput_default, {
              style: { input: styles2.input, label: styles2.label },
              label: "g",
              value: this.props.rgb.g,
              onChange: this.handleChange
            })
          ),
          Cn.createElement(
            "div",
            { style: styles2.field },
            Cn.createElement(EditableInput_default, {
              style: { input: styles2.input, label: styles2.label },
              label: "b",
              value: this.props.rgb.b,
              onChange: this.handleChange
            })
          ),
          Cn.createElement(
            "div",
            { style: styles2.alpha },
            Cn.createElement(EditableInput_default, {
              style: { input: styles2.input, label: styles2.label },
              label: "a",
              value: this.props.rgb.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === "hsl") {
        fields = Cn.createElement(
          "div",
          { style: styles2.fields, className: "flexbox-fix" },
          Cn.createElement(
            "div",
            { style: styles2.field },
            Cn.createElement(EditableInput_default, {
              style: { input: styles2.input, label: styles2.label },
              label: "h",
              value: Math.round(this.props.hsl.h),
              onChange: this.handleChange
            })
          ),
          Cn.createElement(
            "div",
            { style: styles2.field },
            Cn.createElement(EditableInput_default, {
              style: { input: styles2.input, label: styles2.label },
              label: "s",
              value: Math.round(this.props.hsl.s * 100) + "%",
              onChange: this.handleChange
            })
          ),
          Cn.createElement(
            "div",
            { style: styles2.field },
            Cn.createElement(EditableInput_default, {
              style: { input: styles2.input, label: styles2.label },
              label: "l",
              value: Math.round(this.props.hsl.l * 100) + "%",
              onChange: this.handleChange
            })
          ),
          Cn.createElement(
            "div",
            { style: styles2.alpha },
            Cn.createElement(EditableInput_default, {
              style: { input: styles2.input, label: styles2.label },
              label: "a",
              value: this.props.hsl.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      }
      return Cn.createElement(
        "div",
        { style: styles2.wrap, className: "flexbox-fix" },
        fields,
        Cn.createElement(
          "div",
          { style: styles2.toggle },
          Cn.createElement(
            "div",
            { style: styles2.icon, onClick: this.toggleViews, ref: function ref(icon) {
              return _this2.icon = icon;
            } },
            Cn.createElement(import_UnfoldMoreHorizontalIcon.default, {
              style: styles2.svg,
              onMouseOver: this.showHighlight,
              onMouseEnter: this.showHighlight,
              onMouseOut: this.hideHighlight
            })
          )
        )
      );
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, state) {
      if (nextProps.hsl.a !== 1 && state.view === "hex") {
        return { view: "rgb" };
      }
      return null;
    }
  }]);
  return ChromeFields2;
}(Cn.Component);
ChromeFields.defaultProps = {
  view: "hex"
};
var ChromeFields_default = ChromeFields;

// node_modules/react-color/es/components/chrome/ChromePointer.js
init_react();
var import_reactcss15 = __toESM(require_lib());
var ChromePointer = function ChromePointer2() {
  var styles2 = (0, import_reactcss15.default)({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        transform: "translate(-6px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    }
  });
  return Cn.createElement("div", { style: styles2.picker });
};
var ChromePointer_default = ChromePointer;

// node_modules/react-color/es/components/chrome/ChromePointerCircle.js
init_react();
var import_reactcss16 = __toESM(require_lib());
var ChromePointerCircle = function ChromePointerCircle2() {
  var styles2 = (0, import_reactcss16.default)({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        boxShadow: "inset 0 0 0 1px #fff",
        transform: "translate(-6px, -6px)"
      }
    }
  });
  return Cn.createElement("div", { style: styles2.picker });
};
var ChromePointerCircle_default = ChromePointerCircle;

// node_modules/react-color/es/components/chrome/Chrome.js
var Chrome = function Chrome2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, disableAlpha = _ref.disableAlpha, rgb2 = _ref.rgb, hsl3 = _ref.hsl, hsv = _ref.hsv, hex2 = _ref.hex, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className, defaultView = _ref.defaultView;
  var styles2 = (0, import_reactcss17.default)(merge_default({
    "default": {
      picker: {
        width,
        background: "#fff",
        borderRadius: "2px",
        boxShadow: "0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)",
        boxSizing: "initial",
        fontFamily: "Menlo"
      },
      saturation: {
        width: "100%",
        paddingBottom: "55%",
        position: "relative",
        borderRadius: "2px 2px 0 0",
        overflow: "hidden"
      },
      Saturation: {
        radius: "2px 2px 0 0"
      },
      body: {
        padding: "16px 16px 12px"
      },
      controls: {
        display: "flex"
      },
      color: {
        width: "32px"
      },
      swatch: {
        marginTop: "6px",
        width: "16px",
        height: "16px",
        borderRadius: "8px",
        position: "relative",
        overflow: "hidden"
      },
      active: {
        absolute: "0px 0px 0px 0px",
        borderRadius: "8px",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.1)",
        background: "rgba(" + rgb2.r + ", " + rgb2.g + ", " + rgb2.b + ", " + rgb2.a + ")",
        zIndex: "2"
      },
      toggles: {
        flex: "1"
      },
      hue: {
        height: "10px",
        position: "relative",
        marginBottom: "8px"
      },
      Hue: {
        radius: "2px"
      },
      alpha: {
        height: "10px",
        position: "relative"
      },
      Alpha: {
        radius: "2px"
      }
    },
    "disableAlpha": {
      color: {
        width: "22px"
      },
      alpha: {
        display: "none"
      },
      hue: {
        marginBottom: "0px"
      },
      swatch: {
        width: "10px",
        height: "10px",
        marginTop: "0px"
      }
    }
  }, passedStyles), { disableAlpha });
  return Cn.createElement(
    "div",
    { style: styles2.picker, className: "chrome-picker " + className },
    Cn.createElement(
      "div",
      { style: styles2.saturation },
      Cn.createElement(Saturation_default, {
        style: styles2.Saturation,
        hsl: hsl3,
        hsv,
        pointer: ChromePointerCircle_default,
        onChange
      })
    ),
    Cn.createElement(
      "div",
      { style: styles2.body },
      Cn.createElement(
        "div",
        { style: styles2.controls, className: "flexbox-fix" },
        Cn.createElement(
          "div",
          { style: styles2.color },
          Cn.createElement(
            "div",
            { style: styles2.swatch },
            Cn.createElement("div", { style: styles2.active }),
            Cn.createElement(Checkboard_default, { renderers })
          )
        ),
        Cn.createElement(
          "div",
          { style: styles2.toggles },
          Cn.createElement(
            "div",
            { style: styles2.hue },
            Cn.createElement(Hue_default, {
              style: styles2.Hue,
              hsl: hsl3,
              pointer: ChromePointer_default,
              onChange
            })
          ),
          Cn.createElement(
            "div",
            { style: styles2.alpha },
            Cn.createElement(Alpha_default, {
              style: styles2.Alpha,
              rgb: rgb2,
              hsl: hsl3,
              pointer: ChromePointer_default,
              renderers,
              onChange
            })
          )
        )
      ),
      Cn.createElement(ChromeFields_default, {
        rgb: rgb2,
        hsl: hsl3,
        hex: hex2,
        view: defaultView,
        onChange,
        disableAlpha
      })
    )
  );
};
Chrome.propTypes = {
  width: import_prop_types4.default.oneOfType([import_prop_types4.default.string, import_prop_types4.default.number]),
  disableAlpha: import_prop_types4.default.bool,
  styles: import_prop_types4.default.object,
  defaultView: import_prop_types4.default.oneOf(["hex", "rgb", "hsl"])
};
Chrome.defaultProps = {
  width: 225,
  disableAlpha: false,
  styles: {}
};
var Chrome_default = ColorWrap_default(Chrome);

// node_modules/react-color/es/components/compact/Compact.js
init_react();
var import_prop_types5 = __toESM(require_prop_types());
var import_reactcss20 = __toESM(require_lib());

// node_modules/react-color/es/components/compact/CompactColor.js
init_react();
var import_reactcss18 = __toESM(require_lib());
var CompactColor = function CompactColor2(_ref) {
  var color3 = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, active = _ref.active;
  var styles2 = (0, import_reactcss18.default)({
    "default": {
      color: {
        background: color3,
        width: "15px",
        height: "15px",
        float: "left",
        marginRight: "5px",
        marginBottom: "5px",
        position: "relative",
        cursor: "pointer"
      },
      dot: {
        absolute: "5px 5px 5px 5px",
        background: getContrastingColor(color3),
        borderRadius: "50%",
        opacity: "0"
      }
    },
    "active": {
      dot: {
        opacity: "1"
      }
    },
    "color-#FFFFFF": {
      color: {
        boxShadow: "inset 0 0 0 1px #ddd"
      },
      dot: {
        background: "#000"
      }
    },
    "transparent": {
      dot: {
        background: "#000"
      }
    }
  }, { active, "color-#FFFFFF": color3 === "#FFFFFF", "transparent": color3 === "transparent" });
  return Cn.createElement(
    Swatch_default,
    {
      style: styles2.color,
      color: color3,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: "0 0 4px " + color3 }
    },
    Cn.createElement("div", { style: styles2.dot })
  );
};
var CompactColor_default = CompactColor;

// node_modules/react-color/es/components/compact/CompactFields.js
init_react();
var import_reactcss19 = __toESM(require_lib());
var CompactFields = function CompactFields2(_ref) {
  var hex2 = _ref.hex, rgb2 = _ref.rgb, onChange = _ref.onChange;
  var styles2 = (0, import_reactcss19.default)({
    "default": {
      fields: {
        display: "flex",
        paddingBottom: "6px",
        paddingRight: "5px",
        position: "relative"
      },
      active: {
        position: "absolute",
        top: "6px",
        left: "5px",
        height: "9px",
        width: "9px",
        background: hex2
      },
      HEXwrap: {
        flex: "6",
        position: "relative"
      },
      HEXinput: {
        width: "80%",
        padding: "0px",
        paddingLeft: "20%",
        border: "none",
        outline: "none",
        background: "none",
        fontSize: "12px",
        color: "#333",
        height: "16px"
      },
      HEXlabel: {
        display: "none"
      },
      RGBwrap: {
        flex: "3",
        position: "relative"
      },
      RGBinput: {
        width: "70%",
        padding: "0px",
        paddingLeft: "30%",
        border: "none",
        outline: "none",
        background: "none",
        fontSize: "12px",
        color: "#333",
        height: "16px"
      },
      RGBlabel: {
        position: "absolute",
        top: "3px",
        left: "0px",
        lineHeight: "16px",
        textTransform: "uppercase",
        fontSize: "12px",
        color: "#999"
      }
    }
  });
  var handleChange = function handleChange2(data, e9) {
    if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb2.r,
        g: data.g || rgb2.g,
        b: data.b || rgb2.b,
        source: "rgb"
      }, e9);
    } else {
      onChange({
        hex: data.hex,
        source: "hex"
      }, e9);
    }
  };
  return Cn.createElement(
    "div",
    { style: styles2.fields, className: "flexbox-fix" },
    Cn.createElement("div", { style: styles2.active }),
    Cn.createElement(EditableInput_default, {
      style: { wrap: styles2.HEXwrap, input: styles2.HEXinput, label: styles2.HEXlabel },
      label: "hex",
      value: hex2,
      onChange: handleChange
    }),
    Cn.createElement(EditableInput_default, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "r",
      value: rgb2.r,
      onChange: handleChange
    }),
    Cn.createElement(EditableInput_default, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "g",
      value: rgb2.g,
      onChange: handleChange
    }),
    Cn.createElement(EditableInput_default, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "b",
      value: rgb2.b,
      onChange: handleChange
    })
  );
};
var CompactFields_default = CompactFields;

// node_modules/react-color/es/components/compact/Compact.js
var Compact = function Compact2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors2 = _ref.colors, hex2 = _ref.hex, rgb2 = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = (0, import_reactcss20.default)(merge_default({
    "default": {
      Compact: {
        background: "#f6f6f6",
        radius: "4px"
      },
      compact: {
        paddingTop: "5px",
        paddingLeft: "5px",
        boxSizing: "initial",
        width: "240px"
      },
      clear: {
        clear: "both"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e9) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e9);
    } else {
      onChange(data, e9);
    }
  };
  return Cn.createElement(
    Raised_default,
    { style: styles2.Compact, styles: passedStyles },
    Cn.createElement(
      "div",
      { style: styles2.compact, className: "compact-picker " + className },
      Cn.createElement(
        "div",
        null,
        map_default(colors2, function(c9) {
          return Cn.createElement(CompactColor_default, {
            key: c9,
            color: c9,
            active: c9.toLowerCase() === hex2,
            onClick: handleChange,
            onSwatchHover
          });
        }),
        Cn.createElement("div", { style: styles2.clear })
      ),
      Cn.createElement(CompactFields_default, { hex: hex2, rgb: rgb2, onChange: handleChange })
    )
  );
};
Compact.propTypes = {
  colors: import_prop_types5.default.arrayOf(import_prop_types5.default.string),
  styles: import_prop_types5.default.object
};
Compact.defaultProps = {
  colors: ["#4D4D4D", "#999999", "#FFFFFF", "#F44E3B", "#FE9200", "#FCDC00", "#DBDF00", "#A4DD00", "#68CCCA", "#73D8FF", "#AEA1FF", "#FDA1FF", "#333333", "#808080", "#cccccc", "#D33115", "#E27300", "#FCC400", "#B0BC00", "#68BC00", "#16A5A5", "#009CE0", "#7B64FF", "#FA28FF", "#000000", "#666666", "#B3B3B3", "#9F0500", "#C45100", "#FB9E00", "#808900", "#194D33", "#0C797D", "#0062B1", "#653294", "#AB149E"],
  styles: {}
};
var Compact_default = ColorWrap_default(Compact);

// node_modules/react-color/es/components/github/Github.js
init_react();
var import_prop_types6 = __toESM(require_prop_types());
var import_reactcss22 = __toESM(require_lib());

// node_modules/react-color/es/components/github/GithubSwatch.js
init_react();
var import_reactcss21 = __toESM(require_lib());
var GithubSwatch = function GithubSwatch2(_ref) {
  var hover = _ref.hover, color3 = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
  var hoverSwatch = {
    position: "relative",
    zIndex: "2",
    outline: "2px solid #fff",
    boxShadow: "0 0 5px 2px rgba(0,0,0,0.25)"
  };
  var styles2 = (0, import_reactcss21.default)({
    "default": {
      swatch: {
        width: "25px",
        height: "25px",
        fontSize: "0"
      }
    },
    "hover": {
      swatch: hoverSwatch
    }
  }, { hover });
  return Cn.createElement(
    "div",
    { style: styles2.swatch },
    Cn.createElement(Swatch_default, {
      color: color3,
      onClick,
      onHover: onSwatchHover,
      focusStyle: hoverSwatch
    })
  );
};
var GithubSwatch_default = (0, import_reactcss21.handleHover)(GithubSwatch);

// node_modules/react-color/es/components/github/Github.js
var Github = function Github2(_ref) {
  var width = _ref.width, colors2 = _ref.colors, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = (0, import_reactcss22.default)(merge_default({
    "default": {
      card: {
        width,
        background: "#fff",
        border: "1px solid rgba(0,0,0,0.2)",
        boxShadow: "0 3px 12px rgba(0,0,0,0.15)",
        borderRadius: "4px",
        position: "relative",
        padding: "5px",
        display: "flex",
        flexWrap: "wrap"
      },
      triangle: {
        position: "absolute",
        border: "7px solid transparent",
        borderBottomColor: "#fff"
      },
      triangleShadow: {
        position: "absolute",
        border: "8px solid transparent",
        borderBottomColor: "rgba(0,0,0,0.15)"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      },
      triangleShadow: {
        display: "none"
      }
    },
    "top-left-triangle": {
      triangle: {
        top: "-14px",
        left: "10px"
      },
      triangleShadow: {
        top: "-16px",
        left: "9px"
      }
    },
    "top-right-triangle": {
      triangle: {
        top: "-14px",
        right: "10px"
      },
      triangleShadow: {
        top: "-16px",
        right: "9px"
      }
    },
    "bottom-left-triangle": {
      triangle: {
        top: "35px",
        left: "10px",
        transform: "rotate(180deg)"
      },
      triangleShadow: {
        top: "37px",
        left: "9px",
        transform: "rotate(180deg)"
      }
    },
    "bottom-right-triangle": {
      triangle: {
        top: "35px",
        right: "10px",
        transform: "rotate(180deg)"
      },
      triangleShadow: {
        top: "37px",
        right: "9px",
        transform: "rotate(180deg)"
      }
    }
  }, passedStyles), {
    "hide-triangle": triangle === "hide",
    "top-left-triangle": triangle === "top-left",
    "top-right-triangle": triangle === "top-right",
    "bottom-left-triangle": triangle === "bottom-left",
    "bottom-right-triangle": triangle === "bottom-right"
  });
  var handleChange = function handleChange2(hex2, e9) {
    return onChange({ hex: hex2, source: "hex" }, e9);
  };
  return Cn.createElement(
    "div",
    { style: styles2.card, className: "github-picker " + className },
    Cn.createElement("div", { style: styles2.triangleShadow }),
    Cn.createElement("div", { style: styles2.triangle }),
    map_default(colors2, function(c9) {
      return Cn.createElement(GithubSwatch_default, {
        color: c9,
        key: c9,
        onClick: handleChange,
        onSwatchHover
      });
    })
  );
};
Github.propTypes = {
  width: import_prop_types6.default.oneOfType([import_prop_types6.default.string, import_prop_types6.default.number]),
  colors: import_prop_types6.default.arrayOf(import_prop_types6.default.string),
  triangle: import_prop_types6.default.oneOf(["hide", "top-left", "top-right", "bottom-left", "bottom-right"]),
  styles: import_prop_types6.default.object
};
Github.defaultProps = {
  width: 200,
  colors: ["#B80000", "#DB3E00", "#FCCB00", "#008B02", "#006B76", "#1273DE", "#004DCF", "#5300EB", "#EB9694", "#FAD0C3", "#FEF3BD", "#C1E1C5", "#BEDADC", "#C4DEF6", "#BED3F3", "#D4C4FB"],
  triangle: "top-left",
  styles: {}
};
var Github_default = ColorWrap_default(Github);

// node_modules/react-color/es/components/hue/Hue.js
init_react();
var import_prop_types7 = __toESM(require_prop_types());
var import_reactcss24 = __toESM(require_lib());

// node_modules/react-color/es/components/hue/HuePointer.js
init_react();
var import_reactcss23 = __toESM(require_lib());
var SliderPointer = function SliderPointer2(_ref) {
  var direction = _ref.direction;
  var styles2 = (0, import_reactcss23.default)({
    "default": {
      picker: {
        width: "18px",
        height: "18px",
        borderRadius: "50%",
        transform: "translate(-9px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    },
    "vertical": {
      picker: {
        transform: "translate(-3px, -9px)"
      }
    }
  }, { vertical: direction === "vertical" });
  return Cn.createElement("div", { style: styles2.picker });
};
var HuePointer_default = SliderPointer;

// node_modules/react-color/es/components/hue/Hue.js
var _extends7 = Object.assign || function(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var HuePicker = function HuePicker2(_ref) {
  var width = _ref.width, height = _ref.height, onChange = _ref.onChange, hsl3 = _ref.hsl, direction = _ref.direction, pointer2 = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = (0, import_reactcss24.default)(merge_default({
    "default": {
      picker: {
        position: "relative",
        width,
        height
      },
      hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data) {
    return onChange({ a: 1, h: data.h, l: 0.5, s: 1 });
  };
  return Cn.createElement(
    "div",
    { style: styles2.picker, className: "hue-picker " + className },
    Cn.createElement(Hue_default, _extends7({}, styles2.hue, {
      hsl: hsl3,
      pointer: pointer2,
      onChange: handleChange,
      direction
    }))
  );
};
HuePicker.propTypes = {
  styles: import_prop_types7.default.object
};
HuePicker.defaultProps = {
  width: "316px",
  height: "16px",
  direction: "horizontal",
  pointer: HuePointer_default,
  styles: {}
};
var Hue_default2 = ColorWrap_default(HuePicker);

// node_modules/react-color/es/components/material/Material.js
init_react();
var import_reactcss25 = __toESM(require_lib());
var Material = function Material2(_ref) {
  var onChange = _ref.onChange, hex2 = _ref.hex, rgb2 = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = (0, import_reactcss25.default)(merge_default({
    "default": {
      material: {
        width: "98px",
        height: "98px",
        padding: "16px",
        fontFamily: "Roboto"
      },
      HEXwrap: {
        position: "relative"
      },
      HEXinput: {
        width: "100%",
        marginTop: "12px",
        fontSize: "15px",
        color: "#333",
        padding: "0px",
        border: "0px",
        borderBottom: "2px solid " + hex2,
        outline: "none",
        height: "30px"
      },
      HEXlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        fontSize: "11px",
        color: "#999999",
        textTransform: "capitalize"
      },
      Hex: {
        style: {}
      },
      RGBwrap: {
        position: "relative"
      },
      RGBinput: {
        width: "100%",
        marginTop: "12px",
        fontSize: "15px",
        color: "#333",
        padding: "0px",
        border: "0px",
        borderBottom: "1px solid #eee",
        outline: "none",
        height: "30px"
      },
      RGBlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        fontSize: "11px",
        color: "#999999",
        textTransform: "capitalize"
      },
      split: {
        display: "flex",
        marginRight: "-10px",
        paddingTop: "11px"
      },
      third: {
        flex: "1",
        paddingRight: "10px"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e9) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e9);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb2.r,
        g: data.g || rgb2.g,
        b: data.b || rgb2.b,
        source: "rgb"
      }, e9);
    }
  };
  return Cn.createElement(
    Raised_default,
    { styles: passedStyles },
    Cn.createElement(
      "div",
      { style: styles2.material, className: "material-picker " + className },
      Cn.createElement(EditableInput_default, {
        style: { wrap: styles2.HEXwrap, input: styles2.HEXinput, label: styles2.HEXlabel },
        label: "hex",
        value: hex2,
        onChange: handleChange
      }),
      Cn.createElement(
        "div",
        { style: styles2.split, className: "flexbox-fix" },
        Cn.createElement(
          "div",
          { style: styles2.third },
          Cn.createElement(EditableInput_default, {
            style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
            label: "r",
            value: rgb2.r,
            onChange: handleChange
          })
        ),
        Cn.createElement(
          "div",
          { style: styles2.third },
          Cn.createElement(EditableInput_default, {
            style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
            label: "g",
            value: rgb2.g,
            onChange: handleChange
          })
        ),
        Cn.createElement(
          "div",
          { style: styles2.third },
          Cn.createElement(EditableInput_default, {
            style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
            label: "b",
            value: rgb2.b,
            onChange: handleChange
          })
        )
      )
    )
  );
};
var Material_default = ColorWrap_default(Material);

// node_modules/react-color/es/components/photoshop/Photoshop.js
init_react();
var import_prop_types8 = __toESM(require_prop_types());
var import_reactcss31 = __toESM(require_lib());

// node_modules/react-color/es/components/photoshop/PhotoshopFields.js
init_react();
var import_reactcss26 = __toESM(require_lib());
var PhotoshopPicker = function PhotoshopPicker2(_ref) {
  var onChange = _ref.onChange, rgb2 = _ref.rgb, hsv = _ref.hsv, hex2 = _ref.hex;
  var styles2 = (0, import_reactcss26.default)({
    "default": {
      fields: {
        paddingTop: "5px",
        paddingBottom: "9px",
        width: "80px",
        position: "relative"
      },
      divider: {
        height: "5px"
      },
      RGBwrap: {
        position: "relative"
      },
      RGBinput: {
        marginLeft: "40%",
        width: "40%",
        height: "18px",
        border: "1px solid #888888",
        boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
        marginBottom: "5px",
        fontSize: "13px",
        paddingLeft: "3px",
        marginRight: "10px"
      },
      RGBlabel: {
        left: "0px",
        top: "0px",
        width: "34px",
        textTransform: "uppercase",
        fontSize: "13px",
        height: "18px",
        lineHeight: "22px",
        position: "absolute"
      },
      HEXwrap: {
        position: "relative"
      },
      HEXinput: {
        marginLeft: "20%",
        width: "80%",
        height: "18px",
        border: "1px solid #888888",
        boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
        marginBottom: "6px",
        fontSize: "13px",
        paddingLeft: "3px"
      },
      HEXlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        width: "14px",
        textTransform: "uppercase",
        fontSize: "13px",
        height: "18px",
        lineHeight: "22px"
      },
      fieldSymbols: {
        position: "absolute",
        top: "5px",
        right: "-7px",
        fontSize: "13px"
      },
      symbol: {
        height: "20px",
        lineHeight: "22px",
        paddingBottom: "7px"
      }
    }
  });
  var handleChange = function handleChange2(data, e9) {
    if (data["#"]) {
      isValidHex(data["#"]) && onChange({
        hex: data["#"],
        source: "hex"
      }, e9);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb2.r,
        g: data.g || rgb2.g,
        b: data.b || rgb2.b,
        source: "rgb"
      }, e9);
    } else if (data.h || data.s || data.v) {
      onChange({
        h: data.h || hsv.h,
        s: data.s || hsv.s,
        v: data.v || hsv.v,
        source: "hsv"
      }, e9);
    }
  };
  return Cn.createElement(
    "div",
    { style: styles2.fields },
    Cn.createElement(EditableInput_default, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "h",
      value: Math.round(hsv.h),
      onChange: handleChange
    }),
    Cn.createElement(EditableInput_default, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "s",
      value: Math.round(hsv.s * 100),
      onChange: handleChange
    }),
    Cn.createElement(EditableInput_default, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "v",
      value: Math.round(hsv.v * 100),
      onChange: handleChange
    }),
    Cn.createElement("div", { style: styles2.divider }),
    Cn.createElement(EditableInput_default, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "r",
      value: rgb2.r,
      onChange: handleChange
    }),
    Cn.createElement(EditableInput_default, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "g",
      value: rgb2.g,
      onChange: handleChange
    }),
    Cn.createElement(EditableInput_default, {
      style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
      label: "b",
      value: rgb2.b,
      onChange: handleChange
    }),
    Cn.createElement("div", { style: styles2.divider }),
    Cn.createElement(EditableInput_default, {
      style: { wrap: styles2.HEXwrap, input: styles2.HEXinput, label: styles2.HEXlabel },
      label: "#",
      value: hex2.replace("#", ""),
      onChange: handleChange
    }),
    Cn.createElement(
      "div",
      { style: styles2.fieldSymbols },
      Cn.createElement(
        "div",
        { style: styles2.symbol },
        "\xB0"
      ),
      Cn.createElement(
        "div",
        { style: styles2.symbol },
        "%"
      ),
      Cn.createElement(
        "div",
        { style: styles2.symbol },
        "%"
      )
    )
  );
};
var PhotoshopFields_default = PhotoshopPicker;

// node_modules/react-color/es/components/photoshop/PhotoshopPointerCircle.js
init_react();
var import_reactcss27 = __toESM(require_lib());
var PhotoshopPointerCircle = function PhotoshopPointerCircle2(_ref) {
  var hsl3 = _ref.hsl;
  var styles2 = (0, import_reactcss27.default)({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        boxShadow: "inset 0 0 0 1px #fff",
        transform: "translate(-6px, -6px)"
      }
    },
    "black-outline": {
      picker: {
        boxShadow: "inset 0 0 0 1px #000"
      }
    }
  }, { "black-outline": hsl3.l > 0.5 });
  return Cn.createElement("div", { style: styles2.picker });
};
var PhotoshopPointerCircle_default = PhotoshopPointerCircle;

// node_modules/react-color/es/components/photoshop/PhotoshopPointer.js
init_react();
var import_reactcss28 = __toESM(require_lib());
var PhotoshopPointerCircle3 = function PhotoshopPointerCircle4() {
  var styles2 = (0, import_reactcss28.default)({
    "default": {
      triangle: {
        width: 0,
        height: 0,
        borderStyle: "solid",
        borderWidth: "4px 0 4px 6px",
        borderColor: "transparent transparent transparent #fff",
        position: "absolute",
        top: "1px",
        left: "1px"
      },
      triangleBorder: {
        width: 0,
        height: 0,
        borderStyle: "solid",
        borderWidth: "5px 0 5px 8px",
        borderColor: "transparent transparent transparent #555"
      },
      left: {
        Extend: "triangleBorder",
        transform: "translate(-13px, -4px)"
      },
      leftInside: {
        Extend: "triangle",
        transform: "translate(-8px, -5px)"
      },
      right: {
        Extend: "triangleBorder",
        transform: "translate(20px, -14px) rotate(180deg)"
      },
      rightInside: {
        Extend: "triangle",
        transform: "translate(-8px, -5px)"
      }
    }
  });
  return Cn.createElement(
    "div",
    { style: styles2.pointer },
    Cn.createElement(
      "div",
      { style: styles2.left },
      Cn.createElement("div", { style: styles2.leftInside })
    ),
    Cn.createElement(
      "div",
      { style: styles2.right },
      Cn.createElement("div", { style: styles2.rightInside })
    )
  );
};
var PhotoshopPointer_default = PhotoshopPointerCircle3;

// node_modules/react-color/es/components/photoshop/PhotoshopButton.js
init_react();
var import_reactcss29 = __toESM(require_lib());
var PhotoshopButton = function PhotoshopButton2(_ref) {
  var onClick = _ref.onClick, label = _ref.label, children2 = _ref.children, active = _ref.active;
  var styles2 = (0, import_reactcss29.default)({
    "default": {
      button: {
        backgroundImage: "linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)",
        border: "1px solid #878787",
        borderRadius: "2px",
        height: "20px",
        boxShadow: "0 1px 0 0 #EAEAEA",
        fontSize: "14px",
        color: "#000",
        lineHeight: "20px",
        textAlign: "center",
        marginBottom: "10px",
        cursor: "pointer"
      }
    },
    "active": {
      button: {
        boxShadow: "0 0 0 1px #878787"
      }
    }
  }, { active });
  return Cn.createElement(
    "div",
    { style: styles2.button, onClick },
    label || children2
  );
};
var PhotoshopButton_default = PhotoshopButton;

// node_modules/react-color/es/components/photoshop/PhotoshopPreviews.js
init_react();
var import_reactcss30 = __toESM(require_lib());
var PhotoshopPreviews = function PhotoshopPreviews2(_ref) {
  var rgb2 = _ref.rgb, currentColor = _ref.currentColor;
  var styles2 = (0, import_reactcss30.default)({
    "default": {
      swatches: {
        border: "1px solid #B3B3B3",
        borderBottom: "1px solid #F0F0F0",
        marginBottom: "2px",
        marginTop: "1px"
      },
      new: {
        height: "34px",
        background: "rgb(" + rgb2.r + "," + rgb2.g + ", " + rgb2.b + ")",
        boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000"
      },
      current: {
        height: "34px",
        background: currentColor,
        boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000"
      },
      label: {
        fontSize: "14px",
        color: "#000",
        textAlign: "center"
      }
    }
  });
  return Cn.createElement(
    "div",
    null,
    Cn.createElement(
      "div",
      { style: styles2.label },
      "new"
    ),
    Cn.createElement(
      "div",
      { style: styles2.swatches },
      Cn.createElement("div", { style: styles2.new }),
      Cn.createElement("div", { style: styles2.current })
    ),
    Cn.createElement(
      "div",
      { style: styles2.label },
      "current"
    )
  );
};
var PhotoshopPreviews_default = PhotoshopPreviews;

// node_modules/react-color/es/components/photoshop/Photoshop.js
var _createClass8 = function() {
  function defineProperties(target, props) {
    for (var i6 = 0; i6 < props.length; i6++) {
      var descriptor = props[i6];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn8(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Photoshop = function(_React$Component) {
  _inherits8(Photoshop2, _React$Component);
  function Photoshop2(props) {
    _classCallCheck8(this, Photoshop2);
    var _this = _possibleConstructorReturn8(this, (Photoshop2.__proto__ || Object.getPrototypeOf(Photoshop2)).call(this));
    _this.state = {
      currentColor: props.hex
    };
    return _this;
  }
  _createClass8(Photoshop2, [{
    key: "render",
    value: function render3() {
      var _props = this.props, _props$styles = _props.styles, passedStyles = _props$styles === void 0 ? {} : _props$styles, _props$className = _props.className, className = _props$className === void 0 ? "" : _props$className;
      var styles2 = (0, import_reactcss31.default)(merge_default({
        "default": {
          picker: {
            background: "#DCDCDC",
            borderRadius: "4px",
            boxShadow: "0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)",
            boxSizing: "initial",
            width: "513px"
          },
          head: {
            backgroundImage: "linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)",
            borderBottom: "1px solid #B1B1B1",
            boxShadow: "inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)",
            height: "23px",
            lineHeight: "24px",
            borderRadius: "4px 4px 0 0",
            fontSize: "13px",
            color: "#4D4D4D",
            textAlign: "center"
          },
          body: {
            padding: "15px 15px 0",
            display: "flex"
          },
          saturation: {
            width: "256px",
            height: "256px",
            position: "relative",
            border: "2px solid #B3B3B3",
            borderBottom: "2px solid #F0F0F0",
            overflow: "hidden"
          },
          hue: {
            position: "relative",
            height: "256px",
            width: "19px",
            marginLeft: "10px",
            border: "2px solid #B3B3B3",
            borderBottom: "2px solid #F0F0F0"
          },
          controls: {
            width: "180px",
            marginLeft: "10px"
          },
          top: {
            display: "flex"
          },
          previews: {
            width: "60px"
          },
          actions: {
            flex: "1",
            marginLeft: "20px"
          }
        }
      }, passedStyles));
      return Cn.createElement(
        "div",
        { style: styles2.picker, className: "photoshop-picker " + className },
        Cn.createElement(
          "div",
          { style: styles2.head },
          this.props.header
        ),
        Cn.createElement(
          "div",
          { style: styles2.body, className: "flexbox-fix" },
          Cn.createElement(
            "div",
            { style: styles2.saturation },
            Cn.createElement(Saturation_default, {
              hsl: this.props.hsl,
              hsv: this.props.hsv,
              pointer: PhotoshopPointerCircle_default,
              onChange: this.props.onChange
            })
          ),
          Cn.createElement(
            "div",
            { style: styles2.hue },
            Cn.createElement(Hue_default, {
              direction: "vertical",
              hsl: this.props.hsl,
              pointer: PhotoshopPointer_default,
              onChange: this.props.onChange
            })
          ),
          Cn.createElement(
            "div",
            { style: styles2.controls },
            Cn.createElement(
              "div",
              { style: styles2.top, className: "flexbox-fix" },
              Cn.createElement(
                "div",
                { style: styles2.previews },
                Cn.createElement(PhotoshopPreviews_default, {
                  rgb: this.props.rgb,
                  currentColor: this.state.currentColor
                })
              ),
              Cn.createElement(
                "div",
                { style: styles2.actions },
                Cn.createElement(PhotoshopButton_default, { label: "OK", onClick: this.props.onAccept, active: true }),
                Cn.createElement(PhotoshopButton_default, { label: "Cancel", onClick: this.props.onCancel }),
                Cn.createElement(PhotoshopFields_default, {
                  onChange: this.props.onChange,
                  rgb: this.props.rgb,
                  hsv: this.props.hsv,
                  hex: this.props.hex
                })
              )
            )
          )
        )
      );
    }
  }]);
  return Photoshop2;
}(Cn.Component);
Photoshop.propTypes = {
  header: import_prop_types8.default.string,
  styles: import_prop_types8.default.object
};
Photoshop.defaultProps = {
  header: "Color Picker",
  styles: {}
};
var Photoshop_default = ColorWrap_default(Photoshop);

// node_modules/react-color/es/components/sketch/Sketch.js
init_react();
var import_prop_types10 = __toESM(require_prop_types());
var import_reactcss34 = __toESM(require_lib());

// node_modules/react-color/es/components/sketch/SketchFields.js
init_react();
var import_reactcss32 = __toESM(require_lib());
var SketchFields = function SketchFields2(_ref) {
  var onChange = _ref.onChange, rgb2 = _ref.rgb, hsl3 = _ref.hsl, hex2 = _ref.hex, disableAlpha = _ref.disableAlpha;
  var styles2 = (0, import_reactcss32.default)({
    "default": {
      fields: {
        display: "flex",
        paddingTop: "4px"
      },
      single: {
        flex: "1",
        paddingLeft: "6px"
      },
      alpha: {
        flex: "1",
        paddingLeft: "6px"
      },
      double: {
        flex: "2"
      },
      input: {
        width: "80%",
        padding: "4px 10% 3px",
        border: "none",
        boxShadow: "inset 0 0 0 1px #ccc",
        fontSize: "11px"
      },
      label: {
        display: "block",
        textAlign: "center",
        fontSize: "11px",
        color: "#222",
        paddingTop: "3px",
        paddingBottom: "4px",
        textTransform: "capitalize"
      }
    },
    "disableAlpha": {
      alpha: {
        display: "none"
      }
    }
  }, { disableAlpha });
  var handleChange = function handleChange2(data, e9) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e9);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb2.r,
        g: data.g || rgb2.g,
        b: data.b || rgb2.b,
        a: rgb2.a,
        source: "rgb"
      }, e9);
    } else if (data.a) {
      if (data.a < 0) {
        data.a = 0;
      } else if (data.a > 100) {
        data.a = 100;
      }
      data.a /= 100;
      onChange({
        h: hsl3.h,
        s: hsl3.s,
        l: hsl3.l,
        a: data.a,
        source: "rgb"
      }, e9);
    }
  };
  return Cn.createElement(
    "div",
    { style: styles2.fields, className: "flexbox-fix" },
    Cn.createElement(
      "div",
      { style: styles2.double },
      Cn.createElement(EditableInput_default, {
        style: { input: styles2.input, label: styles2.label },
        label: "hex",
        value: hex2.replace("#", ""),
        onChange: handleChange
      })
    ),
    Cn.createElement(
      "div",
      { style: styles2.single },
      Cn.createElement(EditableInput_default, {
        style: { input: styles2.input, label: styles2.label },
        label: "r",
        value: rgb2.r,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    Cn.createElement(
      "div",
      { style: styles2.single },
      Cn.createElement(EditableInput_default, {
        style: { input: styles2.input, label: styles2.label },
        label: "g",
        value: rgb2.g,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    Cn.createElement(
      "div",
      { style: styles2.single },
      Cn.createElement(EditableInput_default, {
        style: { input: styles2.input, label: styles2.label },
        label: "b",
        value: rgb2.b,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    Cn.createElement(
      "div",
      { style: styles2.alpha },
      Cn.createElement(EditableInput_default, {
        style: { input: styles2.input, label: styles2.label },
        label: "a",
        value: Math.round(rgb2.a * 100),
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "100"
      })
    )
  );
};
var SketchFields_default = SketchFields;

// node_modules/react-color/es/components/sketch/SketchPresetColors.js
init_react();
var import_prop_types9 = __toESM(require_prop_types());
var import_reactcss33 = __toESM(require_lib());
var _extends8 = Object.assign || function(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var SketchPresetColors = function SketchPresetColors2(_ref) {
  var colors2 = _ref.colors, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover;
  var styles2 = (0, import_reactcss33.default)({
    "default": {
      colors: {
        margin: "0 -10px",
        padding: "10px 0 0 10px",
        borderTop: "1px solid #eee",
        display: "flex",
        flexWrap: "wrap",
        position: "relative"
      },
      swatchWrap: {
        width: "16px",
        height: "16px",
        margin: "0 10px 10px 0"
      },
      swatch: {
        borderRadius: "3px",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15)"
      }
    },
    "no-presets": {
      colors: {
        display: "none"
      }
    }
  }, {
    "no-presets": !colors2 || !colors2.length
  });
  var handleClick = function handleClick2(hex2, e9) {
    onClick({
      hex: hex2,
      source: "hex"
    }, e9);
  };
  return Cn.createElement(
    "div",
    { style: styles2.colors, className: "flexbox-fix" },
    colors2.map(function(colorObjOrString) {
      var c9 = typeof colorObjOrString === "string" ? { color: colorObjOrString } : colorObjOrString;
      var key = "" + c9.color + (c9.title || "");
      return Cn.createElement(
        "div",
        { key, style: styles2.swatchWrap },
        Cn.createElement(Swatch_default, _extends8({}, c9, {
          style: styles2.swatch,
          onClick: handleClick,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px " + c9.color
          }
        }))
      );
    })
  );
};
SketchPresetColors.propTypes = {
  colors: import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.string, import_prop_types9.default.shape({
    color: import_prop_types9.default.string,
    title: import_prop_types9.default.string
  })])).isRequired
};
var SketchPresetColors_default = SketchPresetColors;

// node_modules/react-color/es/components/sketch/Sketch.js
var _extends9 = Object.assign || function(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var Sketch = function Sketch2(_ref) {
  var width = _ref.width, rgb2 = _ref.rgb, hex2 = _ref.hex, hsv = _ref.hsv, hsl3 = _ref.hsl, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, disableAlpha = _ref.disableAlpha, presetColors = _ref.presetColors, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = (0, import_reactcss34.default)(merge_default({
    "default": _extends9({
      picker: {
        width,
        padding: "10px 10px 0",
        boxSizing: "initial",
        background: "#fff",
        borderRadius: "4px",
        boxShadow: "0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)"
      },
      saturation: {
        width: "100%",
        paddingBottom: "75%",
        position: "relative",
        overflow: "hidden"
      },
      Saturation: {
        radius: "3px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      controls: {
        display: "flex"
      },
      sliders: {
        padding: "4px 0",
        flex: "1"
      },
      color: {
        width: "24px",
        height: "24px",
        position: "relative",
        marginTop: "4px",
        marginLeft: "4px",
        borderRadius: "3px"
      },
      activeColor: {
        absolute: "0px 0px 0px 0px",
        borderRadius: "2px",
        background: "rgba(" + rgb2.r + "," + rgb2.g + "," + rgb2.b + "," + rgb2.a + ")",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      hue: {
        position: "relative",
        height: "10px",
        overflow: "hidden"
      },
      Hue: {
        radius: "2px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      alpha: {
        position: "relative",
        height: "10px",
        marginTop: "4px",
        overflow: "hidden"
      },
      Alpha: {
        radius: "2px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      }
    }, passedStyles),
    "disableAlpha": {
      color: {
        height: "10px"
      },
      hue: {
        height: "10px"
      },
      alpha: {
        display: "none"
      }
    }
  }, passedStyles), { disableAlpha });
  return Cn.createElement(
    "div",
    { style: styles2.picker, className: "sketch-picker " + className },
    Cn.createElement(
      "div",
      { style: styles2.saturation },
      Cn.createElement(Saturation_default, {
        style: styles2.Saturation,
        hsl: hsl3,
        hsv,
        onChange
      })
    ),
    Cn.createElement(
      "div",
      { style: styles2.controls, className: "flexbox-fix" },
      Cn.createElement(
        "div",
        { style: styles2.sliders },
        Cn.createElement(
          "div",
          { style: styles2.hue },
          Cn.createElement(Hue_default, {
            style: styles2.Hue,
            hsl: hsl3,
            onChange
          })
        ),
        Cn.createElement(
          "div",
          { style: styles2.alpha },
          Cn.createElement(Alpha_default, {
            style: styles2.Alpha,
            rgb: rgb2,
            hsl: hsl3,
            renderers,
            onChange
          })
        )
      ),
      Cn.createElement(
        "div",
        { style: styles2.color },
        Cn.createElement(Checkboard_default, null),
        Cn.createElement("div", { style: styles2.activeColor })
      )
    ),
    Cn.createElement(SketchFields_default, {
      rgb: rgb2,
      hsl: hsl3,
      hex: hex2,
      onChange,
      disableAlpha
    }),
    Cn.createElement(SketchPresetColors_default, {
      colors: presetColors,
      onClick: onChange,
      onSwatchHover
    })
  );
};
Sketch.propTypes = {
  disableAlpha: import_prop_types10.default.bool,
  width: import_prop_types10.default.oneOfType([import_prop_types10.default.string, import_prop_types10.default.number]),
  styles: import_prop_types10.default.object
};
Sketch.defaultProps = {
  disableAlpha: false,
  width: 200,
  styles: {},
  presetColors: ["#D0021B", "#F5A623", "#F8E71C", "#8B572A", "#7ED321", "#417505", "#BD10E0", "#9013FE", "#4A90E2", "#50E3C2", "#B8E986", "#000000", "#4A4A4A", "#9B9B9B", "#FFFFFF"]
};
var Sketch_default = ColorWrap_default(Sketch);

// node_modules/react-color/es/components/slider/Slider.js
init_react();
var import_prop_types11 = __toESM(require_prop_types());
var import_reactcss38 = __toESM(require_lib());

// node_modules/react-color/es/components/slider/SliderSwatches.js
init_react();
var import_reactcss36 = __toESM(require_lib());

// node_modules/react-color/es/components/slider/SliderSwatch.js
init_react();
var import_reactcss35 = __toESM(require_lib());
var SliderSwatch = function SliderSwatch2(_ref) {
  var hsl3 = _ref.hsl, offset2 = _ref.offset, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, active = _ref.active, first2 = _ref.first, last2 = _ref.last;
  var styles2 = (0, import_reactcss35.default)({
    "default": {
      swatch: {
        height: "12px",
        background: "hsl(" + hsl3.h + ", 50%, " + offset2 * 100 + "%)",
        cursor: "pointer"
      }
    },
    "first": {
      swatch: {
        borderRadius: "2px 0 0 2px"
      }
    },
    "last": {
      swatch: {
        borderRadius: "0 2px 2px 0"
      }
    },
    "active": {
      swatch: {
        transform: "scaleY(1.8)",
        borderRadius: "3.6px/2px"
      }
    }
  }, { active, first: first2, last: last2 });
  var handleClick = function handleClick2(e9) {
    return onClick({
      h: hsl3.h,
      s: 0.5,
      l: offset2,
      source: "hsl"
    }, e9);
  };
  return Cn.createElement("div", { style: styles2.swatch, onClick: handleClick });
};
var SliderSwatch_default = SliderSwatch;

// node_modules/react-color/es/components/slider/SliderSwatches.js
var SliderSwatches = function SliderSwatches2(_ref) {
  var onClick = _ref.onClick, hsl3 = _ref.hsl;
  var styles2 = (0, import_reactcss36.default)({
    "default": {
      swatches: {
        marginTop: "20px"
      },
      swatch: {
        boxSizing: "border-box",
        width: "20%",
        paddingRight: "1px",
        float: "left"
      },
      clear: {
        clear: "both"
      }
    }
  });
  var epsilon5 = 0.1;
  return Cn.createElement(
    "div",
    { style: styles2.swatches },
    Cn.createElement(
      "div",
      { style: styles2.swatch },
      Cn.createElement(SliderSwatch_default, {
        hsl: hsl3,
        offset: ".80",
        active: Math.abs(hsl3.l - 0.8) < epsilon5 && Math.abs(hsl3.s - 0.5) < epsilon5,
        onClick,
        first: true
      })
    ),
    Cn.createElement(
      "div",
      { style: styles2.swatch },
      Cn.createElement(SliderSwatch_default, {
        hsl: hsl3,
        offset: ".65",
        active: Math.abs(hsl3.l - 0.65) < epsilon5 && Math.abs(hsl3.s - 0.5) < epsilon5,
        onClick
      })
    ),
    Cn.createElement(
      "div",
      { style: styles2.swatch },
      Cn.createElement(SliderSwatch_default, {
        hsl: hsl3,
        offset: ".50",
        active: Math.abs(hsl3.l - 0.5) < epsilon5 && Math.abs(hsl3.s - 0.5) < epsilon5,
        onClick
      })
    ),
    Cn.createElement(
      "div",
      { style: styles2.swatch },
      Cn.createElement(SliderSwatch_default, {
        hsl: hsl3,
        offset: ".35",
        active: Math.abs(hsl3.l - 0.35) < epsilon5 && Math.abs(hsl3.s - 0.5) < epsilon5,
        onClick
      })
    ),
    Cn.createElement(
      "div",
      { style: styles2.swatch },
      Cn.createElement(SliderSwatch_default, {
        hsl: hsl3,
        offset: ".20",
        active: Math.abs(hsl3.l - 0.2) < epsilon5 && Math.abs(hsl3.s - 0.5) < epsilon5,
        onClick,
        last: true
      })
    ),
    Cn.createElement("div", { style: styles2.clear })
  );
};
var SliderSwatches_default = SliderSwatches;

// node_modules/react-color/es/components/slider/SliderPointer.js
init_react();
var import_reactcss37 = __toESM(require_lib());
var SliderPointer3 = function SliderPointer4() {
  var styles2 = (0, import_reactcss37.default)({
    "default": {
      picker: {
        width: "14px",
        height: "14px",
        borderRadius: "6px",
        transform: "translate(-7px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    }
  });
  return Cn.createElement("div", { style: styles2.picker });
};
var SliderPointer_default = SliderPointer3;

// node_modules/react-color/es/components/slider/Slider.js
var Slider = function Slider2(_ref) {
  var hsl3 = _ref.hsl, onChange = _ref.onChange, pointer2 = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = (0, import_reactcss38.default)(merge_default({
    "default": {
      hue: {
        height: "12px",
        position: "relative"
      },
      Hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  return Cn.createElement(
    "div",
    { style: styles2.wrap || {}, className: "slider-picker " + className },
    Cn.createElement(
      "div",
      { style: styles2.hue },
      Cn.createElement(Hue_default, {
        style: styles2.Hue,
        hsl: hsl3,
        pointer: pointer2,
        onChange
      })
    ),
    Cn.createElement(
      "div",
      { style: styles2.swatches },
      Cn.createElement(SliderSwatches_default, { hsl: hsl3, onClick: onChange })
    )
  );
};
Slider.propTypes = {
  styles: import_prop_types11.default.object
};
Slider.defaultProps = {
  pointer: SliderPointer_default,
  styles: {}
};
var Slider_default = ColorWrap_default(Slider);

// node_modules/react-color/es/components/swatches/Swatches.js
init_react();
var import_prop_types12 = __toESM(require_prop_types());
var import_reactcss41 = __toESM(require_lib());

// node_modules/react-color/es/components/swatches/SwatchesGroup.js
init_react();
var import_reactcss40 = __toESM(require_lib());

// node_modules/react-color/es/components/swatches/SwatchesColor.js
init_react();
var import_reactcss39 = __toESM(require_lib());
var import_CheckIcon = __toESM(require_CheckIcon());
var SwatchesColor = function SwatchesColor2(_ref) {
  var color3 = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, first2 = _ref.first, last2 = _ref.last, active = _ref.active;
  var styles2 = (0, import_reactcss39.default)({
    "default": {
      color: {
        width: "40px",
        height: "24px",
        cursor: "pointer",
        background: color3,
        marginBottom: "1px"
      },
      check: {
        color: getContrastingColor(color3),
        marginLeft: "8px",
        display: "none"
      }
    },
    "first": {
      color: {
        overflow: "hidden",
        borderRadius: "2px 2px 0 0"
      }
    },
    "last": {
      color: {
        overflow: "hidden",
        borderRadius: "0 0 2px 2px"
      }
    },
    "active": {
      check: {
        display: "block"
      }
    },
    "color-#FFFFFF": {
      color: {
        boxShadow: "inset 0 0 0 1px #ddd"
      },
      check: {
        color: "#333"
      }
    },
    "transparent": {
      check: {
        color: "#333"
      }
    }
  }, {
    first: first2,
    last: last2,
    active,
    "color-#FFFFFF": color3 === "#FFFFFF",
    "transparent": color3 === "transparent"
  });
  return Cn.createElement(
    Swatch_default,
    {
      color: color3,
      style: styles2.color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: "0 0 4px " + color3 }
    },
    Cn.createElement(
      "div",
      { style: styles2.check },
      Cn.createElement(import_CheckIcon.default, null)
    )
  );
};
var SwatchesColor_default = SwatchesColor;

// node_modules/react-color/es/components/swatches/SwatchesGroup.js
var SwatchesGroup = function SwatchesGroup2(_ref) {
  var onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, group2 = _ref.group, active = _ref.active;
  var styles2 = (0, import_reactcss40.default)({
    "default": {
      group: {
        paddingBottom: "10px",
        width: "40px",
        float: "left",
        marginRight: "10px"
      }
    }
  });
  return Cn.createElement(
    "div",
    { style: styles2.group },
    map_default(group2, function(color3, i6) {
      return Cn.createElement(SwatchesColor_default, {
        key: color3,
        color: color3,
        active: color3.toLowerCase() === active,
        first: i6 === 0,
        last: i6 === group2.length - 1,
        onClick,
        onSwatchHover
      });
    })
  );
};
var SwatchesGroup_default = SwatchesGroup;

// node_modules/react-color/es/components/swatches/Swatches.js
var Swatches = function Swatches2(_ref) {
  var width = _ref.width, height = _ref.height, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors2 = _ref.colors, hex2 = _ref.hex, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = (0, import_reactcss41.default)(merge_default({
    "default": {
      picker: {
        width,
        height
      },
      overflow: {
        height,
        overflowY: "scroll"
      },
      body: {
        padding: "16px 0 6px 16px"
      },
      clear: {
        clear: "both"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e9) {
    return onChange({ hex: data, source: "hex" }, e9);
  };
  return Cn.createElement(
    "div",
    { style: styles2.picker, className: "swatches-picker " + className },
    Cn.createElement(
      Raised_default,
      null,
      Cn.createElement(
        "div",
        { style: styles2.overflow },
        Cn.createElement(
          "div",
          { style: styles2.body },
          map_default(colors2, function(group2) {
            return Cn.createElement(SwatchesGroup_default, {
              key: group2.toString(),
              group: group2,
              active: hex2,
              onClick: handleChange,
              onSwatchHover
            });
          }),
          Cn.createElement("div", { style: styles2.clear })
        )
      )
    )
  );
};
Swatches.propTypes = {
  width: import_prop_types12.default.oneOfType([import_prop_types12.default.string, import_prop_types12.default.number]),
  height: import_prop_types12.default.oneOfType([import_prop_types12.default.string, import_prop_types12.default.number]),
  colors: import_prop_types12.default.arrayOf(import_prop_types12.default.arrayOf(import_prop_types12.default.string)),
  styles: import_prop_types12.default.object
  /* eslint-disable max-len */
};
Swatches.defaultProps = {
  width: 320,
  height: 240,
  colors: [[red["900"], red["700"], red["500"], red["300"], red["100"]], [pink["900"], pink["700"], pink["500"], pink["300"], pink["100"]], [purple["900"], purple["700"], purple["500"], purple["300"], purple["100"]], [deepPurple["900"], deepPurple["700"], deepPurple["500"], deepPurple["300"], deepPurple["100"]], [indigo["900"], indigo["700"], indigo["500"], indigo["300"], indigo["100"]], [blue["900"], blue["700"], blue["500"], blue["300"], blue["100"]], [lightBlue["900"], lightBlue["700"], lightBlue["500"], lightBlue["300"], lightBlue["100"]], [cyan["900"], cyan["700"], cyan["500"], cyan["300"], cyan["100"]], [teal["900"], teal["700"], teal["500"], teal["300"], teal["100"]], ["#194D33", green["700"], green["500"], green["300"], green["100"]], [lightGreen["900"], lightGreen["700"], lightGreen["500"], lightGreen["300"], lightGreen["100"]], [lime["900"], lime["700"], lime["500"], lime["300"], lime["100"]], [yellow["900"], yellow["700"], yellow["500"], yellow["300"], yellow["100"]], [amber["900"], amber["700"], amber["500"], amber["300"], amber["100"]], [orange["900"], orange["700"], orange["500"], orange["300"], orange["100"]], [deepOrange["900"], deepOrange["700"], deepOrange["500"], deepOrange["300"], deepOrange["100"]], [brown["900"], brown["700"], brown["500"], brown["300"], brown["100"]], [blueGrey["900"], blueGrey["700"], blueGrey["500"], blueGrey["300"], blueGrey["100"]], ["#000000", "#525252", "#969696", "#D9D9D9", "#FFFFFF"]],
  styles: {}
};
var Swatches_default = ColorWrap_default(Swatches);

// node_modules/react-color/es/components/twitter/Twitter.js
init_react();
var import_prop_types13 = __toESM(require_prop_types());
var import_reactcss42 = __toESM(require_lib());
var Twitter = function Twitter2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex2 = _ref.hex, colors2 = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = (0, import_reactcss42.default)(merge_default({
    "default": {
      card: {
        width,
        background: "#fff",
        border: "0 solid rgba(0,0,0,0.25)",
        boxShadow: "0 1px 4px rgba(0,0,0,0.25)",
        borderRadius: "4px",
        position: "relative"
      },
      body: {
        padding: "15px 9px 9px 15px"
      },
      label: {
        fontSize: "18px",
        color: "#fff"
      },
      triangle: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 9px 10px 9px",
        borderColor: "transparent transparent #fff transparent",
        position: "absolute"
      },
      triangleShadow: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 9px 10px 9px",
        borderColor: "transparent transparent rgba(0,0,0,.1) transparent",
        position: "absolute"
      },
      hash: {
        background: "#F0F0F0",
        height: "30px",
        width: "30px",
        borderRadius: "4px 0 0 4px",
        float: "left",
        color: "#98A1A4",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      },
      input: {
        width: "100px",
        fontSize: "14px",
        color: "#666",
        border: "0px",
        outline: "none",
        height: "28px",
        boxShadow: "inset 0 0 0 1px #F0F0F0",
        boxSizing: "content-box",
        borderRadius: "0 4px 4px 0",
        float: "left",
        paddingLeft: "8px"
      },
      swatch: {
        width: "30px",
        height: "30px",
        float: "left",
        borderRadius: "4px",
        margin: "0 6px 6px 0"
      },
      clear: {
        clear: "both"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      },
      triangleShadow: {
        display: "none"
      }
    },
    "top-left-triangle": {
      triangle: {
        top: "-10px",
        left: "12px"
      },
      triangleShadow: {
        top: "-11px",
        left: "12px"
      }
    },
    "top-right-triangle": {
      triangle: {
        top: "-10px",
        right: "12px"
      },
      triangleShadow: {
        top: "-11px",
        right: "12px"
      }
    }
  }, passedStyles), {
    "hide-triangle": triangle === "hide",
    "top-left-triangle": triangle === "top-left",
    "top-right-triangle": triangle === "top-right"
  });
  var handleChange = function handleChange2(hexcode, e9) {
    isValidHex(hexcode) && onChange({
      hex: hexcode,
      source: "hex"
    }, e9);
  };
  return Cn.createElement(
    "div",
    { style: styles2.card, className: "twitter-picker " + className },
    Cn.createElement("div", { style: styles2.triangleShadow }),
    Cn.createElement("div", { style: styles2.triangle }),
    Cn.createElement(
      "div",
      { style: styles2.body },
      map_default(colors2, function(c9, i6) {
        return Cn.createElement(Swatch_default, {
          key: i6,
          color: c9,
          hex: c9,
          style: styles2.swatch,
          onClick: handleChange,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: "0 0 4px " + c9
          }
        });
      }),
      Cn.createElement(
        "div",
        { style: styles2.hash },
        "#"
      ),
      Cn.createElement(EditableInput_default, {
        label: null,
        style: { input: styles2.input },
        value: hex2.replace("#", ""),
        onChange: handleChange
      }),
      Cn.createElement("div", { style: styles2.clear })
    )
  );
};
Twitter.propTypes = {
  width: import_prop_types13.default.oneOfType([import_prop_types13.default.string, import_prop_types13.default.number]),
  triangle: import_prop_types13.default.oneOf(["hide", "top-left", "top-right"]),
  colors: import_prop_types13.default.arrayOf(import_prop_types13.default.string),
  styles: import_prop_types13.default.object
};
Twitter.defaultProps = {
  width: 276,
  colors: ["#FF6900", "#FCB900", "#7BDCB5", "#00D084", "#8ED1FC", "#0693E3", "#ABB8C3", "#EB144C", "#F78DA7", "#9900EF"],
  triangle: "top-left",
  styles: {}
};
var Twitter_default = ColorWrap_default(Twitter);

// node_modules/react-color/es/components/google/Google.js
init_react();
var import_prop_types16 = __toESM(require_prop_types());
var import_reactcss46 = __toESM(require_lib());

// node_modules/react-color/es/components/google/GooglePointerCircle.js
init_react();
var import_reactcss43 = __toESM(require_lib());
var import_prop_types14 = __toESM(require_prop_types());
var GooglePointerCircle = function GooglePointerCircle2(props) {
  var styles2 = (0, import_reactcss43.default)({
    "default": {
      picker: {
        width: "20px",
        height: "20px",
        borderRadius: "22px",
        border: "2px #fff solid",
        transform: "translate(-12px, -13px)",
        background: "hsl(" + Math.round(props.hsl.h) + ", " + Math.round(props.hsl.s * 100) + "%, " + Math.round(props.hsl.l * 100) + "%)"
      }
    }
  });
  return Cn.createElement("div", { style: styles2.picker });
};
GooglePointerCircle.propTypes = {
  hsl: import_prop_types14.default.shape({
    h: import_prop_types14.default.number,
    s: import_prop_types14.default.number,
    l: import_prop_types14.default.number,
    a: import_prop_types14.default.number
  })
};
GooglePointerCircle.defaultProps = {
  hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
};
var GooglePointerCircle_default = GooglePointerCircle;

// node_modules/react-color/es/components/google/GooglePointer.js
init_react();
var import_reactcss44 = __toESM(require_lib());
var import_prop_types15 = __toESM(require_prop_types());
var GooglePointer = function GooglePointer2(props) {
  var styles2 = (0, import_reactcss44.default)({
    "default": {
      picker: {
        width: "20px",
        height: "20px",
        borderRadius: "22px",
        transform: "translate(-10px, -7px)",
        background: "hsl(" + Math.round(props.hsl.h) + ", 100%, 50%)",
        border: "2px white solid"
      }
    }
  });
  return Cn.createElement("div", { style: styles2.picker });
};
GooglePointer.propTypes = {
  hsl: import_prop_types15.default.shape({
    h: import_prop_types15.default.number,
    s: import_prop_types15.default.number,
    l: import_prop_types15.default.number,
    a: import_prop_types15.default.number
  })
};
GooglePointer.defaultProps = {
  hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
};
var GooglePointer_default = GooglePointer;

// node_modules/react-color/es/components/google/GoogleFields.js
init_react();
var import_reactcss45 = __toESM(require_lib());
var GoogleFields = function GoogleFields2(_ref) {
  var onChange = _ref.onChange, rgb2 = _ref.rgb, hsl3 = _ref.hsl, hex2 = _ref.hex, hsv = _ref.hsv;
  var handleChange = function handleChange2(data, e9) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e9);
    } else if (data.rgb) {
      var values2 = data.rgb.split(",");
      isvalidColorString(data.rgb, "rgb") && onChange({
        r: values2[0],
        g: values2[1],
        b: values2[2],
        a: 1,
        source: "rgb"
      }, e9);
    } else if (data.hsv) {
      var _values = data.hsv.split(",");
      if (isvalidColorString(data.hsv, "hsv")) {
        _values[2] = _values[2].replace("%", "");
        _values[1] = _values[1].replace("%", "");
        _values[0] = _values[0].replace("\xB0", "");
        if (_values[1] == 1) {
          _values[1] = 0.01;
        } else if (_values[2] == 1) {
          _values[2] = 0.01;
        }
        onChange({
          h: Number(_values[0]),
          s: Number(_values[1]),
          v: Number(_values[2]),
          source: "hsv"
        }, e9);
      }
    } else if (data.hsl) {
      var _values2 = data.hsl.split(",");
      if (isvalidColorString(data.hsl, "hsl")) {
        _values2[2] = _values2[2].replace("%", "");
        _values2[1] = _values2[1].replace("%", "");
        _values2[0] = _values2[0].replace("\xB0", "");
        if (hsvValue[1] == 1) {
          hsvValue[1] = 0.01;
        } else if (hsvValue[2] == 1) {
          hsvValue[2] = 0.01;
        }
        onChange({
          h: Number(_values2[0]),
          s: Number(_values2[1]),
          v: Number(_values2[2]),
          source: "hsl"
        }, e9);
      }
    }
  };
  var styles2 = (0, import_reactcss45.default)({
    "default": {
      wrap: {
        display: "flex",
        height: "100px",
        marginTop: "4px"
      },
      fields: {
        width: "100%"
      },
      column: {
        paddingTop: "10px",
        display: "flex",
        justifyContent: "space-between"
      },
      double: {
        padding: "0px 4.4px",
        boxSizing: "border-box"
      },
      input: {
        width: "100%",
        height: "38px",
        boxSizing: "border-box",
        padding: "4px 10% 3px",
        textAlign: "center",
        border: "1px solid #dadce0",
        fontSize: "11px",
        textTransform: "lowercase",
        borderRadius: "5px",
        outline: "none",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      input2: {
        height: "38px",
        width: "100%",
        border: "1px solid #dadce0",
        boxSizing: "border-box",
        fontSize: "11px",
        textTransform: "lowercase",
        borderRadius: "5px",
        outline: "none",
        paddingLeft: "10px",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      label: {
        textAlign: "center",
        fontSize: "12px",
        background: "#fff",
        position: "absolute",
        textTransform: "uppercase",
        color: "#3c4043",
        width: "35px",
        top: "-6px",
        left: "0",
        right: "0",
        marginLeft: "auto",
        marginRight: "auto",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      label2: {
        left: "10px",
        textAlign: "center",
        fontSize: "12px",
        background: "#fff",
        position: "absolute",
        textTransform: "uppercase",
        color: "#3c4043",
        width: "32px",
        top: "-6px",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      single: {
        flexGrow: "1",
        margin: "0px 4.4px"
      }
    }
  });
  var rgbValue = rgb2.r + ", " + rgb2.g + ", " + rgb2.b;
  var hslValue = Math.round(hsl3.h) + "\xB0, " + Math.round(hsl3.s * 100) + "%, " + Math.round(hsl3.l * 100) + "%";
  var hsvValue = Math.round(hsv.h) + "\xB0, " + Math.round(hsv.s * 100) + "%, " + Math.round(hsv.v * 100) + "%";
  return Cn.createElement(
    "div",
    { style: styles2.wrap, className: "flexbox-fix" },
    Cn.createElement(
      "div",
      { style: styles2.fields },
      Cn.createElement(
        "div",
        { style: styles2.double },
        Cn.createElement(EditableInput_default, {
          style: { input: styles2.input, label: styles2.label },
          label: "hex",
          value: hex2,
          onChange: handleChange
        })
      ),
      Cn.createElement(
        "div",
        { style: styles2.column },
        Cn.createElement(
          "div",
          { style: styles2.single },
          Cn.createElement(EditableInput_default, {
            style: { input: styles2.input2, label: styles2.label2 },
            label: "rgb",
            value: rgbValue,
            onChange: handleChange
          })
        ),
        Cn.createElement(
          "div",
          { style: styles2.single },
          Cn.createElement(EditableInput_default, {
            style: { input: styles2.input2, label: styles2.label2 },
            label: "hsv",
            value: hsvValue,
            onChange: handleChange
          })
        ),
        Cn.createElement(
          "div",
          { style: styles2.single },
          Cn.createElement(EditableInput_default, {
            style: { input: styles2.input2, label: styles2.label2 },
            label: "hsl",
            value: hslValue,
            onChange: handleChange
          })
        )
      )
    )
  );
};
var GoogleFields_default = GoogleFields;

// node_modules/react-color/es/components/google/Google.js
var Google = function Google2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, rgb2 = _ref.rgb, hsl3 = _ref.hsl, hsv = _ref.hsv, hex2 = _ref.hex, header = _ref.header, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles2 = (0, import_reactcss46.default)(merge_default({
    "default": {
      picker: {
        width,
        background: "#fff",
        border: "1px solid #dfe1e5",
        boxSizing: "initial",
        display: "flex",
        flexWrap: "wrap",
        borderRadius: "8px 8px 0px 0px"
      },
      head: {
        height: "57px",
        width: "100%",
        paddingTop: "16px",
        paddingBottom: "16px",
        paddingLeft: "16px",
        fontSize: "20px",
        boxSizing: "border-box",
        fontFamily: "Roboto-Regular,HelveticaNeue,Arial,sans-serif"
      },
      saturation: {
        width: "70%",
        padding: "0px",
        position: "relative",
        overflow: "hidden"
      },
      swatch: {
        width: "30%",
        height: "228px",
        padding: "0px",
        background: "rgba(" + rgb2.r + ", " + rgb2.g + ", " + rgb2.b + ", 1)",
        position: "relative",
        overflow: "hidden"
      },
      body: {
        margin: "auto",
        width: "95%"
      },
      controls: {
        display: "flex",
        boxSizing: "border-box",
        height: "52px",
        paddingTop: "22px"
      },
      color: {
        width: "32px"
      },
      hue: {
        height: "8px",
        position: "relative",
        margin: "0px 16px 0px 16px",
        width: "100%"
      },
      Hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  return Cn.createElement(
    "div",
    { style: styles2.picker, className: "google-picker " + className },
    Cn.createElement(
      "div",
      { style: styles2.head },
      header
    ),
    Cn.createElement("div", { style: styles2.swatch }),
    Cn.createElement(
      "div",
      { style: styles2.saturation },
      Cn.createElement(Saturation_default, {
        hsl: hsl3,
        hsv,
        pointer: GooglePointerCircle_default,
        onChange
      })
    ),
    Cn.createElement(
      "div",
      { style: styles2.body },
      Cn.createElement(
        "div",
        { style: styles2.controls, className: "flexbox-fix" },
        Cn.createElement(
          "div",
          { style: styles2.hue },
          Cn.createElement(Hue_default, {
            style: styles2.Hue,
            hsl: hsl3,
            radius: "4px",
            pointer: GooglePointer_default,
            onChange
          })
        )
      ),
      Cn.createElement(GoogleFields_default, {
        rgb: rgb2,
        hsl: hsl3,
        hex: hex2,
        hsv,
        onChange
      })
    )
  );
};
Google.propTypes = {
  width: import_prop_types16.default.oneOfType([import_prop_types16.default.string, import_prop_types16.default.number]),
  styles: import_prop_types16.default.object,
  header: import_prop_types16.default.string
};
Google.defaultProps = {
  width: 652,
  styles: {},
  header: "Color picker"
};
var Google_default = ColorWrap_default(Google);

// node_modules/preact/compat/client.mjs
init_compat_module();
function createRoot(container) {
  return {
    render(children2) {
      G2(children2, container);
    },
    unmount() {
      hn(container);
    }
  };
}

// src/make_value_change_emitter.ts
var DATA_PASSING_EVENT_ID = "shiny-data-passing-event";
function isDataPassingPayload(x6) {
  if (typeof x6 !== "object") {
    return false;
  }
  if (x6 === null) {
    return false;
  }
  const hasTypeField = "type" in x6 && typeof x6.type === "string";
  const hasValueField = "value" in x6;
  if (!hasTypeField || !hasValueField)
    return false;
  switch (x6.type) {
    case "string":
      return typeof x6.value === "string";
    case "number":
      return typeof x6.value === "number";
    case "boolean":
      return typeof x6.value === "boolean";
    case "string[]":
      return Array.isArray(x6.value) && x6.value.every((x7) => typeof x7 === "string");
    default:
      return true;
  }
}
function makeDataPassingPayload(id2, msg) {
  return { ...msg, id: id2 };
}
function getDataPassingEventValue(evt, id2) {
  if (!(evt instanceof CustomEvent)) {
    return null;
  }
  if (evt.type !== DATA_PASSING_EVENT_ID) {
    return null;
  }
  const payload = evt.detail;
  if (typeof payload !== "object") {
    return null;
  }
  if (typeof payload.id !== "string" || payload.id !== id2) {
    return null;
  }
  if (!isDataPassingPayload(payload)) {
    return null;
  }
  return payload;
}
function makeValueChangeEmitter(el, id2) {
  return (payload) => {
    const event = new CustomEvent(DATA_PASSING_EVENT_ID, {
      detail: makeDataPassingPayload(id2, payload),
      bubbles: true
    });
    el.dispatchEvent(event);
  };
}
var dummyDataPassingWatcher = {
  unsubscribe: () => {
  }
};
function makeDataPassingWatcher(watchId, callback) {
  const onEvent = (e9) => {
    const payload = getDataPassingEventValue(e9, watchId);
    if (payload === null) {
      return;
    }
    const value = payload.value;
    if (value === null || value === void 0) {
      return;
    }
    callback(payload);
  };
  window.addEventListener(DATA_PASSING_EVENT_ID, onEvent);
  return {
    unsubscribe: () => {
      window.removeEventListener(DATA_PASSING_EVENT_ID, onEvent);
    }
  };
}

// src/shiny/OptionalShiny.ts
var Shiny = window.Shiny;

// src/shiny/make-input-binding.ts
function makeInputBinding(tagName, { type: type3 = null } = {}) {
  if (!Shiny) {
    return;
  }
  class NewCustomBinding extends Shiny["InputBinding"] {
    constructor() {
      super();
    }
    find(scope) {
      return $(scope).find(tagName);
    }
    getValue(el) {
      if ("getValue" in el) {
        return el.getValue();
      } else {
        return el.value;
      }
    }
    getType(el) {
      return type3;
    }
    subscribe(el, callback) {
      el.onChangeCallback = callback;
    }
    unsubscribe(el) {
      el.onChangeCallback = (x6) => {
      };
    }
  }
  Shiny.inputBindings.register(new NewCustomBinding(), `${tagName}-Binding`);
}

// src/color-picker.tsx
function ColorPickerReact({
  currentColorCallback
}) {
  const [currentColor, setCurrentColor] = Cn.useState("#fff");
  function handleChange(color3) {
    setCurrentColor(color3.hex);
    currentColorCallback(color3.hex);
  }
  return /* @__PURE__ */ Cn.createElement(Sketch_default, { color: currentColor, onChange: handleChange });
}
var ColorPicker = class extends HTMLElement {
  constructor() {
    super();
    this.onValueChange = makeValueChangeEmitter(this, this.id);
    this.value = "#ffffff";
    this.onChangeCallback = (x6) => {
    };
  }
  currentColorCallback(x6) {
    this.value = x6;
    this.notifyChange();
  }
  notifyChange() {
    this.onChangeCallback(true);
    this.onValueChange({ type: "string", value: this.value });
  }
  connectedCallback() {
    const shadowRoot = this.attachShadow({ mode: "open" });
    const root3 = createRoot(shadowRoot);
    setTimeout(() => {
      this.notifyChange();
    }, 0);
    root3.render(
      /* @__PURE__ */ Cn.createElement(
        ColorPickerReact,
        {
          currentColorCallback: (x6) => this.currentColorCallback(x6)
        }
      )
    );
  }
};
customElements.define("color-picker", ColorPicker);
makeInputBinding("color-picker");

// src/design-preview.ts
var colors = [
  "primary",
  "action",
  "error",
  "bg",
  "bg-1",
  "bg-2",
  "border",
  "border-1",
  "border-2",
  "text",
  "text-1",
  "text-2"
].map((c9) => `--color-${c9}`);
var fontSizes = [
  "heading-1",
  "heading-2",
  "heading-3",
  "heading-4",
  "body",
  "small",
  "x-small"
].map((s8) => `--font-${s8}`);
var sml = ["small", "medium", "large"];
var shadows = sml.map((x6) => `--shadow-${x6}`);
var borders = sml.map((x6) => `--border-${x6}`);
var radii = sml.map((x6) => `--radius-${x6}`);
var spacings = ["x-small", ...sml, "x-large", "xx-large"].map(
  (s8) => `--space-${s8}`
);
var DesignPreview = class extends s4 {
  static {
    this.properties = {};
  }
  static {
    // Styles are scoped to this element: they won't conflict with styles
    // on the main page or in other components. Styling API can be exposed
    // via CSS custom properties.
    this.styles = i`
    :host {
      display: block;
      height: 100%;
      overflow: auto;
      position: relative;
      padding: var(--space-medium);
      color: var(--color-text);
    }

    :host > div {
      padding: var(--space-medium);
      position: relative;
      margin-block: var(--space-medium);
      outline: var(--border-small) solid var(--color-border);
      border-radius: var(--radius-small);
      box-shadow: var(--shadow-small);
    }

    .box-container {
      width: 100%;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      grid-gap: var(--space-medium);
    }

    .box {
      min-width: 0;
      max-width: 100%;
      aspect-ratio: 1;
      display: grid;
      align-items: end;
      border: 0 solid var(--color-border);
      box-shadow: var(--shadow-medium);
      border-radius: var(--radius-small);
      background-color: var(--color-bg-2);
      overflow: hidden;
    }

    .label {
      font-size: var(--font-x-small);
      font-family: var(--font-mono);
    }

    .box > div.label {
      background-color: var(--color-bg-1);
      padding-inline: var(--space-medium);
    }

    .font-sizes-container > p {
      padding: 0;
      margin: 0;
      line-height: var(--font-lineheight-5);
    }

    .spacings {
      display: flex;
      align-items: center;
      padding: var(--space-small);
      gap: var(--space-small);
    }
  `;
  }
  render() {
    return x`
      <div>
        <h2>Colors</h2>
        <div class="box-container">
          ${colors.map(
      (c9) => x`<div class="box" style="background-color: var(${c9})">
              <div class="label">${c9}</div>
            </div>`
    )}
        </div>
      </div>

      <div>
        <h2>Font Sizes</h2>
        <div class="font-sizes-container">
          ${fontSizes.map(
      (size) => x`<p class="font-size" style="font-size: var(${size})">
              ${size}
            </p>`
    )}
        </div>
      </div>

      <div>
        <h2>Border Widths</h2>
        <div class="box-container">
          ${borders.map(
      (border) => x`<div
              class="box"
              style="border-width: var(${border});"
            >
              <div class="label">${border}</div>
            </div>`
    )}
        </div>
      </div>

      <div>
        <h2>Radii</h2>
        <div class="box-container">
          ${radii.map(
      (r6) => x`<div class="box" style="border-radius: var(${r6});">
              <div class="label">${r6}</div>
            </div>`
    )}
        </div>
      </div>

      <div>
        <h2>Spacings</h2>
        <div>
          ${spacings.map(
      (s8) => x`
              <div class="spacings">
                <div
                  style="width: var(${s8}); aspect-ratio: 1; background-color: var(--color-primary);"
                ></div>
                <div class="label">${s8}</div>
              </div>
            `
    )}
        </div>
      </div>
      <div>
        <h2>Box Shadows</h2>
        <div class="box-container">
          ${shadows.map(
      (shadow) => x`<div
              class="box"
              style="box-shadow: var(${shadow});"
            >
              <div class="label">${shadow}</div>
            </div>`
    )}
        </div>
      </div>
    `;
  }
};
customElements.define("design-preview", DesignPreview);

// node_modules/@lit/reactive-element/decorators/custom-element.js
var e6 = (e9) => (n9) => "function" == typeof n9 ? ((e11, n10) => (customElements.define(e11, n10), n10))(e9, n9) : ((e11, n10) => {
  const { kind: t6, elements: s8 } = n10;
  return { kind: t6, elements: s8, finisher(n11) {
    customElements.define(e11, n11);
  } };
})(e9, n9);

// node_modules/@lit/reactive-element/decorators/property.js
var i5 = (i6, e9) => "method" === e9.kind && e9.descriptor && !("value" in e9.descriptor) ? { ...e9, finisher(n9) {
  n9.createProperty(e9.key, i6);
} } : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: e9.key, initializer() {
  "function" == typeof e9.initializer && (this[e9.key] = e9.initializer.call(this));
}, finisher(n9) {
  n9.createProperty(e9.key, i6);
} };
var e7 = (i6, e9, n9) => {
  e9.constructor.createProperty(n9, i6);
};
function n6(n9) {
  return (t6, o8) => void 0 !== o8 ? e7(n9, t6, o8) : i5(n9, t6);
}

// node_modules/@lit/reactive-element/decorators/state.js
function t5(t6) {
  return n6({ ...t6, state: true });
}

// node_modules/@lit/reactive-element/decorators/query-assigned-elements.js
var n7;
var e8 = null != (null === (n7 = window.HTMLSlotElement) || void 0 === n7 ? void 0 : n7.prototype.assignedElements) ? (o8, n9) => o8.assignedElements(n9) : (o8, n9) => o8.assignedNodes(n9).filter((o9) => o9.nodeType === Node.ELEMENT_NODE);

// src/set_el_attr.ts
function setElAttr(el, type3, value) {
  const attr = document.createAttribute(type3);
  attr.value = value;
  if (!el.attributes.getNamedItem(type3)) {
    el.attributes.setNamedItem(attr);
  }
  return el;
}

// src/footer.ts
var DashboardFooter = class extends s4 {
  constructor() {
    super();
    setElAttr(this, "slot", "footer");
  }
  render() {
    return x`
      <div class="footer">
        <slot></slot>
      </div>
    `;
  }
};
DashboardFooter.properties = {};
// Styles are scoped to this element: they won't conflict with styles
// on the main page or in other components. Styling API can be exposed
// via CSS custom properties.
DashboardFooter.styles = i`
    :host {
      display: block;
      position: relative;
      width: 100%;
    }

    .footer {
      width: 100%;
      display: flex;
      justify-content: space-between;
    }
  `;
DashboardFooter = __decorateClass([
  e6("shiny-dashboard-footer")
], DashboardFooter);

// src/general-output.ts
var GeneralOutput = class extends s4 {
  constructor() {
    super(...arguments);
    this.value = null;
    this.watch = "";
    this.watcher = dummyDataPassingWatcher;
  }
  static {
    this.properties = {
      value: {},
      watch: { type: String }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.watcher = makeDataPassingWatcher(this.watch, (payload) => {
      this.value = String(payload.value);
    });
  }
  render() {
    return x`<span class="value">${this.value}</span>`;
  }
};
customElements.define("general-output", GeneralOutput);

// src/grid.ts
var Grid = class extends s4 {
  constructor() {
    super(...arguments);
    this.nRows = 1;
    this.nCols = 2;
    this.alignItems = "stretch";
  }
  connectedCallback() {
    super.connectedCallback();
    this.style.setProperty("--nRows", this.nRows.toString());
    this.style.setProperty("--nCols", this.nCols.toString());
    this.style.setProperty("--align-items", this.alignItems);
  }
  render() {
    return x`<slot></slot>`;
  }
};
// Styles are scoped to this element: they won't conflict with styles
// on the main page or in other components. Styling API can be exposed
// via CSS custom properties.
Grid.styles = i`
    :host {
      display: grid;
      grid-template-columns: repeat(var(--nCols), 1fr);
      grid-template-rows: repeat(var(--nRows), 1fr);
      gap: var(--grid-gap, var(--size-m));
      align-items: var(--align-items);
      height: 100%;
    }

    * {
      box-sizing: border-box;
    }

    ::slotted(*) {
      min-height: 0;
      min-width: 0;
    }
  `;
__decorateClass([
  n6({ type: Number })
], Grid.prototype, "nRows", 2);
__decorateClass([
  n6({ type: Number })
], Grid.prototype, "nCols", 2);
__decorateClass([
  n6({ type: String })
], Grid.prototype, "alignItems", 2);
Grid = __decorateClass([
  e6("shiny-grid")
], Grid);

// src/grid-item.ts
var GridItem = class extends s4 {
  constructor() {
    super(...arguments);
    this.width = 1;
    this.height = 1;
    this.cardStyled = true;
  }
  static {
    this.styles = i`
    :host {
      display: flex;
      flex-direction: column;
    }
  `;
  }
  connectedCallback() {
    super.connectedCallback();
    this.style.setProperty(
      "grid-area",
      `span ${this.height} / span ${this.width}`
    );
  }
  render() {
    const children2 = x`<slot></slot>`;
    return this.cardStyled ? x`<shiny-card>${children2}</shiny-card>` : children2;
  }
};
__decorateClass([
  n6({ type: Number })
], GridItem.prototype, "width", 2);
__decorateClass([
  n6({ type: Number })
], GridItem.prototype, "height", 2);
__decorateClass([
  n6({ type: Boolean })
], GridItem.prototype, "cardStyled", 2);
customElements.define("shiny-grid-item", GridItem);

// node_modules/iconify-icon/dist/iconify-icon.mjs
var defaultIconDimensions = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
var defaultIconTransformations = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
var defaultIconProps = Object.freeze({
  ...defaultIconDimensions,
  ...defaultIconTransformations
});
var defaultExtendedIconProps = Object.freeze({
  ...defaultIconProps,
  body: "",
  hidden: false
});
var defaultIconSizeCustomisations = Object.freeze({
  width: null,
  height: null
});
var defaultIconCustomisations = Object.freeze({
  // Dimensions
  ...defaultIconSizeCustomisations,
  // Transformations
  ...defaultIconTransformations
});
function rotateFromString(value, defaultValue = 0) {
  const units = value.replace(/^-?[0-9.]*/, "");
  function cleanup(value2) {
    while (value2 < 0) {
      value2 += 4;
    }
    return value2 % 4;
  }
  if (units === "") {
    const num = parseInt(value);
    return isNaN(num) ? 0 : cleanup(num);
  } else if (units !== value) {
    let split = 0;
    switch (units) {
      case "%":
        split = 25;
        break;
      case "deg":
        split = 90;
    }
    if (split) {
      let num = parseFloat(value.slice(0, value.length - units.length));
      if (isNaN(num)) {
        return 0;
      }
      num = num / split;
      return num % 1 === 0 ? cleanup(num) : 0;
    }
  }
  return defaultValue;
}
var separator = /[\s,]+/;
function flipFromString(custom8, flip3) {
  flip3.split(separator).forEach((str) => {
    const value = str.trim();
    switch (value) {
      case "horizontal":
        custom8.hFlip = true;
        break;
      case "vertical":
        custom8.vFlip = true;
        break;
    }
  });
}
var defaultCustomisations = {
  ...defaultIconCustomisations,
  preserveAspectRatio: ""
};
function getCustomisations(node) {
  const customisations = {
    ...defaultCustomisations
  };
  const attr = (key, def) => node.getAttribute(key) || def;
  customisations.width = attr("width", null);
  customisations.height = attr("height", null);
  customisations.rotate = rotateFromString(attr("rotate", ""));
  flipFromString(customisations, attr("flip", ""));
  customisations.preserveAspectRatio = attr("preserveAspectRatio", attr("preserveaspectratio", ""));
  return customisations;
}
function haveCustomisationsChanged(value1, value2) {
  for (const key in defaultCustomisations) {
    if (value1[key] !== value2[key]) {
      return true;
    }
  }
  return false;
}
var matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;
var stringToIcon = (value, validate, allowSimpleName, provider = "") => {
  const colonSeparated = value.split(":");
  if (value.slice(0, 1) === "@") {
    if (colonSeparated.length < 2 || colonSeparated.length > 3) {
      return null;
    }
    provider = colonSeparated.shift().slice(1);
  }
  if (colonSeparated.length > 3 || !colonSeparated.length) {
    return null;
  }
  if (colonSeparated.length > 1) {
    const name2 = colonSeparated.pop();
    const prefix = colonSeparated.pop();
    const result = {
      // Allow provider without '@': "provider:prefix:name"
      provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
      prefix,
      name: name2
    };
    return validate && !validateIconName(result) ? null : result;
  }
  const name = colonSeparated[0];
  const dashSeparated = name.split("-");
  if (dashSeparated.length > 1) {
    const result = {
      provider,
      prefix: dashSeparated.shift(),
      name: dashSeparated.join("-")
    };
    return validate && !validateIconName(result) ? null : result;
  }
  if (allowSimpleName && provider === "") {
    const result = {
      provider,
      prefix: "",
      name
    };
    return validate && !validateIconName(result, allowSimpleName) ? null : result;
  }
  return null;
};
var validateIconName = (icon, allowSimpleName) => {
  if (!icon) {
    return false;
  }
  return !!((icon.provider === "" || icon.provider.match(matchIconName)) && (allowSimpleName && icon.prefix === "" || icon.prefix.match(matchIconName)) && icon.name.match(matchIconName));
};
function mergeIconTransformations(obj1, obj2) {
  const result = {};
  if (!obj1.hFlip !== !obj2.hFlip) {
    result.hFlip = true;
  }
  if (!obj1.vFlip !== !obj2.vFlip) {
    result.vFlip = true;
  }
  const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
  if (rotate) {
    result.rotate = rotate;
  }
  return result;
}
function mergeIconData(parent, child) {
  const result = mergeIconTransformations(parent, child);
  for (const key in defaultExtendedIconProps) {
    if (key in defaultIconTransformations) {
      if (key in parent && !(key in result)) {
        result[key] = defaultIconTransformations[key];
      }
    } else if (key in child) {
      result[key] = child[key];
    } else if (key in parent) {
      result[key] = parent[key];
    }
  }
  return result;
}
function getIconsTree(data, names2) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  const resolved = /* @__PURE__ */ Object.create(null);
  function resolve(name) {
    if (icons[name]) {
      return resolved[name] = [];
    }
    if (!(name in resolved)) {
      resolved[name] = null;
      const parent = aliases[name] && aliases[name].parent;
      const value = parent && resolve(parent);
      if (value) {
        resolved[name] = [parent].concat(value);
      }
    }
    return resolved[name];
  }
  (names2 || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);
  return resolved;
}
function internalGetIconData(data, name, tree) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  let currentProps = {};
  function parse3(name2) {
    currentProps = mergeIconData(
      icons[name2] || aliases[name2],
      currentProps
    );
  }
  parse3(name);
  tree.forEach(parse3);
  return mergeIconData(data, currentProps);
}
function parseIconSet(data, callback) {
  const names2 = [];
  if (typeof data !== "object" || typeof data.icons !== "object") {
    return names2;
  }
  if (data.not_found instanceof Array) {
    data.not_found.forEach((name) => {
      callback(name, null);
      names2.push(name);
    });
  }
  const tree = getIconsTree(data);
  for (const name in tree) {
    const item = tree[name];
    if (item) {
      callback(name, internalGetIconData(data, name, item));
      names2.push(name);
    }
  }
  return names2;
}
var optionalPropertyDefaults = {
  provider: "",
  aliases: {},
  not_found: {},
  ...defaultIconDimensions
};
function checkOptionalProps(item, defaults8) {
  for (const prop in defaults8) {
    if (prop in item && typeof item[prop] !== typeof defaults8[prop]) {
      return false;
    }
  }
  return true;
}
function quicklyValidateIconSet(obj) {
  if (typeof obj !== "object" || obj === null) {
    return null;
  }
  const data = obj;
  if (typeof data.prefix !== "string" || !obj.icons || typeof obj.icons !== "object") {
    return null;
  }
  if (!checkOptionalProps(obj, optionalPropertyDefaults)) {
    return null;
  }
  const icons = data.icons;
  for (const name in icons) {
    const icon = icons[name];
    if (!name.match(matchIconName) || typeof icon.body !== "string" || !checkOptionalProps(
      icon,
      defaultExtendedIconProps
    )) {
      return null;
    }
  }
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  for (const name in aliases) {
    const icon = aliases[name];
    const parent = icon.parent;
    if (!name.match(matchIconName) || typeof parent !== "string" || !icons[parent] && !aliases[parent] || !checkOptionalProps(
      icon,
      defaultExtendedIconProps
    )) {
      return null;
    }
  }
  return data;
}
var dataStorage = /* @__PURE__ */ Object.create(null);
function newStorage(provider, prefix) {
  return {
    provider,
    prefix,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function getStorage(provider, prefix) {
  const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));
  return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));
}
function addIconSet(storage2, data) {
  if (!quicklyValidateIconSet(data)) {
    return [];
  }
  return parseIconSet(data, (name, icon) => {
    if (icon) {
      storage2.icons[name] = icon;
    } else {
      storage2.missing.add(name);
    }
  });
}
function addIconToStorage(storage2, name, icon) {
  try {
    if (typeof icon.body === "string") {
      storage2.icons[name] = { ...icon };
      return true;
    }
  } catch (err) {
  }
  return false;
}
function listIcons$1(provider, prefix) {
  let allIcons = [];
  const providers = typeof provider === "string" ? [provider] : Object.keys(dataStorage);
  providers.forEach((provider2) => {
    const prefixes2 = typeof provider2 === "string" && typeof prefix === "string" ? [prefix] : Object.keys(dataStorage[provider2] || {});
    prefixes2.forEach((prefix2) => {
      const storage2 = getStorage(provider2, prefix2);
      allIcons = allIcons.concat(
        Object.keys(storage2.icons).map(
          (name) => (provider2 !== "" ? "@" + provider2 + ":" : "") + prefix2 + ":" + name
        )
      );
    });
  });
  return allIcons;
}
var simpleNames = false;
function allowSimpleNames(allow) {
  if (typeof allow === "boolean") {
    simpleNames = allow;
  }
  return simpleNames;
}
function getIconData(name) {
  const icon = typeof name === "string" ? stringToIcon(name, true, simpleNames) : name;
  if (icon) {
    const storage2 = getStorage(icon.provider, icon.prefix);
    const iconName = icon.name;
    return storage2.icons[iconName] || (storage2.missing.has(iconName) ? null : void 0);
  }
}
function addIcon$1(name, data) {
  const icon = stringToIcon(name, true, simpleNames);
  if (!icon) {
    return false;
  }
  const storage2 = getStorage(icon.provider, icon.prefix);
  return addIconToStorage(storage2, icon.name, data);
}
function addCollection$1(data, provider) {
  if (typeof data !== "object") {
    return false;
  }
  if (typeof provider !== "string") {
    provider = data.provider || "";
  }
  if (simpleNames && !provider && !data.prefix) {
    let added = false;
    if (quicklyValidateIconSet(data)) {
      data.prefix = "";
      parseIconSet(data, (name, icon) => {
        if (icon && addIcon$1(name, icon)) {
          added = true;
        }
      });
    }
    return added;
  }
  const prefix = data.prefix;
  if (!validateIconName({
    provider,
    prefix,
    name: "a"
  })) {
    return false;
  }
  const storage2 = getStorage(provider, prefix);
  return !!addIconSet(storage2, data);
}
function iconExists$1(name) {
  return !!getIconData(name);
}
function getIcon$1(name) {
  const result = getIconData(name);
  return result ? {
    ...defaultIconProps,
    ...result
  } : null;
}
function sortIcons(icons) {
  const result = {
    loaded: [],
    missing: [],
    pending: []
  };
  const storage2 = /* @__PURE__ */ Object.create(null);
  icons.sort((a7, b5) => {
    if (a7.provider !== b5.provider) {
      return a7.provider.localeCompare(b5.provider);
    }
    if (a7.prefix !== b5.prefix) {
      return a7.prefix.localeCompare(b5.prefix);
    }
    return a7.name.localeCompare(b5.name);
  });
  let lastIcon = {
    provider: "",
    prefix: "",
    name: ""
  };
  icons.forEach((icon) => {
    if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {
      return;
    }
    lastIcon = icon;
    const provider = icon.provider;
    const prefix = icon.prefix;
    const name = icon.name;
    const providerStorage = storage2[provider] || (storage2[provider] = /* @__PURE__ */ Object.create(null));
    const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));
    let list;
    if (name in localStorage.icons) {
      list = result.loaded;
    } else if (prefix === "" || localStorage.missing.has(name)) {
      list = result.missing;
    } else {
      list = result.pending;
    }
    const item = {
      provider,
      prefix,
      name
    };
    list.push(item);
  });
  return result;
}
function removeCallback(storages, id2) {
  storages.forEach((storage2) => {
    const items = storage2.loaderCallbacks;
    if (items) {
      storage2.loaderCallbacks = items.filter((row) => row.id !== id2);
    }
  });
}
function updateCallbacks(storage2) {
  if (!storage2.pendingCallbacksFlag) {
    storage2.pendingCallbacksFlag = true;
    setTimeout(() => {
      storage2.pendingCallbacksFlag = false;
      const items = storage2.loaderCallbacks ? storage2.loaderCallbacks.slice(0) : [];
      if (!items.length) {
        return;
      }
      let hasPending = false;
      const provider = storage2.provider;
      const prefix = storage2.prefix;
      items.forEach((item) => {
        const icons = item.icons;
        const oldLength = icons.pending.length;
        icons.pending = icons.pending.filter((icon) => {
          if (icon.prefix !== prefix) {
            return true;
          }
          const name = icon.name;
          if (storage2.icons[name]) {
            icons.loaded.push({
              provider,
              prefix,
              name
            });
          } else if (storage2.missing.has(name)) {
            icons.missing.push({
              provider,
              prefix,
              name
            });
          } else {
            hasPending = true;
            return true;
          }
          return false;
        });
        if (icons.pending.length !== oldLength) {
          if (!hasPending) {
            removeCallback([storage2], item.id);
          }
          item.callback(
            icons.loaded.slice(0),
            icons.missing.slice(0),
            icons.pending.slice(0),
            item.abort
          );
        }
      });
    });
  }
}
var idCounter2 = 0;
function storeCallback(callback, icons, pendingSources) {
  const id2 = idCounter2++;
  const abort = removeCallback.bind(null, pendingSources, id2);
  if (!icons.pending.length) {
    return abort;
  }
  const item = {
    id: id2,
    icons,
    callback,
    abort
  };
  pendingSources.forEach((storage2) => {
    (storage2.loaderCallbacks || (storage2.loaderCallbacks = [])).push(item);
  });
  return abort;
}
var storage = /* @__PURE__ */ Object.create(null);
function setAPIModule(provider, item) {
  storage[provider] = item;
}
function getAPIModule(provider) {
  return storage[provider] || storage[""];
}
function listToIcons(list, validate = true, simpleNames2 = false) {
  const result = [];
  list.forEach((item) => {
    const icon = typeof item === "string" ? stringToIcon(item, validate, simpleNames2) : item;
    if (icon) {
      result.push(icon);
    }
  });
  return result;
}
var defaultConfig = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};
function sendQuery(config, payload, query, done) {
  const resourcesCount = config.resources.length;
  const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;
  let resources;
  if (config.random) {
    let list = config.resources.slice(0);
    resources = [];
    while (list.length > 1) {
      const nextIndex = Math.floor(Math.random() * list.length);
      resources.push(list[nextIndex]);
      list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));
    }
    resources = resources.concat(list);
  } else {
    resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));
  }
  const startTime = Date.now();
  let status = "pending";
  let queriesSent = 0;
  let lastError;
  let timer2 = null;
  let queue = [];
  let doneCallbacks = [];
  if (typeof done === "function") {
    doneCallbacks.push(done);
  }
  function resetTimer() {
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
  }
  function abort() {
    if (status === "pending") {
      status = "aborted";
    }
    resetTimer();
    queue.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue = [];
  }
  function subscribe(callback, overwrite) {
    if (overwrite) {
      doneCallbacks = [];
    }
    if (typeof callback === "function") {
      doneCallbacks.push(callback);
    }
  }
  function getQueryStatus() {
    return {
      startTime,
      payload,
      status,
      queriesSent,
      queriesPending: queue.length,
      subscribe,
      abort
    };
  }
  function failQuery() {
    status = "failed";
    doneCallbacks.forEach((callback) => {
      callback(void 0, lastError);
    });
  }
  function clearQueue() {
    queue.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue = [];
  }
  function moduleResponse(item, response, data) {
    const isError = response !== "success";
    queue = queue.filter((queued) => queued !== item);
    switch (status) {
      case "pending":
        break;
      case "failed":
        if (isError || !config.dataAfterTimeout) {
          return;
        }
        break;
      default:
        return;
    }
    if (response === "abort") {
      lastError = data;
      failQuery();
      return;
    }
    if (isError) {
      lastError = data;
      if (!queue.length) {
        if (!resources.length) {
          failQuery();
        } else {
          execNext();
        }
      }
      return;
    }
    resetTimer();
    clearQueue();
    if (!config.random) {
      const index2 = config.resources.indexOf(item.resource);
      if (index2 !== -1 && index2 !== config.index) {
        config.index = index2;
      }
    }
    status = "completed";
    doneCallbacks.forEach((callback) => {
      callback(data);
    });
  }
  function execNext() {
    if (status !== "pending") {
      return;
    }
    resetTimer();
    const resource = resources.shift();
    if (resource === void 0) {
      if (queue.length) {
        timer2 = setTimeout(() => {
          resetTimer();
          if (status === "pending") {
            clearQueue();
            failQuery();
          }
        }, config.timeout);
        return;
      }
      failQuery();
      return;
    }
    const item = {
      status: "pending",
      resource,
      callback: (status2, data) => {
        moduleResponse(item, status2, data);
      }
    };
    queue.push(item);
    queriesSent++;
    timer2 = setTimeout(execNext, config.rotate);
    query(resource, payload, item.callback);
  }
  setTimeout(execNext);
  return getQueryStatus;
}
function initRedundancy(cfg) {
  const config = {
    ...defaultConfig,
    ...cfg
  };
  let queries = [];
  function cleanup() {
    queries = queries.filter((item) => item().status === "pending");
  }
  function query(payload, queryCallback, doneCallback) {
    const query2 = sendQuery(
      config,
      payload,
      queryCallback,
      (data, error) => {
        cleanup();
        if (doneCallback) {
          doneCallback(data, error);
        }
      }
    );
    queries.push(query2);
    return query2;
  }
  function find2(callback) {
    return queries.find((value) => {
      return callback(value);
    }) || null;
  }
  const instance = {
    query,
    find: find2,
    setIndex: (index2) => {
      config.index = index2;
    },
    getIndex: () => config.index,
    cleanup
  };
  return instance;
}
function createAPIConfig(source) {
  let resources;
  if (typeof source.resources === "string") {
    resources = [source.resources];
  } else {
    resources = source.resources;
    if (!(resources instanceof Array) || !resources.length) {
      return null;
    }
  }
  const result = {
    resources,
    path: source.path || "/",
    maxURL: source.maxURL || 500,
    rotate: source.rotate || 750,
    timeout: source.timeout || 5e3,
    random: source.random === true,
    index: source.index || 0,
    dataAfterTimeout: source.dataAfterTimeout !== false
  };
  return result;
}
var configStorage = /* @__PURE__ */ Object.create(null);
var fallBackAPISources = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
var fallBackAPI = [];
while (fallBackAPISources.length > 0) {
  if (fallBackAPISources.length === 1) {
    fallBackAPI.push(fallBackAPISources.shift());
  } else {
    if (Math.random() > 0.5) {
      fallBackAPI.push(fallBackAPISources.shift());
    } else {
      fallBackAPI.push(fallBackAPISources.pop());
    }
  }
}
configStorage[""] = createAPIConfig({
  resources: ["https://api.iconify.design"].concat(fallBackAPI)
});
function addAPIProvider$1(provider, customConfig) {
  const config = createAPIConfig(customConfig);
  if (config === null) {
    return false;
  }
  configStorage[provider] = config;
  return true;
}
function getAPIConfig(provider) {
  return configStorage[provider];
}
function listAPIProviders() {
  return Object.keys(configStorage);
}
function emptyCallback$1() {
}
var redundancyCache = /* @__PURE__ */ Object.create(null);
function getRedundancyCache(provider) {
  if (!redundancyCache[provider]) {
    const config = getAPIConfig(provider);
    if (!config) {
      return;
    }
    const redundancy = initRedundancy(config);
    const cachedReundancy = {
      config,
      redundancy
    };
    redundancyCache[provider] = cachedReundancy;
  }
  return redundancyCache[provider];
}
function sendAPIQuery(target, query, callback) {
  let redundancy;
  let send2;
  if (typeof target === "string") {
    const api = getAPIModule(target);
    if (!api) {
      callback(void 0, 424);
      return emptyCallback$1;
    }
    send2 = api.send;
    const cached = getRedundancyCache(target);
    if (cached) {
      redundancy = cached.redundancy;
    }
  } else {
    const config = createAPIConfig(target);
    if (config) {
      redundancy = initRedundancy(config);
      const moduleKey = target.resources ? target.resources[0] : "";
      const api = getAPIModule(moduleKey);
      if (api) {
        send2 = api.send;
      }
    }
  }
  if (!redundancy || !send2) {
    callback(void 0, 424);
    return emptyCallback$1;
  }
  return redundancy.query(query, send2, callback)().abort;
}
var browserCacheVersion = "iconify2";
var browserCachePrefix = "iconify";
var browserCacheCountKey = browserCachePrefix + "-count";
var browserCacheVersionKey = browserCachePrefix + "-version";
var browserStorageHour = 36e5;
var browserStorageCacheExpiration = 168;
function getStoredItem(func, key) {
  try {
    return func.getItem(key);
  } catch (err) {
  }
}
function setStoredItem(func, key, value) {
  try {
    func.setItem(key, value);
    return true;
  } catch (err) {
  }
}
function removeStoredItem(func, key) {
  try {
    func.removeItem(key);
  } catch (err) {
  }
}
function setBrowserStorageItemsCount(storage2, value) {
  return setStoredItem(storage2, browserCacheCountKey, value.toString());
}
function getBrowserStorageItemsCount(storage2) {
  return parseInt(getStoredItem(storage2, browserCacheCountKey)) || 0;
}
var browserStorageConfig = {
  local: true,
  session: true
};
var browserStorageEmptyItems = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
var browserStorageStatus = false;
function setBrowserStorageStatus(status) {
  browserStorageStatus = status;
}
var _window = typeof window === "undefined" ? {} : window;
function getBrowserStorage(key) {
  const attr = key + "Storage";
  try {
    if (_window && _window[attr] && typeof _window[attr].length === "number") {
      return _window[attr];
    }
  } catch (err) {
  }
  browserStorageConfig[key] = false;
}
function iterateBrowserStorage(key, callback) {
  const func = getBrowserStorage(key);
  if (!func) {
    return;
  }
  const version = getStoredItem(func, browserCacheVersionKey);
  if (version !== browserCacheVersion) {
    if (version) {
      const total2 = getBrowserStorageItemsCount(func);
      for (let i6 = 0; i6 < total2; i6++) {
        removeStoredItem(func, browserCachePrefix + i6.toString());
      }
    }
    setStoredItem(func, browserCacheVersionKey, browserCacheVersion);
    setBrowserStorageItemsCount(func, 0);
    return;
  }
  const minTime = Math.floor(Date.now() / browserStorageHour) - browserStorageCacheExpiration;
  const parseItem = (index2) => {
    const name = browserCachePrefix + index2.toString();
    const item = getStoredItem(func, name);
    if (typeof item !== "string") {
      return;
    }
    try {
      const data = JSON.parse(item);
      if (typeof data === "object" && typeof data.cached === "number" && data.cached > minTime && typeof data.provider === "string" && typeof data.data === "object" && typeof data.data.prefix === "string" && callback(data, index2)) {
        return true;
      }
    } catch (err) {
    }
    removeStoredItem(func, name);
  };
  let total = getBrowserStorageItemsCount(func);
  for (let i6 = total - 1; i6 >= 0; i6--) {
    if (!parseItem(i6)) {
      if (i6 === total - 1) {
        total--;
        setBrowserStorageItemsCount(func, total);
      } else {
        browserStorageEmptyItems[key].add(i6);
      }
    }
  }
}
function initBrowserStorage() {
  if (browserStorageStatus) {
    return;
  }
  setBrowserStorageStatus(true);
  for (const key in browserStorageConfig) {
    iterateBrowserStorage(key, (item) => {
      const iconSet = item.data;
      const provider = item.provider;
      const prefix = iconSet.prefix;
      const storage2 = getStorage(
        provider,
        prefix
      );
      if (!addIconSet(storage2, iconSet).length) {
        return false;
      }
      const lastModified = iconSet.lastModified || -1;
      storage2.lastModifiedCached = storage2.lastModifiedCached ? Math.min(storage2.lastModifiedCached, lastModified) : lastModified;
      return true;
    });
  }
}
function updateLastModified(storage2, lastModified) {
  const lastValue = storage2.lastModifiedCached;
  if (lastValue && lastValue >= lastModified) {
    return lastValue === lastModified;
  }
  storage2.lastModifiedCached = lastModified;
  if (lastValue) {
    for (const key in browserStorageConfig) {
      iterateBrowserStorage(key, (item) => {
        const iconSet = item.data;
        return item.provider !== storage2.provider || iconSet.prefix !== storage2.prefix || iconSet.lastModified === lastModified;
      });
    }
  }
  return true;
}
function storeInBrowserStorage(storage2, data) {
  if (!browserStorageStatus) {
    initBrowserStorage();
  }
  function store(key) {
    let func;
    if (!browserStorageConfig[key] || !(func = getBrowserStorage(key))) {
      return;
    }
    const set4 = browserStorageEmptyItems[key];
    let index2;
    if (set4.size) {
      set4.delete(index2 = Array.from(set4).shift());
    } else {
      index2 = getBrowserStorageItemsCount(func);
      if (!setBrowserStorageItemsCount(func, index2 + 1)) {
        return;
      }
    }
    const item = {
      cached: Math.floor(Date.now() / browserStorageHour),
      provider: storage2.provider,
      data
    };
    return setStoredItem(
      func,
      browserCachePrefix + index2.toString(),
      JSON.stringify(item)
    );
  }
  if (data.lastModified && !updateLastModified(storage2, data.lastModified)) {
    return;
  }
  if (!Object.keys(data.icons).length) {
    return;
  }
  if (data.not_found) {
    data = Object.assign({}, data);
    delete data.not_found;
  }
  if (!store("local")) {
    store("session");
  }
}
function emptyCallback() {
}
function loadedNewIcons(storage2) {
  if (!storage2.iconsLoaderFlag) {
    storage2.iconsLoaderFlag = true;
    setTimeout(() => {
      storage2.iconsLoaderFlag = false;
      updateCallbacks(storage2);
    });
  }
}
function loadNewIcons(storage2, icons) {
  if (!storage2.iconsToLoad) {
    storage2.iconsToLoad = icons;
  } else {
    storage2.iconsToLoad = storage2.iconsToLoad.concat(icons).sort();
  }
  if (!storage2.iconsQueueFlag) {
    storage2.iconsQueueFlag = true;
    setTimeout(() => {
      storage2.iconsQueueFlag = false;
      const { provider, prefix } = storage2;
      const icons2 = storage2.iconsToLoad;
      delete storage2.iconsToLoad;
      let api;
      if (!icons2 || !(api = getAPIModule(provider))) {
        return;
      }
      const params = api.prepare(provider, prefix, icons2);
      params.forEach((item) => {
        sendAPIQuery(provider, item, (data) => {
          if (typeof data !== "object") {
            item.icons.forEach((name) => {
              storage2.missing.add(name);
            });
          } else {
            try {
              const parsed = addIconSet(
                storage2,
                data
              );
              if (!parsed.length) {
                return;
              }
              const pending = storage2.pendingIcons;
              if (pending) {
                parsed.forEach((name) => {
                  pending.delete(name);
                });
              }
              storeInBrowserStorage(storage2, data);
            } catch (err) {
              console.error(err);
            }
          }
          loadedNewIcons(storage2);
        });
      });
    });
  }
}
var loadIcons$1 = (icons, callback) => {
  const cleanedIcons = listToIcons(icons, true, allowSimpleNames());
  const sortedIcons = sortIcons(cleanedIcons);
  if (!sortedIcons.pending.length) {
    let callCallback = true;
    if (callback) {
      setTimeout(() => {
        if (callCallback) {
          callback(
            sortedIcons.loaded,
            sortedIcons.missing,
            sortedIcons.pending,
            emptyCallback
          );
        }
      });
    }
    return () => {
      callCallback = false;
    };
  }
  const newIcons = /* @__PURE__ */ Object.create(null);
  const sources = [];
  let lastProvider, lastPrefix;
  sortedIcons.pending.forEach((icon) => {
    const { provider, prefix } = icon;
    if (prefix === lastPrefix && provider === lastProvider) {
      return;
    }
    lastProvider = provider;
    lastPrefix = prefix;
    sources.push(getStorage(provider, prefix));
    const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));
    if (!providerNewIcons[prefix]) {
      providerNewIcons[prefix] = [];
    }
  });
  sortedIcons.pending.forEach((icon) => {
    const { provider, prefix, name } = icon;
    const storage2 = getStorage(provider, prefix);
    const pendingQueue = storage2.pendingIcons || (storage2.pendingIcons = /* @__PURE__ */ new Set());
    if (!pendingQueue.has(name)) {
      pendingQueue.add(name);
      newIcons[provider][prefix].push(name);
    }
  });
  sources.forEach((storage2) => {
    const { provider, prefix } = storage2;
    if (newIcons[provider][prefix].length) {
      loadNewIcons(storage2, newIcons[provider][prefix]);
    }
  });
  return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;
};
var loadIcon$1 = (icon) => {
  return new Promise((fulfill, reject) => {
    const iconObj = typeof icon === "string" ? stringToIcon(icon, true) : icon;
    if (!iconObj) {
      reject(icon);
      return;
    }
    loadIcons$1([iconObj || icon], (loaded) => {
      if (loaded.length && iconObj) {
        const data = getIconData(iconObj);
        if (data) {
          fulfill({
            ...defaultIconProps,
            ...data
          });
          return;
        }
      }
      reject(icon);
    });
  });
};
function testIconObject(value) {
  try {
    const obj = typeof value === "string" ? JSON.parse(value) : value;
    if (typeof obj.body === "string") {
      return {
        ...obj
      };
    }
  } catch (err) {
  }
}
function parseIconValue(value, onload) {
  const name = typeof value === "string" ? stringToIcon(value, true, true) : null;
  if (!name) {
    const data2 = testIconObject(value);
    return {
      value,
      data: data2
    };
  }
  const data = getIconData(name);
  if (data !== void 0 || !name.prefix) {
    return {
      value,
      name,
      data
      // could be 'null' -> icon is missing
    };
  }
  const loading = loadIcons$1([name], () => onload(value, name, getIconData(name)));
  return {
    value,
    name,
    loading
  };
}
function getInline(node) {
  return node.hasAttribute("inline");
}
var isBuggedSafari = false;
try {
  isBuggedSafari = navigator.vendor.indexOf("Apple") === 0;
} catch (err) {
}
function getRenderMode(body, mode2) {
  switch (mode2) {
    case "svg":
    case "bg":
    case "mask":
      return mode2;
  }
  if (mode2 !== "style" && (isBuggedSafari || body.indexOf("<a") === -1)) {
    return "svg";
  }
  return body.indexOf("currentColor") === -1 ? "bg" : "mask";
}
var unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
var unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize$1(size, ratio, precision) {
  if (ratio === 1) {
    return size;
  }
  precision = precision || 100;
  if (typeof size === "number") {
    return Math.ceil(size * ratio * precision) / precision;
  }
  if (typeof size !== "string") {
    return size;
  }
  const oldParts = size.split(unitsSplit);
  if (oldParts === null || !oldParts.length) {
    return size;
  }
  const newParts = [];
  let code = oldParts.shift();
  let isNumber = unitsTest.test(code);
  while (true) {
    if (isNumber) {
      const num = parseFloat(code);
      if (isNaN(num)) {
        newParts.push(code);
      } else {
        newParts.push(Math.ceil(num * ratio * precision) / precision);
      }
    } else {
      newParts.push(code);
    }
    code = oldParts.shift();
    if (code === void 0) {
      return newParts.join("");
    }
    isNumber = !isNumber;
  }
}
var isUnsetKeyword = (value) => value === "unset" || value === "undefined" || value === "none";
function iconToSVG(icon, customisations) {
  const fullIcon = {
    ...defaultIconProps,
    ...icon
  };
  const fullCustomisations = {
    ...defaultIconCustomisations,
    ...customisations
  };
  const box = {
    left: fullIcon.left,
    top: fullIcon.top,
    width: fullIcon.width,
    height: fullIcon.height
  };
  let body = fullIcon.body;
  [fullIcon, fullCustomisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation = props.rotate;
    if (hFlip) {
      if (vFlip) {
        rotation += 2;
      } else {
        transformations.push(
          "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"
        );
        transformations.push("scale(-1 1)");
        box.top = box.left = 0;
      }
    } else if (vFlip) {
      transformations.push(
        "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"
      );
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation < 0) {
      rotation -= Math.floor(rotation / 4) * 4;
    }
    rotation = rotation % 4;
    switch (rotation) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift(
          "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
      case 2:
        transformations.unshift(
          "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"
        );
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift(
          "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
    }
    if (rotation % 2 === 1) {
      if (box.left !== box.top) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) {
      body = '<g transform="' + transformations.join(" ") + '">' + body + "</g>";
    }
  });
  const customisationsWidth = fullCustomisations.width;
  const customisationsHeight = fullCustomisations.height;
  const boxWidth = box.width;
  const boxHeight = box.height;
  let width;
  let height;
  if (customisationsWidth === null) {
    height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
    width = calculateSize$1(height, boxWidth / boxHeight);
  } else {
    width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
    height = customisationsHeight === null ? calculateSize$1(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
  }
  const attributes = {};
  const setAttr = (prop, value) => {
    if (!isUnsetKeyword(value)) {
      attributes[prop] = value.toString();
    }
  };
  setAttr("width", width);
  setAttr("height", height);
  attributes.viewBox = box.left.toString() + " " + box.top.toString() + " " + boxWidth.toString() + " " + boxHeight.toString();
  return {
    attributes,
    body
  };
}
var detectFetch = () => {
  let callback;
  try {
    callback = fetch;
    if (typeof callback === "function") {
      return callback;
    }
  } catch (err) {
  }
};
var fetchModule = detectFetch();
function setFetch(fetch2) {
  fetchModule = fetch2;
}
function getFetch() {
  return fetchModule;
}
function calculateMaxLength(provider, prefix) {
  const config = getAPIConfig(provider);
  if (!config) {
    return 0;
  }
  let result;
  if (!config.maxURL) {
    result = 0;
  } else {
    let maxHostLength = 0;
    config.resources.forEach((item) => {
      const host = item;
      maxHostLength = Math.max(maxHostLength, host.length);
    });
    const url = prefix + ".json?icons=";
    result = config.maxURL - maxHostLength - config.path.length - url.length;
  }
  return result;
}
function shouldAbort(status) {
  return status === 404;
}
var prepare = (provider, prefix, icons) => {
  const results = [];
  const maxLength = calculateMaxLength(provider, prefix);
  const type3 = "icons";
  let item = {
    type: type3,
    provider,
    prefix,
    icons: []
  };
  let length3 = 0;
  icons.forEach((name, index2) => {
    length3 += name.length + 1;
    if (length3 >= maxLength && index2 > 0) {
      results.push(item);
      item = {
        type: type3,
        provider,
        prefix,
        icons: []
      };
      length3 = name.length;
    }
    item.icons.push(name);
  });
  results.push(item);
  return results;
};
function getPath(provider) {
  if (typeof provider === "string") {
    const config = getAPIConfig(provider);
    if (config) {
      return config.path;
    }
  }
  return "/";
}
var send = (host, params, callback) => {
  if (!fetchModule) {
    callback("abort", 424);
    return;
  }
  let path2 = getPath(params.provider);
  switch (params.type) {
    case "icons": {
      const prefix = params.prefix;
      const icons = params.icons;
      const iconsList = icons.join(",");
      const urlParams = new URLSearchParams({
        icons: iconsList
      });
      path2 += prefix + ".json?" + urlParams.toString();
      break;
    }
    case "custom": {
      const uri = params.uri;
      path2 += uri.slice(0, 1) === "/" ? uri.slice(1) : uri;
      break;
    }
    default:
      callback("abort", 400);
      return;
  }
  let defaultError = 503;
  fetchModule(host + path2).then((response) => {
    const status = response.status;
    if (status !== 200) {
      setTimeout(() => {
        callback(shouldAbort(status) ? "abort" : "next", status);
      });
      return;
    }
    defaultError = 501;
    return response.json();
  }).then((data) => {
    if (typeof data !== "object" || data === null) {
      setTimeout(() => {
        if (data === 404) {
          callback("abort", data);
        } else {
          callback("next", defaultError);
        }
      });
      return;
    }
    setTimeout(() => {
      callback("success", data);
    });
  }).catch(() => {
    callback("next", defaultError);
  });
};
var fetchAPIModule = {
  prepare,
  send
};
function toggleBrowserCache(storage2, value) {
  switch (storage2) {
    case "local":
    case "session":
      browserStorageConfig[storage2] = value;
      break;
    case "all":
      for (const key in browserStorageConfig) {
        browserStorageConfig[key] = value;
      }
      break;
  }
}
var nodeAttr = "data-style";
var customStyle = "";
function appendCustomStyle(style) {
  customStyle = style;
}
function updateStyle(parent, inline) {
  let styleNode = Array.from(parent.childNodes).find((node) => node.hasAttribute && node.hasAttribute(nodeAttr));
  if (!styleNode) {
    styleNode = document.createElement("style");
    styleNode.setAttribute(nodeAttr, nodeAttr);
    parent.appendChild(styleNode);
  }
  styleNode.textContent = ":host{display:inline-block;vertical-align:" + (inline ? "-0.125em" : "0") + "}span,svg{display:block}" + customStyle;
}
function exportFunctions() {
  setAPIModule("", fetchAPIModule);
  allowSimpleNames(true);
  let _window2;
  try {
    _window2 = window;
  } catch (err) {
  }
  if (_window2) {
    initBrowserStorage();
    if (_window2.IconifyPreload !== void 0) {
      const preload = _window2.IconifyPreload;
      const err = "Invalid IconifyPreload syntax.";
      if (typeof preload === "object" && preload !== null) {
        (preload instanceof Array ? preload : [preload]).forEach((item) => {
          try {
            if (
              // Check if item is an object and not null/array
              typeof item !== "object" || item === null || item instanceof Array || // Check for 'icons' and 'prefix'
              typeof item.icons !== "object" || typeof item.prefix !== "string" || // Add icon set
              !addCollection$1(item)
            ) {
              console.error(err);
            }
          } catch (e9) {
            console.error(err);
          }
        });
      }
    }
    if (_window2.IconifyProviders !== void 0) {
      const providers = _window2.IconifyProviders;
      if (typeof providers === "object" && providers !== null) {
        for (const key in providers) {
          const err = "IconifyProviders[" + key + "] is invalid.";
          try {
            const value = providers[key];
            if (typeof value !== "object" || !value || value.resources === void 0) {
              continue;
            }
            if (!addAPIProvider$1(key, value)) {
              console.error(err);
            }
          } catch (e9) {
            console.error(err);
          }
        }
      }
    }
  }
  const _api2 = {
    getAPIConfig,
    setAPIModule,
    sendAPIQuery,
    setFetch,
    getFetch,
    listAPIProviders
  };
  return {
    enableCache: (storage2) => toggleBrowserCache(storage2, true),
    disableCache: (storage2) => toggleBrowserCache(storage2, false),
    iconExists: iconExists$1,
    getIcon: getIcon$1,
    listIcons: listIcons$1,
    addIcon: addIcon$1,
    addCollection: addCollection$1,
    calculateSize: calculateSize$1,
    buildIcon: iconToSVG,
    loadIcons: loadIcons$1,
    loadIcon: loadIcon$1,
    addAPIProvider: addAPIProvider$1,
    appendCustomStyle,
    _api: _api2
  };
}
function iconToHTML(body, attributes) {
  let renderAttribsHTML = body.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const attr in attributes) {
    renderAttribsHTML += " " + attr + '="' + attributes[attr] + '"';
  }
  return '<svg xmlns="http://www.w3.org/2000/svg"' + renderAttribsHTML + ">" + body + "</svg>";
}
function encodeSVGforURL(svg) {
  return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function svgToURL(svg) {
  return 'url("data:image/svg+xml,' + encodeSVGforURL(svg) + '")';
}
var monotoneProps = {
  "background-color": "currentColor"
};
var coloredProps = {
  "background-color": "transparent"
};
var propsToAdd = {
  image: "var(--svg)",
  repeat: "no-repeat",
  size: "100% 100%"
};
var propsToAddTo = {
  "-webkit-mask": monotoneProps,
  "mask": monotoneProps,
  "background": coloredProps
};
for (const prefix in propsToAddTo) {
  const list = propsToAddTo[prefix];
  for (const prop in propsToAdd) {
    list[prefix + "-" + prop] = propsToAdd[prop];
  }
}
function fixSize(value) {
  return value ? value + (value.match(/^[-0-9.]+$/) ? "px" : "") : "inherit";
}
function renderSPAN(data, icon, useMask) {
  const node = document.createElement("span");
  let body = data.body;
  if (body.indexOf("<a") !== -1) {
    body += "<!-- " + Date.now() + " -->";
  }
  const renderAttribs = data.attributes;
  const html = iconToHTML(body, {
    ...renderAttribs,
    width: icon.width + "",
    height: icon.height + ""
  });
  const url = svgToURL(html);
  const svgStyle = node.style;
  const styles2 = {
    "--svg": url,
    "width": fixSize(renderAttribs.width),
    "height": fixSize(renderAttribs.height),
    ...useMask ? monotoneProps : coloredProps
  };
  for (const prop in styles2) {
    svgStyle.setProperty(prop, styles2[prop]);
  }
  return node;
}
function renderSVG(data) {
  const node = document.createElement("span");
  const attr = data.attributes;
  let style = "";
  if (!attr.width) {
    style = "width: inherit;";
  }
  if (!attr.height) {
    style += "height: inherit;";
  }
  if (style) {
    attr.style = style;
  }
  node.innerHTML = iconToHTML(data.body, attr);
  return node.firstChild;
}
function renderIcon(parent, state) {
  const iconData = state.icon.data;
  const customisations = state.customisations;
  const renderData = iconToSVG(iconData, customisations);
  if (customisations.preserveAspectRatio) {
    renderData.attributes["preserveAspectRatio"] = customisations.preserveAspectRatio;
  }
  const mode2 = state.renderedMode;
  let node;
  switch (mode2) {
    case "svg":
      node = renderSVG(renderData);
      break;
    default:
      node = renderSPAN(renderData, {
        ...defaultIconProps,
        ...iconData
      }, mode2 === "mask");
  }
  const oldNode = Array.from(parent.childNodes).find((node2) => {
    const tag = node2.tagName && node2.tagName.toUpperCase();
    return tag === "SPAN" || tag === "SVG";
  });
  if (oldNode) {
    if (node.tagName === "SPAN" && oldNode.tagName === node.tagName) {
      oldNode.setAttribute("style", node.getAttribute("style"));
    } else {
      parent.replaceChild(node, oldNode);
    }
  } else {
    parent.appendChild(node);
  }
}
function setPendingState(icon, inline, lastState) {
  const lastRender = lastState && (lastState.rendered ? lastState : lastState.lastRender);
  return {
    rendered: false,
    inline,
    icon,
    lastRender
  };
}
function defineIconifyIcon(name = "iconify-icon") {
  let customElements2;
  let ParentClass;
  try {
    customElements2 = window.customElements;
    ParentClass = window.HTMLElement;
  } catch (err) {
    return;
  }
  if (!customElements2 || !ParentClass) {
    return;
  }
  const ConflictingClass = customElements2.get(name);
  if (ConflictingClass) {
    return ConflictingClass;
  }
  const attributes = [
    // Icon
    "icon",
    // Mode
    "mode",
    "inline",
    // Customisations
    "width",
    "height",
    "rotate",
    "flip"
  ];
  const IconifyIcon = class extends ParentClass {
    // Root
    _shadowRoot;
    // State
    _state;
    // Attributes check queued
    _checkQueued = false;
    /**
     * Constructor
     */
    constructor() {
      super();
      const root3 = this._shadowRoot = this.attachShadow({
        mode: "open"
      });
      const inline = getInline(this);
      updateStyle(root3, inline);
      this._state = setPendingState({
        value: ""
      }, inline);
      this._queueCheck();
    }
    /**
     * Observed attributes
     */
    static get observedAttributes() {
      return attributes.slice(0);
    }
    /**
     * Observed properties that are different from attributes
     *
     * Experimental! Need to test with various frameworks that support it
     */
    /*
    static get properties() {
        return {
            inline: {
                type: Boolean,
                reflect: true,
            },
            // Not listing other attributes because they are strings or combination
            // of string and another type. Cannot have multiple types
        };
    }
    */
    /**
     * Attribute has changed
     */
    attributeChangedCallback(name2) {
      if (name2 === "inline") {
        const newInline = getInline(this);
        const state = this._state;
        if (newInline !== state.inline) {
          state.inline = newInline;
          updateStyle(this._shadowRoot, newInline);
        }
      } else {
        this._queueCheck();
      }
    }
    /**
     * Get/set icon
     */
    get icon() {
      const value = this.getAttribute("icon");
      if (value && value.slice(0, 1) === "{") {
        try {
          return JSON.parse(value);
        } catch (err) {
        }
      }
      return value;
    }
    set icon(value) {
      if (typeof value === "object") {
        value = JSON.stringify(value);
      }
      this.setAttribute("icon", value);
    }
    /**
     * Get/set inline
     */
    get inline() {
      return getInline(this);
    }
    set inline(value) {
      if (value) {
        this.setAttribute("inline", "true");
      } else {
        this.removeAttribute("inline");
      }
    }
    /**
     * Restart animation
     */
    restartAnimation() {
      const state = this._state;
      if (state.rendered) {
        const root3 = this._shadowRoot;
        if (state.renderedMode === "svg") {
          try {
            root3.lastChild.setCurrentTime(0);
            return;
          } catch (err) {
          }
        }
        renderIcon(root3, state);
      }
    }
    /**
     * Get status
     */
    get status() {
      const state = this._state;
      return state.rendered ? "rendered" : state.icon.data === null ? "failed" : "loading";
    }
    /**
     * Queue attributes re-check
     */
    _queueCheck() {
      if (!this._checkQueued) {
        this._checkQueued = true;
        setTimeout(() => {
          this._check();
        });
      }
    }
    /**
     * Check for changes
     */
    _check() {
      if (!this._checkQueued) {
        return;
      }
      this._checkQueued = false;
      const state = this._state;
      const newIcon = this.getAttribute("icon");
      if (newIcon !== state.icon.value) {
        this._iconChanged(newIcon);
        return;
      }
      if (!state.rendered) {
        return;
      }
      const mode2 = this.getAttribute("mode");
      const customisations = getCustomisations(this);
      if (state.attrMode !== mode2 || haveCustomisationsChanged(state.customisations, customisations)) {
        this._renderIcon(state.icon, customisations, mode2);
      }
    }
    /**
     * Icon value has changed
     */
    _iconChanged(newValue) {
      const icon = parseIconValue(newValue, (value, name2, data) => {
        const state = this._state;
        if (state.rendered || this.getAttribute("icon") !== value) {
          return;
        }
        const icon2 = {
          value,
          name: name2,
          data
        };
        if (icon2.data) {
          this._gotIconData(icon2);
        } else {
          state.icon = icon2;
        }
      });
      if (icon.data) {
        this._gotIconData(icon);
      } else {
        this._state = setPendingState(icon, this._state.inline, this._state);
      }
    }
    /**
     * Got new icon data, icon is ready to (re)render
     */
    _gotIconData(icon) {
      this._checkQueued = false;
      this._renderIcon(icon, getCustomisations(this), this.getAttribute("mode"));
    }
    /**
     * Re-render based on icon data
     */
    _renderIcon(icon, customisations, attrMode) {
      const renderedMode = getRenderMode(icon.data.body, attrMode);
      const inline = this._state.inline;
      renderIcon(this._shadowRoot, this._state = {
        rendered: true,
        icon,
        inline,
        customisations,
        attrMode,
        renderedMode
      });
    }
  };
  attributes.forEach((attr) => {
    if (!(attr in IconifyIcon.prototype)) {
      Object.defineProperty(IconifyIcon.prototype, attr, {
        get: function() {
          return this.getAttribute(attr);
        },
        set: function(value) {
          if (value !== null) {
            this.setAttribute(attr, value);
          } else {
            this.removeAttribute(attr);
          }
        }
      });
    }
  });
  const functions = exportFunctions();
  for (const key in functions) {
    IconifyIcon[key] = IconifyIcon.prototype[key] = functions[key];
  }
  customElements2.define(name, IconifyIcon);
  return IconifyIcon;
}
var IconifyIconComponent = defineIconifyIcon() || exportFunctions();
var { enableCache, disableCache, iconExists, getIcon, listIcons, addIcon, addCollection, calculateSize, buildIcon, loadIcons, loadIcon, addAPIProvider, _api } = IconifyIconComponent;

// src/icon.ts
var ShinyIcon = class extends s4 {
  constructor() {
    super(...arguments);
    this.name = "info-circle";
  }
  /**
   * Renders the ShinyIcon element.
   * @returns {TemplateResult} The rendered template for the ShinyIcon element.
   */
  render() {
    return x`<iconify-icon icon="${this.name}"></iconify-icon>`;
  }
};
/**
 * The styles for the ShinyIcon element.
 * @static
 * @property {CSSResult} styles
 */
ShinyIcon.styles = i`
    :host {
      display: inline-block;
      height: 1em;
    }
  `;
__decorateClass([
  n6()
], ShinyIcon.prototype, "name", 2);
ShinyIcon = __decorateClass([
  e6("shiny-icon")
], ShinyIcon);

// node_modules/d3-array/src/ascending.js
function ascending(a7, b5) {
  return a7 == null || b5 == null ? NaN : a7 < b5 ? -1 : a7 > b5 ? 1 : a7 >= b5 ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a7, b5) {
  return a7 == null || b5 == null ? NaN : b5 < a7 ? -1 : b5 > a7 ? 1 : b5 >= a7 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f4) {
  let compare1, compare2, delta;
  if (f4.length !== 2) {
    compare1 = ascending;
    compare2 = (d6, x6) => ascending(f4(d6), x6);
    delta = (d6, x6) => f4(d6) - x6;
  } else {
    compare1 = f4 === ascending || f4 === descending ? f4 : zero;
    compare2 = f4;
    delta = f4;
  }
  function left2(a7, x6, lo = 0, hi = a7.length) {
    if (lo < hi) {
      if (compare1(x6, x6) !== 0)
        return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a7[mid2], x6) < 0)
          lo = mid2 + 1;
        else
          hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a7, x6, lo = 0, hi = a7.length) {
    if (lo < hi) {
      if (compare1(x6, x6) !== 0)
        return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a7[mid2], x6) <= 0)
          lo = mid2 + 1;
        else
          hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a7, x6, lo = 0, hi = a7.length) {
    const i6 = left2(a7, x6, lo, hi - 1);
    return i6 > lo && delta(a7[i6 - 1], x6) > -delta(a7[i6], x6) ? i6 - 1 : i6;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x6) {
  return x6 === null ? NaN : +x6;
}
function* numbers(values2, valueof2) {
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/count.js
function count(values2, valueof2) {
  let count2 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        ++count2;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        ++count2;
      }
    }
  }
  return count2;
}

// node_modules/d3-array/src/cross.js
function length(array2) {
  return array2.length | 0;
}
function empty(length3) {
  return !(length3 > 0);
}
function arrayify(values2) {
  return typeof values2 !== "object" || "length" in values2 ? values2 : Array.from(values2);
}
function reducer(reduce) {
  return (values2) => reduce(...values2);
}
function cross(...values2) {
  const reduce = typeof values2[values2.length - 1] === "function" && reducer(values2.pop());
  values2 = values2.map(arrayify);
  const lengths = values2.map(length);
  const j5 = values2.length - 1;
  const index2 = new Array(j5 + 1).fill(0);
  const product = [];
  if (j5 < 0 || lengths.some(empty))
    return product;
  while (true) {
    product.push(index2.map((j6, i7) => values2[i7][j6]));
    let i6 = j5;
    while (++index2[i6] === lengths[i6]) {
      if (i6 === 0)
        return reduce ? product.map(reduce) : product;
      index2[i6--] = 0;
    }
  }
}

// node_modules/d3-array/src/cumsum.js
function cumsum(values2, valueof2) {
  var sum2 = 0, index2 = 0;
  return Float64Array.from(values2, valueof2 === void 0 ? (v4) => sum2 += +v4 || 0 : (v4) => sum2 += +valueof2(v4, index2++, values2) || 0);
}

// node_modules/d3-array/src/variance.js
function variance(values2, valueof2) {
  let count2 = 0;
  let delta;
  let mean2 = 0;
  let sum2 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        delta = value - mean2;
        mean2 += delta / ++count2;
        sum2 += delta * (value - mean2);
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        delta = value - mean2;
        mean2 += delta / ++count2;
        sum2 += delta * (value - mean2);
      }
    }
  }
  if (count2 > 1)
    return sum2 / (count2 - 1);
}

// node_modules/d3-array/src/deviation.js
function deviation(values2, valueof2) {
  const v4 = variance(values2, valueof2);
  return v4 ? Math.sqrt(v4) : v4;
}

// node_modules/d3-array/src/extent.js
function extent(values2, valueof2) {
  let min4;
  let max4;
  if (valueof2 === void 0) {
    for (const value of values2) {
      if (value != null) {
        if (min4 === void 0) {
          if (value >= value)
            min4 = max4 = value;
        } else {
          if (min4 > value)
            min4 = value;
          if (max4 < value)
            max4 = value;
        }
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null) {
        if (min4 === void 0) {
          if (value >= value)
            min4 = max4 = value;
        } else {
          if (min4 > value)
            min4 = value;
          if (max4 < value)
            max4 = value;
        }
      }
    }
  }
  return [min4, max4];
}

// node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x6) {
    const p5 = this._partials;
    let i6 = 0;
    for (let j5 = 0; j5 < this._n && j5 < 32; j5++) {
      const y5 = p5[j5], hi = x6 + y5, lo = Math.abs(x6) < Math.abs(y5) ? x6 - (hi - y5) : y5 - (hi - x6);
      if (lo)
        p5[i6++] = lo;
      x6 = hi;
    }
    p5[i6] = x6;
    this._n = i6 + 1;
    return this;
  }
  valueOf() {
    const p5 = this._partials;
    let n9 = this._n, x6, y5, lo, hi = 0;
    if (n9 > 0) {
      hi = p5[--n9];
      while (n9 > 0) {
        x6 = hi;
        y5 = p5[--n9];
        hi = x6 + y5;
        lo = y5 - (hi - x6);
        if (lo)
          break;
      }
      if (n9 > 0 && (lo < 0 && p5[n9 - 1] < 0 || lo > 0 && p5[n9 - 1] > 0)) {
        y5 = lo * 2;
        x6 = hi + y5;
        if (y5 == x6 - hi)
          hi = x6;
      }
    }
    return hi;
  }
};

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value] of entries)
        this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
var InternSet = class extends Set {
  constructor(values2, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (values2 != null)
      for (const value of values2)
        this.add(value);
  }
  has(value) {
    return super.has(intern_get(this, value));
  }
  add(value) {
    return super.add(intern_set(this, value));
  }
  delete(value) {
    return super.delete(intern_delete(this, value));
  }
};
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

// node_modules/d3-array/src/identity.js
function identity2(x6) {
  return x6;
}

// node_modules/d3-array/src/group.js
function group(values2, ...keys2) {
  return nest(values2, identity2, identity2, keys2);
}
function rollup(values2, reduce, ...keys2) {
  return nest(values2, identity2, reduce, keys2);
}
function rollups(values2, reduce, ...keys2) {
  return nest(values2, Array.from, reduce, keys2);
}
function nest(values2, map4, reduce, keys2) {
  return function regroup(values3, i6) {
    if (i6 >= keys2.length)
      return reduce(values3);
    const groups2 = new InternMap();
    const keyof3 = keys2[i6++];
    let index2 = -1;
    for (const value of values3) {
      const key = keyof3(value, ++index2, values3);
      const group2 = groups2.get(key);
      if (group2)
        group2.push(value);
      else
        groups2.set(key, [value]);
    }
    for (const [key, values4] of groups2) {
      groups2.set(key, regroup(values4, i6));
    }
    return map4(groups2);
  }(values2, 0);
}

// node_modules/d3-array/src/permute.js
function permute(source, keys2) {
  return Array.from(keys2, (key) => source[key]);
}

// node_modules/d3-array/src/sort.js
function sort(values2, ...F4) {
  if (typeof values2[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  values2 = Array.from(values2);
  let [f4] = F4;
  if (f4 && f4.length !== 2 || F4.length > 1) {
    const index2 = Uint32Array.from(values2, (d6, i6) => i6);
    if (F4.length > 1) {
      F4 = F4.map((f5) => values2.map(f5));
      index2.sort((i6, j5) => {
        for (const f5 of F4) {
          const c9 = ascendingDefined(f5[i6], f5[j5]);
          if (c9)
            return c9;
        }
      });
    } else {
      f4 = values2.map(f4);
      index2.sort((i6, j5) => ascendingDefined(f4[i6], f4[j5]));
    }
    return permute(values2, index2);
  }
  return values2.sort(compareDefined(f4));
}
function compareDefined(compare = ascending) {
  if (compare === ascending)
    return ascendingDefined;
  if (typeof compare !== "function")
    throw new TypeError("compare is not a function");
  return (a7, b5) => {
    const x6 = compare(a7, b5);
    if (x6 || x6 === 0)
      return x6;
    return (compare(b5, b5) === 0) - (compare(a7, a7) === 0);
  };
}
function ascendingDefined(a7, b5) {
  return (a7 == null || !(a7 >= a7)) - (b5 == null || !(b5 >= b5)) || (a7 < b5 ? -1 : a7 > b5 ? 1 : 0);
}

// node_modules/d3-array/src/groupSort.js
function groupSort(values2, reduce, key) {
  return (reduce.length !== 2 ? sort(rollup(values2, reduce, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values2, key), ([ak, av], [bk, bv]) => reduce(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e52 = Math.sqrt(10);
var e22 = Math.sqrt(2);
function tickSpec(start2, stop, count2) {
  const step = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e52 ? 5 : error >= e22 ? 2 : 1;
  let i1, i22, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start2 * inc);
    i22 = Math.round(stop * inc);
    if (i1 / inc < start2)
      ++i1;
    if (i22 / inc > stop)
      --i22;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start2 / inc);
    i22 = Math.round(stop / inc);
    if (i1 * inc < start2)
      ++i1;
    if (i22 * inc > stop)
      --i22;
  }
  if (i22 < i1 && 0.5 <= count2 && count2 < 2)
    return tickSpec(start2, stop, count2 * 2);
  return [i1, i22, inc];
}
function ticks(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  if (!(count2 > 0))
    return [];
  if (start2 === stop)
    return [start2];
  const reverse2 = stop < start2, [i1, i22, inc] = reverse2 ? tickSpec(stop, start2, count2) : tickSpec(start2, stop, count2);
  if (!(i22 >= i1))
    return [];
  const n9 = i22 - i1 + 1, ticks2 = new Array(n9);
  if (reverse2) {
    if (inc < 0)
      for (let i6 = 0; i6 < n9; ++i6)
        ticks2[i6] = (i22 - i6) / -inc;
    else
      for (let i6 = 0; i6 < n9; ++i6)
        ticks2[i6] = (i22 - i6) * inc;
  } else {
    if (inc < 0)
      for (let i6 = 0; i6 < n9; ++i6)
        ticks2[i6] = (i1 + i6) / -inc;
    else
      for (let i6 = 0; i6 < n9; ++i6)
        ticks2[i6] = (i1 + i6) * inc;
  }
  return ticks2;
}
function tickIncrement(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  return tickSpec(start2, stop, count2)[2];
}
function tickStep(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  const reverse2 = stop < start2, inc = reverse2 ? tickIncrement(stop, start2, count2) : tickIncrement(start2, stop, count2);
  return (reverse2 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/d3-array/src/threshold/sturges.js
function thresholdSturges(values2) {
  return Math.max(1, Math.ceil(Math.log(count(values2)) / Math.LN2) + 1);
}

// node_modules/d3-array/src/max.js
function max(values2, valueof2) {
  let max4;
  if (valueof2 === void 0) {
    for (const value of values2) {
      if (value != null && (max4 < value || max4 === void 0 && value >= value)) {
        max4 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (max4 < value || max4 === void 0 && value >= value)) {
        max4 = value;
      }
    }
  }
  return max4;
}

// node_modules/d3-array/src/maxIndex.js
function maxIndex(values2, valueof2) {
  let max4;
  let maxIndex2 = -1;
  let index2 = -1;
  if (valueof2 === void 0) {
    for (const value of values2) {
      ++index2;
      if (value != null && (max4 < value || max4 === void 0 && value >= value)) {
        max4 = value, maxIndex2 = index2;
      }
    }
  } else {
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (max4 < value || max4 === void 0 && value >= value)) {
        max4 = value, maxIndex2 = index2;
      }
    }
  }
  return maxIndex2;
}

// node_modules/d3-array/src/min.js
function min(values2, valueof2) {
  let min4;
  if (valueof2 === void 0) {
    for (const value of values2) {
      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value;
      }
    }
  }
  return min4;
}

// node_modules/d3-array/src/minIndex.js
function minIndex(values2, valueof2) {
  let min4;
  let minIndex2 = -1;
  let index2 = -1;
  if (valueof2 === void 0) {
    for (const value of values2) {
      ++index2;
      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value, minIndex2 = index2;
      }
    }
  } else {
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value, minIndex2 = index2;
      }
    }
  }
  return minIndex2;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array2, k6, left2 = 0, right2 = Infinity, compare) {
  k6 = Math.floor(k6);
  left2 = Math.floor(Math.max(0, left2));
  right2 = Math.floor(Math.min(array2.length - 1, right2));
  if (!(left2 <= k6 && k6 <= right2))
    return array2;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      const n9 = right2 - left2 + 1;
      const m5 = k6 - left2 + 1;
      const z5 = Math.log(n9);
      const s8 = 0.5 * Math.exp(2 * z5 / 3);
      const sd = 0.5 * Math.sqrt(z5 * s8 * (n9 - s8) / n9) * (m5 - n9 / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left2, Math.floor(k6 - m5 * s8 / n9 + sd));
      const newRight = Math.min(right2, Math.floor(k6 + (n9 - m5) * s8 / n9 + sd));
      quickselect(array2, k6, newLeft, newRight, compare);
    }
    const t6 = array2[k6];
    let i6 = left2;
    let j5 = right2;
    swap(array2, left2, k6);
    if (compare(array2[right2], t6) > 0)
      swap(array2, left2, right2);
    while (i6 < j5) {
      swap(array2, i6, j5), ++i6, --j5;
      while (compare(array2[i6], t6) < 0)
        ++i6;
      while (compare(array2[j5], t6) > 0)
        --j5;
    }
    if (compare(array2[left2], t6) === 0)
      swap(array2, left2, j5);
    else
      ++j5, swap(array2, j5, right2);
    if (j5 <= k6)
      left2 = j5 + 1;
    if (k6 <= j5)
      right2 = j5 - 1;
  }
  return array2;
}
function swap(array2, i6, j5) {
  const t6 = array2[i6];
  array2[i6] = array2[j5];
  array2[j5] = t6;
}

// node_modules/d3-array/src/greatest.js
function greatest(values2, compare = ascending) {
  let max4;
  let defined2 = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values2) {
      const value = compare(element);
      if (defined2 ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {
        max4 = element;
        maxValue = value;
        defined2 = true;
      }
    }
  } else {
    for (const value of values2) {
      if (defined2 ? compare(value, max4) > 0 : compare(value, value) === 0) {
        max4 = value;
        defined2 = true;
      }
    }
  }
  return max4;
}

// node_modules/d3-array/src/quantile.js
function quantile(values2, p5, valueof2) {
  values2 = Float64Array.from(numbers(values2, valueof2));
  if (!(n9 = values2.length) || isNaN(p5 = +p5))
    return;
  if (p5 <= 0 || n9 < 2)
    return min(values2);
  if (p5 >= 1)
    return max(values2);
  var n9, i6 = (n9 - 1) * p5, i0 = Math.floor(i6), value0 = max(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min(values2.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i6 - i0);
}
function quantileSorted(values2, p5, valueof2 = number) {
  if (!(n9 = values2.length) || isNaN(p5 = +p5))
    return;
  if (p5 <= 0 || n9 < 2)
    return +valueof2(values2[0], 0, values2);
  if (p5 >= 1)
    return +valueof2(values2[n9 - 1], n9 - 1, values2);
  var n9, i6 = (n9 - 1) * p5, i0 = Math.floor(i6), value0 = +valueof2(values2[i0], i0, values2), value1 = +valueof2(values2[i0 + 1], i0 + 1, values2);
  return value0 + (value1 - value0) * (i6 - i0);
}

// node_modules/d3-array/src/threshold/freedmanDiaconis.js
function thresholdFreedmanDiaconis(values2, min4, max4) {
  const c9 = count(values2), d6 = quantile(values2, 0.75) - quantile(values2, 0.25);
  return c9 && d6 ? Math.ceil((max4 - min4) / (2 * d6 * Math.pow(c9, -1 / 3))) : 1;
}

// node_modules/d3-array/src/threshold/scott.js
function thresholdScott(values2, min4, max4) {
  const c9 = count(values2), d6 = deviation(values2);
  return c9 && d6 ? Math.ceil((max4 - min4) * Math.cbrt(c9) / (3.49 * d6)) : 1;
}

// node_modules/d3-array/src/mean.js
function mean(values2, valueof2) {
  let count2 = 0;
  let sum2 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        ++count2, sum2 += value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        ++count2, sum2 += value;
      }
    }
  }
  if (count2)
    return sum2 / count2;
}

// node_modules/d3-array/src/median.js
function median(values2, valueof2) {
  return quantile(values2, 0.5, valueof2);
}

// node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array2 of arrays) {
    yield* array2;
  }
}
function merge2(arrays) {
  return Array.from(flatten(arrays));
}

// node_modules/d3-array/src/mode.js
function mode(values2, valueof2) {
  const counts = new InternMap();
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  }
  let modeValue;
  let modeCount = 0;
  for (const [value, count2] of counts) {
    if (count2 > modeCount) {
      modeCount = count2;
      modeValue = value;
    }
  }
  return modeValue;
}

// node_modules/d3-array/src/pairs.js
function pairs(values2, pairof = pair) {
  const pairs2 = [];
  let previous;
  let first2 = false;
  for (const value of values2) {
    if (first2)
      pairs2.push(pairof(previous, value));
    previous = value;
    first2 = true;
  }
  return pairs2;
}
function pair(a7, b5) {
  return [a7, b5];
}

// node_modules/d3-array/src/range.js
function range(start2, stop, step) {
  start2 = +start2, stop = +stop, step = (n9 = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n9 < 3 ? 1 : +step;
  var i6 = -1, n9 = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range4 = new Array(n9);
  while (++i6 < n9) {
    range4[i6] = start2 + i6 * step;
  }
  return range4;
}

// node_modules/d3-array/src/sum.js
function sum(values2, valueof2) {
  let sum2 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value = +value) {
        sum2 += value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if (value = +valueof2(value, ++index2, values2)) {
        sum2 += value;
      }
    }
  }
  return sum2;
}

// node_modules/d3-array/src/reverse.js
function reverse(values2) {
  if (typeof values2[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  return Array.from(values2).reverse();
}

// node_modules/d3-axis/src/identity.js
function identity_default2(x6) {
  return x6;
}

// node_modules/d3-axis/src/axis.js
var top = 1;
var right = 2;
var bottom = 3;
var left = 4;
var epsilon = 1e-6;
function translateX(x6) {
  return "translate(" + x6 + ",0)";
}
function translateY(y5) {
  return "translate(0," + y5 + ")";
}
function number2(scale2) {
  return (d6) => +scale2(d6);
}
function center(scale2, offset2) {
  offset2 = Math.max(0, scale2.bandwidth() - offset2 * 2) / 2;
  if (scale2.round())
    offset2 = Math.round(offset2);
  return (d6) => +scale2(d6) + offset2;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale2) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset2 = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k6 = orient === top || orient === left ? -1 : 1, x6 = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values2 = tickValues == null ? scale2.ticks ? scale2.ticks.apply(scale2, tickArguments) : scale2.domain() : tickValues, format3 = tickFormat2 == null ? scale2.tickFormat ? scale2.tickFormat.apply(scale2, tickArguments) : identity_default2 : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range4 = scale2.range(), range0 = +range4[0] + offset2, range1 = +range4[range4.length - 1] + offset2, position2 = (scale2.bandwidth ? center : number2)(scale2.copy(), offset2), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values2, scale2).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text2 = tick.select("text");
    path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x6 + "2", k6 * tickSizeInner));
    text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x6, k6 * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path2 = path2.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text2 = text2.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d6) {
        return isFinite(d6 = position2(d6)) ? transform2(d6 + offset2) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function(d6) {
        var p5 = this.parentNode.__axis;
        return transform2((p5 && isFinite(p5 = p5(d6)) ? p5 : position2(d6)) + offset2);
      });
    }
    tickExit.remove();
    path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k6 * tickSizeOuter + "," + range0 + "H" + offset2 + "V" + range1 + "H" + k6 * tickSizeOuter : "M" + offset2 + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k6 * tickSizeOuter + "V" + offset2 + "H" + range1 + "V" + k6 * tickSizeOuter : "M" + range0 + "," + offset2 + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d6) {
      return transform2(position2(d6) + offset2);
    });
    line.attr(x6 + "2", k6 * tickSizeInner);
    text2.attr(x6, k6 * spacing).text(format3);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position2;
    });
  }
  axis2.scale = function(_4) {
    return arguments.length ? (scale2 = _4, axis2) : scale2;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_4) {
    return arguments.length ? (tickArguments = _4 == null ? [] : Array.from(_4), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_4) {
    return arguments.length ? (tickValues = _4 == null ? null : Array.from(_4), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_4) {
    return arguments.length ? (tickFormat2 = _4, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_4) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_4, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_4) {
    return arguments.length ? (tickSizeInner = +_4, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_4) {
    return arguments.length ? (tickSizeOuter = +_4, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_4) {
    return arguments.length ? (tickPadding = +_4, axis2) : tickPadding;
  };
  axis2.offset = function(_4) {
    return arguments.length ? (offset2 = +_4, axis2) : offset2;
  };
  return axis2;
}
function axisBottom(scale2) {
  return axis(bottom, scale2);
}

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i6 = 0, n9 = arguments.length, _4 = {}, t6; i6 < n9; ++i6) {
    if (!(t6 = arguments[i6] + "") || t6 in _4 || /[\s.]/.test(t6))
      throw new Error("illegal type: " + t6);
    _4[t6] = [];
  }
  return new Dispatch(_4);
}
function Dispatch(_4) {
  this._ = _4;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t6) {
    var name = "", i6 = t6.indexOf(".");
    if (i6 >= 0)
      name = t6.slice(i6 + 1), t6 = t6.slice(0, i6);
    if (t6 && !types.hasOwnProperty(t6))
      throw new Error("unknown type: " + t6);
    return { type: t6, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _4 = this._, T5 = parseTypenames(typename + "", _4), t6, i6 = -1, n9 = T5.length;
    if (arguments.length < 2) {
      while (++i6 < n9)
        if ((t6 = (typename = T5[i6]).type) && (t6 = get4(_4[t6], typename.name)))
          return t6;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i6 < n9) {
      if (t6 = (typename = T5[i6]).type)
        _4[t6] = set(_4[t6], typename.name, callback);
      else if (callback == null)
        for (t6 in _4)
          _4[t6] = set(_4[t6], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy3 = {}, _4 = this._;
    for (var t6 in _4)
      copy3[t6] = _4[t6].slice();
    return new Dispatch(copy3);
  },
  call: function(type3, that) {
    if ((n9 = arguments.length - 2) > 0)
      for (var args = new Array(n9), i6 = 0, n9, t6; i6 < n9; ++i6)
        args[i6] = arguments[i6 + 2];
    if (!this._.hasOwnProperty(type3))
      throw new Error("unknown type: " + type3);
    for (t6 = this._[type3], i6 = 0, n9 = t6.length; i6 < n9; ++i6)
      t6[i6].value.apply(that, args);
  },
  apply: function(type3, that, args) {
    if (!this._.hasOwnProperty(type3))
      throw new Error("unknown type: " + type3);
    for (var t6 = this._[type3], i6 = 0, n9 = t6.length; i6 < n9; ++i6)
      t6[i6].value.apply(that, args);
  }
};
function get4(type3, name) {
  for (var i6 = 0, n9 = type3.length, c9; i6 < n9; ++i6) {
    if ((c9 = type3[i6]).name === name) {
      return c9.value;
    }
  }
}
function set(type3, name, callback) {
  for (var i6 = 0, n9 = type3.length; i6 < n9; ++i6) {
    if (type3[i6].name === name) {
      type3[i6] = noop, type3 = type3.slice(0, i6).concat(type3.slice(i6 + 1));
      break;
    }
  }
  if (callback != null)
    type3.push({ name, value: callback });
  return type3;
}
var dispatch_default = dispatch;

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i6 = prefix.indexOf(":");
  if (i6 >= 0 && (prefix = name.slice(0, i6)) !== "xmlns")
    name = name.slice(i6 + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups2 = this._groups, m5 = groups2.length, subgroups = new Array(m5), j5 = 0; j5 < m5; ++j5) {
    for (var group2 = groups2[j5], n9 = group2.length, subgroup = subgroups[j5] = new Array(n9), node, subnode, i6 = 0; i6 < n9; ++i6) {
      if ((node = group2[i6]) && (subnode = select.call(node, node.__data__, i6, group2))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i6] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array(x6) {
  return x6 == null ? [] : Array.isArray(x6) ? x6 : Array.from(x6);
}

// node_modules/d3-selection/src/selectorAll.js
function empty2() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty2 : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function")
    select = arrayAll(select);
  else
    select = selectorAll_default(select);
  for (var groups2 = this._groups, m5 = groups2.length, subgroups = [], parents = [], j5 = 0; j5 < m5; ++j5) {
    for (var group2 = groups2[j5], n9 = group2.length, node, i6 = 0; i6 < n9; ++i6) {
      if (node = group2[i6]) {
        subgroups.push(select.call(node, node.__data__, i6, group2));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups2 = this._groups, m5 = groups2.length, subgroups = new Array(m5), j5 = 0; j5 < m5; ++j5) {
    for (var group2 = groups2[j5], n9 = group2.length, subgroup = subgroups[j5] = [], node, i6 = 0; i6 < n9; ++i6) {
      if ((node = group2[i6]) && match.call(node, node.__data__, i6, group2)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default2(x6) {
  return function() {
    return x6;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group2, enter, update, exit, data) {
  var i6 = 0, node, groupLength = group2.length, dataLength = data.length;
  for (; i6 < dataLength; ++i6) {
    if (node = group2[i6]) {
      node.__data__ = data[i6];
      update[i6] = node;
    } else {
      enter[i6] = new EnterNode(parent, data[i6]);
    }
  }
  for (; i6 < groupLength; ++i6) {
    if (node = group2[i6]) {
      exit[i6] = node;
    }
  }
}
function bindKey(parent, group2, enter, update, exit, data, key) {
  var i6, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group2.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i6 = 0; i6 < groupLength; ++i6) {
    if (node = group2[i6]) {
      keyValues[i6] = keyValue = key.call(node, node.__data__, i6, group2) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i6] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i6 = 0; i6 < dataLength; ++i6) {
    keyValue = key.call(parent, data[i6], i6, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i6] = node;
      node.__data__ = data[i6];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i6] = new EnterNode(parent, data[i6]);
    }
  }
  for (i6 = 0; i6 < groupLength; ++i6) {
    if ((node = group2[i6]) && nodeByKeyValue.get(keyValues[i6]) === node) {
      exit[i6] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups2 = this._groups;
  if (typeof value !== "function")
    value = constant_default2(value);
  for (var m5 = groups2.length, update = new Array(m5), enter = new Array(m5), exit = new Array(m5), j5 = 0; j5 < m5; ++j5) {
    var parent = parents[j5], group2 = groups2[j5], groupLength = group2.length, data = arraylike(value.call(parent, parent && parent.__data__, j5, parents)), dataLength = data.length, enterGroup = enter[j5] = new Array(dataLength), updateGroup = update[j5] = new Array(dataLength), exitGroup = exit[j5] = new Array(groupLength);
    bind(parent, group2, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default2(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m12 = groups1.length, m5 = Math.min(m0, m12), merges = new Array(m0), j5 = 0; j5 < m5; ++j5) {
    for (var group0 = groups0[j5], group1 = groups1[j5], n9 = group0.length, merge3 = merges[j5] = new Array(n9), node, i6 = 0; i6 < n9; ++i6) {
      if (node = group0[i6] || group1[i6]) {
        merge3[i6] = node;
      }
    }
  }
  for (; j5 < m0; ++j5) {
    merges[j5] = groups0[j5];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups2 = this._groups, j5 = -1, m5 = groups2.length; ++j5 < m5; ) {
    for (var group2 = groups2[j5], i6 = group2.length - 1, next = group2[i6], node; --i6 >= 0; ) {
      if (node = group2[i6]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare)
    compare = ascending2;
  function compareNode(a7, b5) {
    return a7 && b5 ? compare(a7.__data__, b5.__data__) : !a7 - !b5;
  }
  for (var groups2 = this._groups, m5 = groups2.length, sortgroups = new Array(m5), j5 = 0; j5 < m5; ++j5) {
    for (var group2 = groups2[j5], n9 = group2.length, sortgroup = sortgroups[j5] = new Array(n9), node, i6 = 0; i6 < n9; ++i6) {
      if (node = group2[i6]) {
        sortgroup[i6] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending2(a7, b5) {
  return a7 < b5 ? -1 : a7 > b5 ? 1 : a7 >= b5 ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups2 = this._groups, j5 = 0, m5 = groups2.length; j5 < m5; ++j5) {
    for (var group2 = groups2[j5], i6 = 0, n9 = group2.length; i6 < n9; ++i6) {
      var node = group2[i6];
      if (node)
        return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups2 = this._groups, j5 = 0, m5 = groups2.length; j5 < m5; ++j5) {
    for (var group2 = groups2[j5], i6 = 0, n9 = group2.length, node; i6 < n9; ++i6) {
      if (node = group2[i6])
        callback.call(node, node.__data__, i6, group2);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v4 = value.apply(this, arguments);
    if (v4 == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v4);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v4 = value.apply(this, arguments);
    if (v4 == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v4);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v4 = value.apply(this, arguments);
    if (v4 == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v4, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v4 = value.apply(this, arguments);
    if (v4 == null)
      delete this[name];
    else
      this[name] = v4;
  };
}
function property_default2(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i6 = this._names.indexOf(name);
    if (i6 < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i6 = this._names.indexOf(name);
    if (i6 >= 0) {
      this._names.splice(i6, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names2) {
  var list = classList(node), i6 = -1, n9 = names2.length;
  while (++i6 < n9)
    list.add(names2[i6]);
}
function classedRemove(node, names2) {
  var list = classList(node), i6 = -1, n9 = names2.length;
  while (++i6 < n9)
    list.remove(names2[i6]);
}
function classedTrue(names2) {
  return function() {
    classedAdd(this, names2);
  };
}
function classedFalse(names2) {
  return function() {
    classedRemove(this, names2);
  };
}
function classedFunction(names2, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names2);
  };
}
function classed_default(name, value) {
  var names2 = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i6 = -1, n9 = names2.length;
    while (++i6 < n9)
      if (!list.contains(names2[i6]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names2, value));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v4 = value.apply(this, arguments);
    this.textContent = v4 == null ? "" : v4;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v4 = value.apply(this, arguments);
    this.innerHTML = v4 == null ? "" : v4;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create3 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create3.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create3 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create3.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone3 = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone3, this.nextSibling) : clone3;
}
function selection_cloneDeep() {
  var clone3 = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone3, this.nextSibling) : clone3;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t6) {
    var name = "", i6 = t6.indexOf(".");
    if (i6 >= 0)
      name = t6.slice(i6 + 1), t6 = t6.slice(0, i6);
    return { type: t6, name };
  });
}
function onRemove(typename) {
  return function() {
    var on2 = this.__on;
    if (!on2)
      return;
    for (var j5 = 0, i6 = -1, m5 = on2.length, o8; j5 < m5; ++j5) {
      if (o8 = on2[j5], (!typename.type || o8.type === typename.type) && o8.name === typename.name) {
        this.removeEventListener(o8.type, o8.listener, o8.options);
      } else {
        on2[++i6] = o8;
      }
    }
    if (++i6)
      on2.length = i6;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on2 = this.__on, o8, listener = contextListener(value);
    if (on2)
      for (var j5 = 0, m5 = on2.length; j5 < m5; ++j5) {
        if ((o8 = on2[j5]).type === typename.type && o8.name === typename.name) {
          this.removeEventListener(o8.type, o8.listener, o8.options);
          this.addEventListener(o8.type, o8.listener = listener, o8.options = options);
          o8.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o8 = { type: typename.type, name: typename.name, value, listener, options };
    if (!on2)
      this.__on = [o8];
    else
      on2.push(o8);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i6, n9 = typenames.length, t6;
  if (arguments.length < 2) {
    var on2 = this.node().__on;
    if (on2)
      for (var j5 = 0, m5 = on2.length, o8; j5 < m5; ++j5) {
        for (i6 = 0, o8 = on2[j5]; i6 < n9; ++i6) {
          if ((t6 = typenames[i6]).type === o8.type && t6.name === o8.name) {
            return o8.value;
          }
        }
      }
    return;
  }
  on2 = value ? onAdd : onRemove;
  for (i6 = 0; i6 < n9; ++i6)
    this.each(on2(typenames[i6], value, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type3, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type3, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type3, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type3, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type3, params) {
  return function() {
    return dispatchEvent(this, type3, params);
  };
}
function dispatchFunction(type3, params) {
  return function() {
    return dispatchEvent(this, type3, params.apply(this, arguments));
  };
}
function dispatch_default2(type3, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type3, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups2 = this._groups, j5 = 0, m5 = groups2.length; j5 < m5; ++j5) {
    for (var group2 = groups2[j5], i6 = 0, n9 = group2.length, node; i6 < n9; ++i6) {
      if (node = group2[i6])
        yield node;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root2 = [null];
function Selection(groups2, parents) {
  this._groups = groups2;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root2);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default2,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default2,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root2);
}

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent)
    event = sourceEvent;
  return event;
}

// node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
  event = sourceEvent_default(event);
  if (node === void 0)
    node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point6 = svg.createSVGPoint();
      point6.x = event.clientX, point6.y = event.clientY;
      point6 = point6.matrixTransform(node.getScreenCTM().inverse());
      return [point6.x, point6.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format3) {
  var m5, l7;
  format3 = (format3 + "").trim().toLowerCase();
  return (m5 = reHex.exec(format3)) ? (l7 = m5[1].length, m5 = parseInt(m5[1], 16), l7 === 6 ? rgbn(m5) : l7 === 3 ? new Rgb(m5 >> 8 & 15 | m5 >> 4 & 240, m5 >> 4 & 15 | m5 & 240, (m5 & 15) << 4 | m5 & 15, 1) : l7 === 8 ? rgba(m5 >> 24 & 255, m5 >> 16 & 255, m5 >> 8 & 255, (m5 & 255) / 255) : l7 === 4 ? rgba(m5 >> 12 & 15 | m5 >> 8 & 240, m5 >> 8 & 15 | m5 >> 4 & 240, m5 >> 4 & 15 | m5 & 240, ((m5 & 15) << 4 | m5 & 15) / 255) : null) : (m5 = reRgbInteger.exec(format3)) ? new Rgb(m5[1], m5[2], m5[3], 1) : (m5 = reRgbPercent.exec(format3)) ? new Rgb(m5[1] * 255 / 100, m5[2] * 255 / 100, m5[3] * 255 / 100, 1) : (m5 = reRgbaInteger.exec(format3)) ? rgba(m5[1], m5[2], m5[3], m5[4]) : (m5 = reRgbaPercent.exec(format3)) ? rgba(m5[1] * 255 / 100, m5[2] * 255 / 100, m5[3] * 255 / 100, m5[4]) : (m5 = reHslPercent.exec(format3)) ? hsla(m5[1], m5[2] / 100, m5[3] / 100, 1) : (m5 = reHslaPercent.exec(format3)) ? hsla(m5[1], m5[2] / 100, m5[3] / 100, m5[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n9) {
  return new Rgb(n9 >> 16 & 255, n9 >> 8 & 255, n9 & 255, 1);
}
function rgba(r6, g6, b5, a7) {
  if (a7 <= 0)
    r6 = g6 = b5 = NaN;
  return new Rgb(r6, g6, b5, a7);
}
function rgbConvert(o8) {
  if (!(o8 instanceof Color))
    o8 = color(o8);
  if (!o8)
    return new Rgb();
  o8 = o8.rgb();
  return new Rgb(o8.r, o8.g, o8.b, o8.opacity);
}
function rgb(r6, g6, b5, opacity2) {
  return arguments.length === 1 ? rgbConvert(r6) : new Rgb(r6, g6, b5, opacity2 == null ? 1 : opacity2);
}
function Rgb(r6, g6, b5, opacity2) {
  this.r = +r6;
  this.g = +g6;
  this.b = +b5;
  this.opacity = +opacity2;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k6) {
    k6 = k6 == null ? brighter : Math.pow(brighter, k6);
    return new Rgb(this.r * k6, this.g * k6, this.b * k6, this.opacity);
  },
  darker(k6) {
    k6 = k6 == null ? darker : Math.pow(darker, k6);
    return new Rgb(this.r * k6, this.g * k6, this.b * k6, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a7 = clampa(this.opacity);
  return `${a7 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a7 === 1 ? ")" : `, ${a7})`}`;
}
function clampa(opacity2) {
  return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h5, s8, l7, a7) {
  if (a7 <= 0)
    h5 = s8 = l7 = NaN;
  else if (l7 <= 0 || l7 >= 1)
    h5 = s8 = NaN;
  else if (s8 <= 0)
    h5 = NaN;
  return new Hsl(h5, s8, l7, a7);
}
function hslConvert(o8) {
  if (o8 instanceof Hsl)
    return new Hsl(o8.h, o8.s, o8.l, o8.opacity);
  if (!(o8 instanceof Color))
    o8 = color(o8);
  if (!o8)
    return new Hsl();
  if (o8 instanceof Hsl)
    return o8;
  o8 = o8.rgb();
  var r6 = o8.r / 255, g6 = o8.g / 255, b5 = o8.b / 255, min4 = Math.min(r6, g6, b5), max4 = Math.max(r6, g6, b5), h5 = NaN, s8 = max4 - min4, l7 = (max4 + min4) / 2;
  if (s8) {
    if (r6 === max4)
      h5 = (g6 - b5) / s8 + (g6 < b5) * 6;
    else if (g6 === max4)
      h5 = (b5 - r6) / s8 + 2;
    else
      h5 = (r6 - g6) / s8 + 4;
    s8 /= l7 < 0.5 ? max4 + min4 : 2 - max4 - min4;
    h5 *= 60;
  } else {
    s8 = l7 > 0 && l7 < 1 ? 0 : h5;
  }
  return new Hsl(h5, s8, l7, o8.opacity);
}
function hsl(h5, s8, l7, opacity2) {
  return arguments.length === 1 ? hslConvert(h5) : new Hsl(h5, s8, l7, opacity2 == null ? 1 : opacity2);
}
function Hsl(h5, s8, l7, opacity2) {
  this.h = +h5;
  this.s = +s8;
  this.l = +l7;
  this.opacity = +opacity2;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k6) {
    k6 = k6 == null ? brighter : Math.pow(brighter, k6);
    return new Hsl(this.h, this.s, this.l * k6, this.opacity);
  },
  darker(k6) {
    k6 = k6 == null ? darker : Math.pow(darker, k6);
    return new Hsl(this.h, this.s, this.l * k6, this.opacity);
  },
  rgb() {
    var h5 = this.h % 360 + (this.h < 0) * 360, s8 = isNaN(h5) || isNaN(this.s) ? 0 : this.s, l7 = this.l, m23 = l7 + (l7 < 0.5 ? l7 : 1 - l7) * s8, m12 = 2 * l7 - m23;
    return new Rgb(
      hsl2rgb(h5 >= 240 ? h5 - 240 : h5 + 120, m12, m23),
      hsl2rgb(h5, m12, m23),
      hsl2rgb(h5 < 120 ? h5 + 240 : h5 - 120, m12, m23),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a7 = clampa(this.opacity);
    return `${a7 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a7 === 1 ? ")" : `, ${a7})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h5, m12, m23) {
  return (h5 < 60 ? m12 + (m23 - m12) * h5 / 60 : h5 < 180 ? m23 : h5 < 240 ? m12 + (m23 - m12) * (240 - h5) / 60 : m12) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K2 = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t22 = 3 * t1 * t1;
var t32 = t1 * t1 * t1;
function labConvert(o8) {
  if (o8 instanceof Lab)
    return new Lab(o8.l, o8.a, o8.b, o8.opacity);
  if (o8 instanceof Hcl)
    return hcl2lab(o8);
  if (!(o8 instanceof Rgb))
    o8 = rgbConvert(o8);
  var r6 = rgb2lrgb(o8.r), g6 = rgb2lrgb(o8.g), b5 = rgb2lrgb(o8.b), y5 = xyz2lab((0.2225045 * r6 + 0.7168786 * g6 + 0.0606169 * b5) / Yn), x6, z5;
  if (r6 === g6 && g6 === b5)
    x6 = z5 = y5;
  else {
    x6 = xyz2lab((0.4360747 * r6 + 0.3850649 * g6 + 0.1430804 * b5) / Xn);
    z5 = xyz2lab((0.0139322 * r6 + 0.0971045 * g6 + 0.7141733 * b5) / Zn);
  }
  return new Lab(116 * y5 - 16, 500 * (x6 - y5), 200 * (y5 - z5), o8.opacity);
}
function lab(l7, a7, b5, opacity2) {
  return arguments.length === 1 ? labConvert(l7) : new Lab(l7, a7, b5, opacity2 == null ? 1 : opacity2);
}
function Lab(l7, a7, b5, opacity2) {
  this.l = +l7;
  this.a = +a7;
  this.b = +b5;
  this.opacity = +opacity2;
}
define_default(Lab, lab, extend(Color, {
  brighter(k6) {
    return new Lab(this.l + K2 * (k6 == null ? 1 : k6), this.a, this.b, this.opacity);
  },
  darker(k6) {
    return new Lab(this.l - K2 * (k6 == null ? 1 : k6), this.a, this.b, this.opacity);
  },
  rgb() {
    var y5 = (this.l + 16) / 116, x6 = isNaN(this.a) ? y5 : y5 + this.a / 500, z5 = isNaN(this.b) ? y5 : y5 - this.b / 200;
    x6 = Xn * lab2xyz(x6);
    y5 = Yn * lab2xyz(y5);
    z5 = Zn * lab2xyz(z5);
    return new Rgb(
      lrgb2rgb(3.1338561 * x6 - 1.6168667 * y5 - 0.4906146 * z5),
      lrgb2rgb(-0.9787684 * x6 + 1.9161415 * y5 + 0.033454 * z5),
      lrgb2rgb(0.0719453 * x6 - 0.2289914 * y5 + 1.4052427 * z5),
      this.opacity
    );
  }
}));
function xyz2lab(t6) {
  return t6 > t32 ? Math.pow(t6, 1 / 3) : t6 / t22 + t0;
}
function lab2xyz(t6) {
  return t6 > t1 ? t6 * t6 * t6 : t22 * (t6 - t0);
}
function lrgb2rgb(x6) {
  return 255 * (x6 <= 31308e-7 ? 12.92 * x6 : 1.055 * Math.pow(x6, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x6) {
  return (x6 /= 255) <= 0.04045 ? x6 / 12.92 : Math.pow((x6 + 0.055) / 1.055, 2.4);
}
function hclConvert(o8) {
  if (o8 instanceof Hcl)
    return new Hcl(o8.h, o8.c, o8.l, o8.opacity);
  if (!(o8 instanceof Lab))
    o8 = labConvert(o8);
  if (o8.a === 0 && o8.b === 0)
    return new Hcl(NaN, 0 < o8.l && o8.l < 100 ? 0 : NaN, o8.l, o8.opacity);
  var h5 = Math.atan2(o8.b, o8.a) * degrees;
  return new Hcl(h5 < 0 ? h5 + 360 : h5, Math.sqrt(o8.a * o8.a + o8.b * o8.b), o8.l, o8.opacity);
}
function hcl(h5, c9, l7, opacity2) {
  return arguments.length === 1 ? hclConvert(h5) : new Hcl(h5, c9, l7, opacity2 == null ? 1 : opacity2);
}
function Hcl(h5, c9, l7, opacity2) {
  this.h = +h5;
  this.c = +c9;
  this.l = +l7;
  this.opacity = +opacity2;
}
function hcl2lab(o8) {
  if (isNaN(o8.h))
    return new Lab(o8.l, 0, 0, o8.opacity);
  var h5 = o8.h * radians;
  return new Lab(o8.l, Math.cos(h5) * o8.c, Math.sin(h5) * o8.c, o8.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k6) {
    return new Hcl(this.h, this.c, this.l + K2 * (k6 == null ? 1 : k6), this.opacity);
  },
  darker(k6) {
    return new Hcl(this.h, this.c, this.l - K2 * (k6 == null ? 1 : k6), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A5 = -0.14861;
var B5 = 1.78277;
var C4 = -0.29227;
var D3 = -0.90649;
var E4 = 1.97294;
var ED = E4 * D3;
var EB = E4 * B5;
var BC_DA = B5 * C4 - D3 * A5;
function cubehelixConvert(o8) {
  if (o8 instanceof Cubehelix)
    return new Cubehelix(o8.h, o8.s, o8.l, o8.opacity);
  if (!(o8 instanceof Rgb))
    o8 = rgbConvert(o8);
  var r6 = o8.r / 255, g6 = o8.g / 255, b5 = o8.b / 255, l7 = (BC_DA * b5 + ED * r6 - EB * g6) / (BC_DA + ED - EB), bl = b5 - l7, k6 = (E4 * (g6 - l7) - C4 * bl) / D3, s8 = Math.sqrt(k6 * k6 + bl * bl) / (E4 * l7 * (1 - l7)), h5 = s8 ? Math.atan2(k6, bl) * degrees - 120 : NaN;
  return new Cubehelix(h5 < 0 ? h5 + 360 : h5, s8, l7, o8.opacity);
}
function cubehelix(h5, s8, l7, opacity2) {
  return arguments.length === 1 ? cubehelixConvert(h5) : new Cubehelix(h5, s8, l7, opacity2 == null ? 1 : opacity2);
}
function Cubehelix(h5, s8, l7, opacity2) {
  this.h = +h5;
  this.s = +s8;
  this.l = +l7;
  this.opacity = +opacity2;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k6) {
    k6 = k6 == null ? brighter : Math.pow(brighter, k6);
    return new Cubehelix(this.h, this.s, this.l * k6, this.opacity);
  },
  darker(k6) {
    k6 = k6 == null ? darker : Math.pow(darker, k6);
    return new Cubehelix(this.h, this.s, this.l * k6, this.opacity);
  },
  rgb() {
    var h5 = isNaN(this.h) ? 0 : (this.h + 120) * radians, l7 = +this.l, a7 = isNaN(this.s) ? 0 : this.s * l7 * (1 - l7), cosh = Math.cos(h5), sinh = Math.sin(h5);
    return new Rgb(
      255 * (l7 + a7 * (A5 * cosh + B5 * sinh)),
      255 * (l7 + a7 * (C4 * cosh + D3 * sinh)),
      255 * (l7 + a7 * (E4 * cosh)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v22, v32) {
  var t23 = t13 * t13, t33 = t23 * t13;
  return ((1 - 3 * t13 + 3 * t23 - t33) * v0 + (4 - 6 * t23 + 3 * t33) * v1 + (1 + 3 * t13 + 3 * t23 - 3 * t33) * v22 + t33 * v32) / 6;
}
function basis_default(values2) {
  var n9 = values2.length - 1;
  return function(t6) {
    var i6 = t6 <= 0 ? t6 = 0 : t6 >= 1 ? (t6 = 1, n9 - 1) : Math.floor(t6 * n9), v1 = values2[i6], v22 = values2[i6 + 1], v0 = i6 > 0 ? values2[i6 - 1] : 2 * v1 - v22, v32 = i6 < n9 - 1 ? values2[i6 + 2] : 2 * v22 - v1;
    return basis((t6 - i6 / n9) * n9, v0, v1, v22, v32);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values2) {
  var n9 = values2.length;
  return function(t6) {
    var i6 = Math.floor(((t6 %= 1) < 0 ? ++t6 : t6) * n9), v0 = values2[(i6 + n9 - 1) % n9], v1 = values2[i6 % n9], v22 = values2[(i6 + 1) % n9], v32 = values2[(i6 + 2) % n9];
    return basis((t6 - i6 / n9) * n9, v0, v1, v22, v32);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default3 = (x6) => () => x6;

// node_modules/d3-interpolate/src/color.js
function linear(a7, d6) {
  return function(t6) {
    return a7 + t6 * d6;
  };
}
function exponential(a7, b5, y5) {
  return a7 = Math.pow(a7, y5), b5 = Math.pow(b5, y5) - a7, y5 = 1 / y5, function(t6) {
    return Math.pow(a7 + t6 * b5, y5);
  };
}
function hue(a7, b5) {
  var d6 = b5 - a7;
  return d6 ? linear(a7, d6 > 180 || d6 < -180 ? d6 - 360 * Math.round(d6 / 360) : d6) : constant_default3(isNaN(a7) ? b5 : a7);
}
function gamma(y5) {
  return (y5 = +y5) === 1 ? nogamma : function(a7, b5) {
    return b5 - a7 ? exponential(a7, b5, y5) : constant_default3(isNaN(a7) ? b5 : a7);
  };
}
function nogamma(a7, b5) {
  var d6 = b5 - a7;
  return d6 ? linear(a7, d6) : constant_default3(isNaN(a7) ? b5 : a7);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y5) {
  var color3 = gamma(y5);
  function rgb2(start2, end) {
    var r6 = color3((start2 = rgb(start2)).r, (end = rgb(end)).r), g6 = color3(start2.g, end.g), b5 = color3(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);
    return function(t6) {
      start2.r = r6(t6);
      start2.g = g6(t6);
      start2.b = b5(t6);
      start2.opacity = opacity2(t6);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors2) {
    var n9 = colors2.length, r6 = new Array(n9), g6 = new Array(n9), b5 = new Array(n9), i6, color3;
    for (i6 = 0; i6 < n9; ++i6) {
      color3 = rgb(colors2[i6]);
      r6[i6] = color3.r || 0;
      g6[i6] = color3.g || 0;
      b5[i6] = color3.b || 0;
    }
    r6 = spline(r6);
    g6 = spline(g6);
    b5 = spline(b5);
    color3.opacity = 1;
    return function(t6) {
      color3.r = r6(t6);
      color3.g = g6(t6);
      color3.b = b5(t6);
      return color3 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a7, b5) {
  if (!b5)
    b5 = [];
  var n9 = a7 ? Math.min(b5.length, a7.length) : 0, c9 = b5.slice(), i6;
  return function(t6) {
    for (i6 = 0; i6 < n9; ++i6)
      c9[i6] = a7[i6] * (1 - t6) + b5[i6] * t6;
    return c9;
  };
}
function isNumberArray(x6) {
  return ArrayBuffer.isView(x6) && !(x6 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a7, b5) {
  var nb = b5 ? b5.length : 0, na = a7 ? Math.min(nb, a7.length) : 0, x6 = new Array(na), c9 = new Array(nb), i6;
  for (i6 = 0; i6 < na; ++i6)
    x6[i6] = value_default(a7[i6], b5[i6]);
  for (; i6 < nb; ++i6)
    c9[i6] = b5[i6];
  return function(t6) {
    for (i6 = 0; i6 < na; ++i6)
      c9[i6] = x6[i6](t6);
    return c9;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a7, b5) {
  var d6 = /* @__PURE__ */ new Date();
  return a7 = +a7, b5 = +b5, function(t6) {
    return d6.setTime(a7 * (1 - t6) + b5 * t6), d6;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a7, b5) {
  return a7 = +a7, b5 = +b5, function(t6) {
    return a7 * (1 - t6) + b5 * t6;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a7, b5) {
  var i6 = {}, c9 = {}, k6;
  if (a7 === null || typeof a7 !== "object")
    a7 = {};
  if (b5 === null || typeof b5 !== "object")
    b5 = {};
  for (k6 in b5) {
    if (k6 in a7) {
      i6[k6] = value_default(a7[k6], b5[k6]);
    } else {
      c9[k6] = b5[k6];
    }
  }
  return function(t6) {
    for (k6 in i6)
      c9[k6] = i6[k6](t6);
    return c9;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b5) {
  return function() {
    return b5;
  };
}
function one(b5) {
  return function(t6) {
    return b5(t6) + "";
  };
}
function string_default(a7, b5) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i6 = -1, s8 = [], q4 = [];
  a7 = a7 + "", b5 = b5 + "";
  while ((am = reA.exec(a7)) && (bm = reB.exec(b5))) {
    if ((bs = bm.index) > bi) {
      bs = b5.slice(bi, bs);
      if (s8[i6])
        s8[i6] += bs;
      else
        s8[++i6] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s8[i6])
        s8[i6] += bm;
      else
        s8[++i6] = bm;
    } else {
      s8[++i6] = null;
      q4.push({ i: i6, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b5.length) {
    bs = b5.slice(bi);
    if (s8[i6])
      s8[i6] += bs;
    else
      s8[++i6] = bs;
  }
  return s8.length < 2 ? q4[0] ? one(q4[0].x) : zero2(b5) : (b5 = q4.length, function(t6) {
    for (var i7 = 0, o8; i7 < b5; ++i7)
      s8[(o8 = q4[i7]).i] = o8.x(t6);
    return s8.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a7, b5) {
  var t6 = typeof b5, c9;
  return b5 == null || t6 === "boolean" ? constant_default3(b5) : (t6 === "number" ? number_default : t6 === "string" ? (c9 = color(b5)) ? (b5 = c9, rgb_default) : string_default : b5 instanceof color ? rgb_default : b5 instanceof Date ? date_default : isNumberArray(b5) ? numberArray_default : Array.isArray(b5) ? genericArray : typeof b5.valueOf !== "function" && typeof b5.toString !== "function" || isNaN(b5) ? object_default : number_default)(a7, b5);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a7, b5) {
  return a7 = +a7, b5 = +b5, function(t6) {
    return Math.round(a7 * (1 - t6) + b5 * t6);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity3 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a7, b5, c9, d6, e9, f4) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a7 * a7 + b5 * b5))
    a7 /= scaleX, b5 /= scaleX;
  if (skewX = a7 * c9 + b5 * d6)
    c9 -= a7 * skewX, d6 -= b5 * skewX;
  if (scaleY = Math.sqrt(c9 * c9 + d6 * d6))
    c9 /= scaleY, d6 /= scaleY, skewX /= scaleY;
  if (a7 * d6 < b5 * c9)
    a7 = -a7, b5 = -b5, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e9,
    translateY: f4,
    rotate: Math.atan2(b5, a7) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m5 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m5.isIdentity ? identity3 : decompose_default(m5.a, m5.b, m5.c, m5.d, m5.e, m5.f);
}
function parseSvg(value) {
  if (value == null)
    return identity3;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity3;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse3, pxComma, pxParen, degParen) {
  function pop(s8) {
    return s8.length ? s8.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s8, q4) {
    if (xa !== xb || ya !== yb) {
      var i6 = s8.push("translate(", null, pxComma, null, pxParen);
      q4.push({ i: i6 - 4, x: number_default(xa, xb) }, { i: i6 - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s8.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a7, b5, s8, q4) {
    if (a7 !== b5) {
      if (a7 - b5 > 180)
        b5 += 360;
      else if (b5 - a7 > 180)
        a7 += 360;
      q4.push({ i: s8.push(pop(s8) + "rotate(", null, degParen) - 2, x: number_default(a7, b5) });
    } else if (b5) {
      s8.push(pop(s8) + "rotate(" + b5 + degParen);
    }
  }
  function skewX(a7, b5, s8, q4) {
    if (a7 !== b5) {
      q4.push({ i: s8.push(pop(s8) + "skewX(", null, degParen) - 2, x: number_default(a7, b5) });
    } else if (b5) {
      s8.push(pop(s8) + "skewX(" + b5 + degParen);
    }
  }
  function scale2(xa, ya, xb, yb, s8, q4) {
    if (xa !== xb || ya !== yb) {
      var i6 = s8.push(pop(s8) + "scale(", null, ",", null, ")");
      q4.push({ i: i6 - 4, x: number_default(xa, xb) }, { i: i6 - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s8.push(pop(s8) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a7, b5) {
    var s8 = [], q4 = [];
    a7 = parse3(a7), b5 = parse3(b5);
    translate(a7.translateX, a7.translateY, b5.translateX, b5.translateY, s8, q4);
    rotate(a7.rotate, b5.rotate, s8, q4);
    skewX(a7.skewX, b5.skewX, s8, q4);
    scale2(a7.scaleX, a7.scaleY, b5.scaleX, b5.scaleY, s8, q4);
    a7 = b5 = null;
    return function(t6) {
      var i6 = -1, n9 = q4.length, o8;
      while (++i6 < n9)
        s8[(o8 = q4[i6]).i] = o8.x(t6);
      return s8.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start2, end) {
    var h5 = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s8 = nogamma(start2.s, end.s), l7 = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
    return function(t6) {
      start2.h = h5(t6);
      start2.s = s8(t6);
      start2.l = l7(t6);
      start2.opacity = opacity2(t6);
      return start2 + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/lab.js
function lab2(start2, end) {
  var l7 = nogamma((start2 = lab(start2)).l, (end = lab(end)).l), a7 = nogamma(start2.a, end.a), b5 = nogamma(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);
  return function(t6) {
    start2.l = l7(t6);
    start2.a = a7(t6);
    start2.b = b5(t6);
    start2.opacity = opacity2(t6);
    return start2 + "";
  };
}

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start2, end) {
    var h5 = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c9 = nogamma(start2.c, end.c), l7 = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
    return function(t6) {
      start2.h = h5(t6);
      start2.c = c9(t6);
      start2.l = l7(t6);
      start2.opacity = opacity2(t6);
      return start2 + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y5) {
    y5 = +y5;
    function cubehelix3(start2, end) {
      var h5 = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s8 = nogamma(start2.s, end.s), l7 = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
      return function(t6) {
        start2.h = h5(t6);
        start2.s = s8(t6);
        start2.l = l7(Math.pow(t6, y5));
        start2.opacity = opacity2(t6);
        return start2 + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate2, values2) {
  if (values2 === void 0)
    values2 = interpolate2, interpolate2 = value_default;
  var i6 = 0, n9 = values2.length - 1, v4 = values2[0], I4 = new Array(n9 < 0 ? 0 : n9);
  while (i6 < n9)
    I4[i6] = interpolate2(v4, v4 = values2[++i6]);
  return function(t6) {
    var i7 = Math.max(0, Math.min(n9 - 1, Math.floor(t6 *= n9)));
    return I4[i7](t6 - i7);
  };
}

// node_modules/d3-interpolate/src/quantize.js
function quantize_default(interpolator, n9) {
  var samples = new Array(n9);
  for (var i6 = 0; i6 < n9; ++i6)
    samples[i6] = interpolator(i6 / (n9 - 1));
  return samples;
}

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f4) {
  setTimeout(f4, 17);
};
function now2() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time2) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now2() : +time2) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time2) {
  var t6 = new Timer();
  t6.restart(callback, delay, time2);
  return t6;
}
function timerFlush() {
  now2();
  ++frame;
  var t6 = taskHead, e9;
  while (t6) {
    if ((e9 = clockNow - t6._time) >= 0)
      t6._call.call(void 0, e9);
    t6 = t6._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now3 = clock.now(), delay = now3 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now3;
}
function nap() {
  var t03, t13 = taskHead, t23, time2 = Infinity;
  while (t13) {
    if (t13._call) {
      if (time2 > t13._time)
        time2 = t13._time;
      t03 = t13, t13 = t13._next;
    } else {
      t23 = t13._next, t13._next = null;
      t13 = t03 ? t03._next = t23 : taskHead = t23;
    }
  }
  taskTail = t03;
  sleep(time2);
}
function sleep(time2) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity)
      timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time2) {
  var t6 = new Timer();
  delay = delay == null ? 0 : +delay;
  t6.restart((elapsed) => {
    t6.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t6;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index2, group2, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name,
    index: index2,
    // For context during callback.
    group: group2,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule = get5(node, id2);
  if (schedule.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get5(node, id2);
  if (schedule.state > STARTED)
    throw new Error("too late; already running");
  return schedule;
}
function get5(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2]))
    throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule, 0, self2.time);
  function schedule(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed)
      start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i6, j5, n9, o8;
    if (self2.state !== SCHEDULED)
      return stop();
    for (i6 in schedules) {
      o8 = schedules[i6];
      if (o8.name !== self2.name)
        continue;
      if (o8.state === STARTED)
        return timeout_default(start2);
      if (o8.state === RUNNING) {
        o8.state = ENDED;
        o8.timer.stop();
        o8.on.call("interrupt", node, node.__data__, o8.index, o8.group);
        delete schedules[i6];
      } else if (+i6 < id2) {
        o8.state = ENDED;
        o8.timer.stop();
        o8.on.call("cancel", node, node.__data__, o8.index, o8.group);
        delete schedules[i6];
      }
    }
    timeout_default(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING)
      return;
    self2.state = STARTED;
    tween = new Array(n9 = self2.tween.length);
    for (i6 = 0, j5 = -1; i6 < n9; ++i6) {
      if (o8 = self2.tween[i6].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j5] = o8;
      }
    }
    tween.length = j5 + 1;
  }
  function tick(elapsed) {
    var t6 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i6 = -1, n9 = tween.length;
    while (++i6 < n9) {
      tween[i6].call(node, t6);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i6 in schedules)
      return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty3 = true, i6;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i6 in schedules) {
    if ((schedule = schedules[i6]).name !== name) {
      empty3 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i6];
  }
  if (empty3)
    delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i6 = 0, n9 = tween1.length; i6 < n9; ++i6) {
        if (tween1[i6].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i6, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t6 = { name, value }, i6 = 0, n9 = tween1.length; i6 < n9; ++i6) {
        if (tween1[i6].name === name) {
          tween1[i6] = t6;
          break;
        }
      }
      if (i6 === n9)
        tween1.push(t6);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get5(this.node(), id2).tween;
    for (var i6 = 0, n9 = tween.length, t6; i6 < n9; ++i6) {
      if ((t6 = tween[i6]).name === name) {
        return t6.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get5(node, id2).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a7, b5) {
  var c9;
  return (typeof b5 === "number" ? number_default : b5 instanceof color ? rgb_default : (c9 = color(b5)) ? (b5 = c9, rgb_default) : string_default)(a7, b5);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i6 = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i6, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i6, value));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i6) {
  return function(t6) {
    this.setAttribute(name, i6.call(this, t6));
  };
}
function attrInterpolateNS(fullname, i6) {
  return function(t6) {
    this.setAttributeNS(fullname.space, fullname.local, i6.call(this, t6));
  };
}
function attrTweenNS(fullname, value) {
  var t03, i0;
  function tween() {
    var i6 = value.apply(this, arguments);
    if (i6 !== i0)
      t03 = (i0 = i6) && attrInterpolateNS(fullname, i6);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t03, i0;
  function tween() {
    var i6 = value.apply(this, arguments);
    if (i6 !== i0)
      t03 = (i0 = i6) && attrInterpolate(name, i6);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get5(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get5(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get5(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v4 = value.apply(this, arguments);
    if (typeof v4 !== "function")
      throw new Error();
    set2(this, id2).ease = v4;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups2 = this._groups, m5 = groups2.length, subgroups = new Array(m5), j5 = 0; j5 < m5; ++j5) {
    for (var group2 = groups2[j5], n9 = group2.length, subgroup = subgroups[j5] = [], node, i6 = 0; i6 < n9; ++i6) {
      if ((node = group2[i6]) && match.call(node, node.__data__, i6, group2)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default3(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m12 = groups1.length, m5 = Math.min(m0, m12), merges = new Array(m0), j5 = 0; j5 < m5; ++j5) {
    for (var group0 = groups0[j5], group1 = groups1[j5], n9 = group0.length, merge3 = merges[j5] = new Array(n9), node, i6 = 0; i6 < n9; ++i6) {
      if (node = group0[i6] || group1[i6]) {
        merge3[i6] = node;
      }
    }
  }
  for (; j5 < m0; ++j5) {
    merges[j5] = groups0[j5];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t6) {
    var i6 = t6.indexOf(".");
    if (i6 >= 0)
      t6 = t6.slice(0, i6);
    return !t6 || t6 === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set2;
  return function() {
    var schedule = sit(this, id2), on2 = schedule.on;
    if (on2 !== on0)
      (on1 = (on0 = on2).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get5(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i6 in this.__transition)
      if (+i6 !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups2 = this._groups, m5 = groups2.length, subgroups = new Array(m5), j5 = 0; j5 < m5; ++j5) {
    for (var group2 = groups2[j5], n9 = group2.length, subgroup = subgroups[j5] = new Array(n9), node, subnode, i6 = 0; i6 < n9; ++i6) {
      if ((node = group2[i6]) && (subnode = select.call(node, node.__data__, i6, group2))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i6] = subnode;
        schedule_default(subgroup[i6], name, id2, i6, subgroup, get5(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default2(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selectorAll_default(select);
  for (var groups2 = this._groups, m5 = groups2.length, subgroups = [], parents = [], j5 = 0; j5 < m5; ++j5) {
    for (var group2 = groups2[j5], n9 = group2.length, node, i6 = 0; i6 < n9; ++i6) {
      if (node = group2[i6]) {
        for (var children2 = select.call(node, node.__data__, i6, group2), child, inherit3 = get5(node, id2), k6 = 0, l7 = children2.length; k6 < l7; ++k6) {
          if (child = children2[k6]) {
            schedule_default(child, name, id2, k6, children2, inherit3);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule = set2(this, id2), on2 = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
    if (on2 !== on0 || listener0 !== listener)
      (on1 = (on0 = on2).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i6 = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i6)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i6, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i6, value), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i6, priority) {
  return function(t6) {
    this.style.setProperty(name, i6.call(this, t6), priority);
  };
}
function styleTween(name, value, priority) {
  var t6, i0;
  function tween() {
    var i6 = value.apply(this, arguments);
    if (i6 !== i0)
      t6 = (i0 = i6) && styleInterpolate(name, i6, priority);
    return t6;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i6) {
  return function(t6) {
    this.textContent = i6.call(this, t6);
  };
}
function textTween(value) {
  var t03, i0;
  function tween() {
    var i6 = value.apply(this, arguments);
    if (i6 !== i0)
      t03 = (i0 = i6) && textInterpolate(i6);
    return t03;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups2 = this._groups, m5 = groups2.length, j5 = 0; j5 < m5; ++j5) {
    for (var group2 = groups2[j5], n9 = group2.length, node, i6 = 0; i6 < n9; ++i6) {
      if (node = group2[i6]) {
        var inherit3 = get5(node, id0);
        schedule_default(node, name, id1, i6, group2, {
          time: inherit3.time + inherit3.delay + inherit3.duration,
          delay: 0,
          duration: inherit3.duration,
          ease: inherit3.ease
        });
      }
    }
  }
  return new Transition(groups2, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on2 = schedule.on;
      if (on2 !== on0) {
        on1 = (on0 = on2).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0)
      resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups2, parents, name, id2) {
  this._groups = groups2;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default2,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default3,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t6) {
  return ((t6 *= 2) <= 1 ? t6 * t6 * t6 : (t6 -= 2) * t6 * t6 + 2) / 2;
}

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now2(), name = name == null ? null : name + "";
  }
  for (var groups2 = this._groups, m5 = groups2.length, j5 = 0; j5 < m5; ++j5) {
    for (var group2 = groups2[j5], n9 = group2.length, node, i6 = 0; i6 < n9; ++i6) {
      if (node = group2[i6]) {
        schedule_default(node, name, id2, i6, group2, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups2, this._parents, name, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-brush/src/brush.js
var { abs, max: max2, min: min2 } = Math;
function number1(e9) {
  return [+e9[0], +e9[1]];
}
function number22(e9) {
  return [number1(e9[0]), number1(e9[1])];
}
var X2 = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x6, e9) {
    return x6 == null ? null : [[+x6[0], e9[0][1]], [+x6[1], e9[1][1]]];
  },
  output: function(xy2) {
    return xy2 && [xy2[0][0], xy2[1][0]];
  }
};
var Y2 = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y5, e9) {
    return y5 == null ? null : [[e9[0][0], +y5[0]], [e9[1][0], +y5[1]]];
  },
  output: function(xy2) {
    return xy2 && [xy2[0][1], xy2[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy2) {
    return xy2 == null ? null : number22(xy2);
  },
  output: function(xy2) {
    return xy2;
  }
};
function type(t6) {
  return { type: t6 };
}

// node_modules/d3-path/src/path.js
var pi = Math.PI;
var tau = 2 * pi;
var epsilon2 = 1e-6;
var tauEpsilon = tau - epsilon2;
function append(strings) {
  this._ += strings[0];
  for (let i6 = 1, n9 = strings.length; i6 < n9; ++i6) {
    this._ += arguments[i6] + strings[i6];
  }
}
function appendRound(digits) {
  let d6 = Math.floor(digits);
  if (!(d6 >= 0))
    throw new Error(`invalid digits: ${digits}`);
  if (d6 > 15)
    return append;
  const k6 = 10 ** d6;
  return function(strings) {
    this._ += strings[0];
    for (let i6 = 1, n9 = strings.length; i6 < n9; ++i6) {
      this._ += Math.round(arguments[i6] * k6) / k6 + strings[i6];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x6, y5) {
    this._append`M${this._x0 = this._x1 = +x6},${this._y0 = this._y1 = +y5}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x6, y5) {
    this._append`L${this._x1 = +x6},${this._y1 = +y5}`;
  }
  quadraticCurveTo(x12, y12, x6, y5) {
    this._append`Q${+x12},${+y12},${this._x1 = +x6},${this._y1 = +y5}`;
  }
  bezierCurveTo(x12, y12, x22, y22, x6, y5) {
    this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x6},${this._y1 = +y5}`;
  }
  arcTo(x12, y12, x22, y22, r6) {
    x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r6 = +r6;
    if (r6 < 0)
      throw new Error(`negative radius: ${r6}`);
    let x05 = this._x1, y05 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x05 - x12, y01 = y05 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x12},${this._y1 = y12}`;
    } else if (!(l01_2 > epsilon2))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r6) {
      this._append`L${this._x1 = x12},${this._y1 = y12}`;
    } else {
      let x20 = x22 - x05, y20 = y22 - y05, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l7 = r6 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l7 / l01, t21 = l7 / l21;
      if (Math.abs(t01 - 1) > epsilon2) {
        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
      }
      this._append`A${r6},${r6},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
    }
  }
  arc(x6, y5, r6, a0, a1, ccw) {
    x6 = +x6, y5 = +y5, r6 = +r6, ccw = !!ccw;
    if (r6 < 0)
      throw new Error(`negative radius: ${r6}`);
    let dx = r6 * Math.cos(a0), dy = r6 * Math.sin(a0), x05 = x6 + dx, y05 = y5 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x05},${y05}`;
    } else if (Math.abs(this._x1 - x05) > epsilon2 || Math.abs(this._y1 - y05) > epsilon2) {
      this._append`L${x05},${y05}`;
    }
    if (!r6)
      return;
    if (da < 0)
      da = da % tau + tau;
    if (da > tauEpsilon) {
      this._append`A${r6},${r6},0,1,${cw},${x6 - dx},${y5 - dy}A${r6},${r6},0,1,${cw},${this._x1 = x05},${this._y1 = y05}`;
    } else if (da > epsilon2) {
      this._append`A${r6},${r6},0,${+(da >= pi)},${cw},${this._x1 = x6 + r6 * Math.cos(a1)},${this._y1 = y5 + r6 * Math.sin(a1)}`;
    }
  }
  rect(x6, y5, w5, h5) {
    this._append`M${this._x0 = this._x1 = +x6},${this._y0 = this._y1 = +y5}h${w5 = +w5}v${+h5}h${-w5}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;
function pathRound(digits = 3) {
  return new Path(+digits);
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x6) {
  return Math.abs(x6 = Math.round(x6)) >= 1e21 ? x6.toLocaleString("en").replace(/,/g, "") : x6.toString(10);
}
function formatDecimalParts(x6, p5) {
  if ((i6 = (x6 = p5 ? x6.toExponential(p5 - 1) : x6.toExponential()).indexOf("e")) < 0)
    return null;
  var i6, coefficient = x6.slice(0, i6);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x6.slice(i6 + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x6) {
  return x6 = formatDecimalParts(Math.abs(x6)), x6 ? x6[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i6 = value.length, t6 = [], j5 = 0, g6 = grouping[0], length3 = 0;
    while (i6 > 0 && g6 > 0) {
      if (length3 + g6 + 1 > width)
        g6 = Math.max(1, width - length3);
      t6.push(value.substring(i6 -= g6, i6 + g6));
      if ((length3 += g6 + 1) > width)
        break;
      g6 = grouping[j5 = (j5 + 1) % grouping.length];
    }
    return t6.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i6) {
      return numerals[+i6];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s8) {
  out:
    for (var n9 = s8.length, i6 = 1, i0 = -1, i1; i6 < n9; ++i6) {
      switch (s8[i6]) {
        case ".":
          i0 = i1 = i6;
          break;
        case "0":
          if (i0 === 0)
            i0 = i6;
          i1 = i6;
          break;
        default:
          if (!+s8[i6])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s8.slice(0, i0) + s8.slice(i1 + 1) : s8;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x6, p5) {
  var d6 = formatDecimalParts(x6, p5);
  if (!d6)
    return x6 + "";
  var coefficient = d6[0], exponent = d6[1], i6 = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n9 = coefficient.length;
  return i6 === n9 ? coefficient : i6 > n9 ? coefficient + new Array(i6 - n9 + 1).join("0") : i6 > 0 ? coefficient.slice(0, i6) + "." + coefficient.slice(i6) : "0." + new Array(1 - i6).join("0") + formatDecimalParts(x6, Math.max(0, p5 + i6 - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x6, p5) {
  var d6 = formatDecimalParts(x6, p5);
  if (!d6)
    return x6 + "";
  var coefficient = d6[0], exponent = d6[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x6, p5) => (x6 * 100).toFixed(p5),
  "b": (x6) => Math.round(x6).toString(2),
  "c": (x6) => x6 + "",
  "d": formatDecimal_default,
  "e": (x6, p5) => x6.toExponential(p5),
  "f": (x6, p5) => x6.toFixed(p5),
  "g": (x6, p5) => x6.toPrecision(p5),
  "o": (x6) => Math.round(x6).toString(8),
  "p": (x6, p5) => formatRounded_default(x6 * 100, p5),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x6) => Math.round(x6).toString(16).toUpperCase(),
  "x": (x6) => Math.round(x6).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default3(x6) {
  return x6;
}

// node_modules/d3-format/src/locale.js
var map2 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group2 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default3 : formatGroup_default(map2.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default3 : formatNumerals_default(map2.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "\u2212" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol2 = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type3 = specifier.type;
    if (type3 === "n")
      comma = true, type3 = "g";
    else if (!formatTypes_default[type3])
      precision === void 0 && (precision = 12), trim = true, type3 = "g";
    if (zero3 || fill === "0" && align === "=")
      zero3 = true, fill = "0", align = "=";
    var prefix = symbol2 === "$" ? currencyPrefix : symbol2 === "#" && /[boxX]/.test(type3) ? "0" + type3.toLowerCase() : "", suffix = symbol2 === "$" ? currencySuffix : /[%p]/.test(type3) ? percent : "";
    var formatType = formatTypes_default[type3], maybeSuffix = /[defgprs%]/.test(type3);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type3) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format3(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i6, n9, c9;
      if (type3 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign3 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type3 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i6 = -1, n9 = value.length;
          while (++i6 < n9) {
            if (c9 = value.charCodeAt(i6), 48 > c9 || c9 > 57) {
              valueSuffix = (c9 === 46 ? decimal + value.slice(i6 + 1) : value.slice(i6)) + valueSuffix;
              value = value.slice(0, i6);
              break;
            }
          }
        }
      }
      if (comma && !zero3)
        value = group2(value, Infinity);
      var length3 = valuePrefix.length + value.length + valueSuffix.length, padding = length3 < width ? new Array(width - length3 + 1).join(fill) : "";
      if (comma && zero3)
        value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length3 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length3);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format3.toString = function() {
      return specifier + "";
    };
    return format3;
  }
  function formatPrefix2(specifier, value) {
    var f4 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e9 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k6 = Math.pow(10, -e9), prefix = prefixes[8 + e9 / 3];
    return function(value2) {
      return f4(k6 * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max4) {
  step = Math.abs(step), max4 = Math.abs(max4) - step;
  return Math.max(0, exponent_default(max4) - exponent_default(step)) + 1;
}

// node_modules/d3-geo/src/math.js
var epsilon3 = 1e-6;
var epsilon22 = 1e-12;
var pi2 = Math.PI;
var halfPi = pi2 / 2;
var quarterPi = pi2 / 4;
var tau2 = pi2 * 2;
var degrees3 = 180 / pi2;
var radians2 = pi2 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var exp = Math.exp;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x6) {
  return x6 > 0 ? 1 : x6 < 0 ? -1 : 0;
};
var sqrt = Math.sqrt;
var tan = Math.tan;
function acos(x6) {
  return x6 > 1 ? 0 : x6 < -1 ? pi2 : Math.acos(x6);
}
function asin(x6) {
  return x6 > 1 ? halfPi : x6 < -1 ? -halfPi : Math.asin(x6);
}

// node_modules/d3-geo/src/noop.js
function noop2() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i6 = -1, n9 = features.length;
    while (++i6 < n9)
      streamGeometry(features[i6].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i6 = -1, n9 = coordinates.length;
    while (++i6 < n9)
      object = coordinates[i6], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i6 = -1, n9 = coordinates.length;
    while (++i6 < n9)
      streamLine(coordinates[i6], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i6 = -1, n9 = coordinates.length;
    while (++i6 < n9)
      streamPolygon(coordinates[i6], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i6 = -1, n9 = geometries.length;
    while (++i6 < n9)
      streamGeometry(geometries[i6], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i6 = -1, n9 = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i6 < n9)
    coordinate = coordinates[i6], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i6 = -1, n9 = coordinates.length;
  stream.polygonStart();
  while (++i6 < n9)
    streamLine(coordinates[i6], stream, 1);
  stream.polygonEnd();
}
function stream_default(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian2) {
  return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos(phi2);
  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi2)];
}
function cartesianDot(a7, b5) {
  return a7[0] * b5[0] + a7[1] * b5[1] + a7[2] * b5[2];
}
function cartesianCross(a7, b5) {
  return [a7[1] * b5[2] - a7[2] * b5[1], a7[2] * b5[0] - a7[0] * b5[2], a7[0] * b5[1] - a7[1] * b5[0]];
}
function cartesianAddInPlace(a7, b5) {
  a7[0] += b5[0], a7[1] += b5[1], a7[2] += b5[2];
}
function cartesianScale(vector, k6) {
  return [vector[0] * k6, vector[1] * k6, vector[2] * k6];
}
function cartesianNormalizeInPlace(d6) {
  var l7 = sqrt(d6[0] * d6[0] + d6[1] * d6[1] + d6[2] * d6[2]);
  d6[0] /= l7, d6[1] /= l7, d6[2] /= l7;
}

// node_modules/d3-geo/src/compose.js
function compose_default(a7, b5) {
  function compose(x6, y5) {
    return x6 = a7(x6, y5), b5(x6[0], x6[1]);
  }
  if (a7.invert && b5.invert)
    compose.invert = function(x6, y5) {
      return x6 = b5.invert(x6, y5), x6 && a7.invert(x6[0], x6[1]);
    };
  return compose;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  if (abs2(lambda) > pi2)
    lambda -= Math.round(lambda / tau2) * tau2;
  return [lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau2) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    lambda += deltaLambda;
    if (abs2(lambda) > pi2)
      lambda -= Math.round(lambda / tau2) * tau2;
    return [lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos(phi2), x6 = cos(lambda) * cosPhi, y5 = sin(lambda) * cosPhi, z5 = sin(phi2), k6 = z5 * cosDeltaPhi + x6 * sinDeltaPhi;
    return [
      atan2(y5 * cosDeltaGamma - k6 * sinDeltaGamma, x6 * cosDeltaPhi - z5 * sinDeltaPhi),
      asin(k6 * cosDeltaGamma + y5 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos(phi2), x6 = cos(lambda) * cosPhi, y5 = sin(lambda) * cosPhi, z5 = sin(phi2), k6 = z5 * cosDeltaGamma - y5 * sinDeltaGamma;
    return [
      atan2(y5 * cosDeltaGamma + z5 * sinDeltaGamma, x6 * cosDeltaPhi + k6 * sinDeltaPhi),
      asin(k6 * cosDeltaPhi - x6 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate) {
  rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);
  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius2, delta, direction, t03, t13) {
  if (!delta)
    return;
  var cosRadius = cos(radius2), sinRadius = sin(radius2), step = direction * delta;
  if (t03 == null) {
    t03 = radius2 + direction * tau2;
    t13 = radius2 - step / 2;
  } else {
    t03 = circleRadius(cosRadius, t03);
    t13 = circleRadius(cosRadius, t13);
    if (direction > 0 ? t03 < t13 : t03 > t13)
      t03 += direction * tau2;
  }
  for (var point6, t6 = t03; direction > 0 ? t6 > t13 : t6 < t13; t6 -= step) {
    point6 = spherical([cosRadius, -sinRadius * cos(t6), -sinRadius * sin(t6)]);
    stream.point(point6[0], point6[1]);
  }
}
function circleRadius(cosRadius, point6) {
  point6 = cartesian(point6), point6[0] -= cosRadius;
  cartesianNormalizeInPlace(point6);
  var radius2 = acos(-point6[1]);
  return ((-point6[2] < 0 ? -radius2 : radius2) + tau2 - epsilon3) % tau2;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line;
  return {
    point: function(x6, y5, m5) {
      line.push([x6, y5, m5]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop2,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a7, b5) {
  return abs2(a7[0] - b5[0]) < epsilon3 && abs2(a7[1] - b5[1]) < epsilon3;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point6, points, other, entry) {
  this.x = point6;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate2, stream) {
  var subject = [], clip = [], i6, n9;
  segments.forEach(function(segment) {
    if ((n10 = segment.length - 1) <= 0)
      return;
    var n10, p0 = segment[0], p1 = segment[n10], x6;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i6 = 0; i6 < n10; ++i6)
          stream.point((p0 = segment[i6])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon3;
    }
    subject.push(x6 = new Intersection(p0, segment, null, true));
    clip.push(x6.o = new Intersection(p0, null, x6, false));
    subject.push(x6 = new Intersection(p1, segment, null, false));
    clip.push(x6.o = new Intersection(p1, null, x6, true));
  });
  if (!subject.length)
    return;
  clip.sort(compareIntersection2);
  link(subject);
  link(clip);
  for (i6 = 0, n9 = clip.length; i6 < n9; ++i6) {
    clip[i6].e = startInside = !startInside;
  }
  var start2 = subject[0], points, point6;
  while (1) {
    var current = start2, isSubject = true;
    while (current.v)
      if ((current = current.n) === start2)
        return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i6 = 0, n9 = points.length; i6 < n9; ++i6)
            stream.point((point6 = points[i6])[0], point6[1]);
        } else {
          interpolate2(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i6 = points.length - 1; i6 >= 0; --i6)
            stream.point((point6 = points[i6])[0], point6[1]);
        } else {
          interpolate2(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array2) {
  if (!(n9 = array2.length))
    return;
  var n9, i6 = 0, a7 = array2[0], b5;
  while (++i6 < n9) {
    a7.n = b5 = array2[i6];
    b5.p = a7;
    a7 = b5;
  }
  a7.n = b5 = array2[0];
  b5.p = a7;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point6) {
  return abs2(point6[0]) <= pi2 ? point6[0] : sign(point6[0]) * ((abs2(point6[0]) + pi2) % tau2 - pi2);
}
function polygonContains_default(polygon, point6) {
  var lambda = longitude(point6), phi2 = point6[1], sinPhi = sin(phi2), normal = [sin(lambda), -cos(lambda), 0], angle = 0, winding = 0;
  var sum2 = new Adder();
  if (sinPhi === 1)
    phi2 = halfPi + epsilon3;
  else if (sinPhi === -1)
    phi2 = -halfPi - epsilon3;
  for (var i6 = 0, n9 = polygon.length; i6 < n9; ++i6) {
    if (!(m5 = (ring = polygon[i6]).length))
      continue;
    var ring, m5, point0 = ring[m5 - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);
    for (var j5 = 0; j5 < m5; ++j5, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j5], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi2, k6 = sinPhi0 * sinPhi1;
      sum2.add(atan2(k6 * sign3 * sin(absDelta), cosPhi0 * cosPhi1 + k6 * cos(absDelta)));
      angle += antimeridian ? delta + sign3 * tau2 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle < -epsilon3 || angle < epsilon3 && sum2 < -epsilon22) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate2, start2) {
  return function(sink) {
    var line = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point6;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge2(segments);
        var startInside = polygonContains_default(polygon, start2);
        if (segments.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate2, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate2(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate2(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point6(lambda, phi2) {
      if (pointVisible(lambda, phi2))
        sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line.point(lambda, phi2);
    }
    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }
    function lineEnd() {
      clip.point = point6;
      line.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i6, n9 = ringSegments.length, m5, segment, point7;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n9)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m5 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i6 = 0; i6 < m5; ++i6)
            sink.point((point7 = segment[i6])[0], point7[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n9 > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a7, b5) {
  return ((a7 = a7.x)[0] < 0 ? a7[1] - halfPi - epsilon3 : halfPi - a7[1]) - ((b5 = b5.x)[0] < 0 ? b5[1] - halfPi - epsilon3 : halfPi - b5[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi2, -halfPi]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi2 : -pi2, delta = abs2(lambda1 - lambda0);
      if (abs2(delta - pi2) < epsilon3) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi2) {
        if (abs2(lambda0 - sign0) < epsilon3)
          lambda0 -= sign0 * epsilon3;
        if (abs2(lambda1 - sign1) < epsilon3)
          lambda1 -= sign1 * epsilon3;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);
  return abs2(sinLambda0Lambda1) > epsilon3 ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to2, direction, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi;
    stream.point(-pi2, phi2);
    stream.point(0, phi2);
    stream.point(pi2, phi2);
    stream.point(pi2, 0);
    stream.point(pi2, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi2, -phi2);
    stream.point(-pi2, 0);
    stream.point(-pi2, phi2);
  } else if (abs2(from[0] - to2[0]) > epsilon3) {
    var lambda = from[0] < to2[0] ? pi2 : -pi2;
    phi2 = direction * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to2[0], to2[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default(radius2) {
  var cr = cos(radius2), delta = 6 * radians2, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon3;
  function interpolate2(from, to2, direction, stream) {
    circleStream(stream, radius2, delta, direction, from, to2);
  }
  function visible(lambda, phi2) {
    return cos(lambda) * cos(phi2) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v4 = visible(lambda, phi2), c9 = smallRadius ? v4 ? 0 : code(lambda, phi2) : v4 ? code(lambda + (lambda < 0 ? pi2 : -pi2), phi2) : 0;
        if (!point0 && (v00 = v0 = v4))
          stream.lineStart();
        if (v4 !== v0) {
          point22 = intersect(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v4 !== v0) {
          clean = 0;
          if (v4) {
            stream.lineStart();
            point22 = intersect(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v4) {
          var t6;
          if (!(c9 & c0) && (t6 = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t6[0][0], t6[0][1]);
              stream.point(t6[1][0], t6[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t6[1][0], t6[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t6[0][0], t6[0][1], 3);
            }
          }
        }
        if (v4 && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v4, c0 = c9;
      },
      lineEnd: function() {
        if (v0)
          stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect(a7, b5, two) {
    var pa = cartesian(a7), pb = cartesian(b5);
    var n1 = [1, 0, 0], n22 = cartesianCross(pa, pb), n2n2 = cartesianDot(n22, n22), n1n2 = n22[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant)
      return !two && a7;
    var c12 = cr * n2n2 / determinant, c23 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n22), A6 = cartesianScale(n1, c12), B6 = cartesianScale(n22, c23);
    cartesianAddInPlace(A6, B6);
    var u5 = n1xn2, w5 = cartesianDot(A6, u5), uu = cartesianDot(u5, u5), t23 = w5 * w5 - uu * (cartesianDot(A6, A6) - 1);
    if (t23 < 0)
      return;
    var t6 = sqrt(t23), q4 = cartesianScale(u5, (-w5 - t6) / uu);
    cartesianAddInPlace(q4, A6);
    q4 = spherical(q4);
    if (!two)
      return q4;
    var lambda0 = a7[0], lambda1 = b5[0], phi0 = a7[1], phi1 = b5[1], z5;
    if (lambda1 < lambda0)
      z5 = lambda0, lambda0 = lambda1, lambda1 = z5;
    var delta2 = lambda1 - lambda0, polar = abs2(delta2 - pi2) < epsilon3, meridian = polar || delta2 < epsilon3;
    if (!polar && phi1 < phi0)
      z5 = phi0, phi0 = phi1, phi1 = z5;
    if (meridian ? polar ? phi0 + phi1 > 0 ^ q4[1] < (abs2(q4[0] - lambda0) < epsilon3 ? phi0 : phi1) : phi0 <= q4[1] && q4[1] <= phi1 : delta2 > pi2 ^ (lambda0 <= q4[0] && q4[0] <= lambda1)) {
      var q1 = cartesianScale(u5, (-w5 + t6) / uu);
      cartesianAddInPlace(q1, A6);
      return [q4, spherical(q1)];
    }
  }
  function code(lambda, phi2) {
    var r6 = smallRadius ? radius2 : pi2 - radius2, code2 = 0;
    if (lambda < -r6)
      code2 |= 1;
    else if (lambda > r6)
      code2 |= 2;
    if (phi2 < -r6)
      code2 |= 4;
    else if (phi2 > r6)
      code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate2, smallRadius ? [0, -radius2] : [-pi2, radius2 - pi2]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default(a7, b5, x05, y05, x12, y12) {
  var ax = a7[0], ay = a7[1], bx = b5[0], by = b5[1], t03 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r6;
  r6 = x05 - ax;
  if (!dx && r6 > 0)
    return;
  r6 /= dx;
  if (dx < 0) {
    if (r6 < t03)
      return;
    if (r6 < t13)
      t13 = r6;
  } else if (dx > 0) {
    if (r6 > t13)
      return;
    if (r6 > t03)
      t03 = r6;
  }
  r6 = x12 - ax;
  if (!dx && r6 < 0)
    return;
  r6 /= dx;
  if (dx < 0) {
    if (r6 > t13)
      return;
    if (r6 > t03)
      t03 = r6;
  } else if (dx > 0) {
    if (r6 < t03)
      return;
    if (r6 < t13)
      t13 = r6;
  }
  r6 = y05 - ay;
  if (!dy && r6 > 0)
    return;
  r6 /= dy;
  if (dy < 0) {
    if (r6 < t03)
      return;
    if (r6 < t13)
      t13 = r6;
  } else if (dy > 0) {
    if (r6 > t13)
      return;
    if (r6 > t03)
      t03 = r6;
  }
  r6 = y12 - ay;
  if (!dy && r6 < 0)
    return;
  r6 /= dy;
  if (dy < 0) {
    if (r6 > t13)
      return;
    if (r6 > t03)
      t03 = r6;
  } else if (dy > 0) {
    if (r6 < t03)
      return;
    if (r6 < t13)
      t13 = r6;
  }
  if (t03 > 0)
    a7[0] = ax + t03 * dx, a7[1] = ay + t03 * dy;
  if (t13 < 1)
    b5[0] = ax + t13 * dx, b5[1] = ay + t13 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x05, y05, x12, y12) {
  function visible(x6, y5) {
    return x05 <= x6 && x6 <= x12 && y05 <= y5 && y5 <= y12;
  }
  function interpolate2(from, to2, direction, stream) {
    var a7 = 0, a1 = 0;
    if (from == null || (a7 = corner(from, direction)) !== (a1 = corner(to2, direction)) || comparePoint(from, to2) < 0 ^ direction > 0) {
      do
        stream.point(a7 === 0 || a7 === 3 ? x05 : x12, a7 > 1 ? y12 : y05);
      while ((a7 = (a7 + direction + 4) % 4) !== a1);
    } else {
      stream.point(to2[0], to2[1]);
    }
  }
  function corner(p5, direction) {
    return abs2(p5[0] - x05) < epsilon3 ? direction > 0 ? 0 : 3 : abs2(p5[0] - x12) < epsilon3 ? direction > 0 ? 2 : 1 : abs2(p5[1] - y05) < epsilon3 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a7, b5) {
    return comparePoint(a7.x, b5.x);
  }
  function comparePoint(a7, b5) {
    var ca = corner(a7, 1), cb = corner(b5, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b5[1] - a7[1] : ca === 1 ? a7[0] - b5[0] : ca === 2 ? a7[1] - b5[1] : b5[0] - a7[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first2, clean;
    var clipStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point6(x6, y5) {
      if (visible(x6, y5))
        activeStream.point(x6, y5);
    }
    function polygonInside() {
      var winding = 0;
      for (var i6 = 0, n9 = polygon.length; i6 < n9; ++i6) {
        for (var ring2 = polygon[i6], j5 = 1, m5 = ring2.length, point7 = ring2[0], a0, a1, b0 = point7[0], b1 = point7[1]; j5 < m5; ++j5) {
          a0 = b0, a1 = b1, point7 = ring2[j5], b0 = point7[0], b1 = point7[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x05 - a0))
              ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x05 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge2(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate2(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate2, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon)
        polygon.push(ring = []);
      first2 = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point6;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint(x6, y5) {
      var v4 = visible(x6, y5);
      if (polygon)
        ring.push([x6, y5]);
      if (first2) {
        x__ = x6, y__ = y5, v__ = v4;
        first2 = false;
        if (v4) {
          activeStream.lineStart();
          activeStream.point(x6, y5);
        }
      } else {
        if (v4 && v_)
          activeStream.point(x6, y5);
        else {
          var a7 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b5 = [x6 = Math.max(clipMin, Math.min(clipMax, x6)), y5 = Math.max(clipMin, Math.min(clipMax, y5))];
          if (line_default(a7, b5, x05, y05, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a7[0], a7[1]);
            }
            activeStream.point(b5[0], b5[1]);
            if (!v4)
              activeStream.lineEnd();
            clean = false;
          } else if (v4) {
            activeStream.lineStart();
            activeStream.point(x6, y5);
            clean = false;
          }
        }
      }
      x_ = x6, y_ = y5, v_ = v4;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/identity.js
var identity_default4 = (x6) => x6;

// node_modules/d3-geo/src/path/area.js
var areaSum = new Adder();
var areaRingSum = new Adder();
var x00;
var y00;
var x0;
var y0;
var areaStream = {
  point: noop2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop2;
    areaSum.add(abs2(areaRingSum));
    areaRingSum = new Adder();
  },
  result: function() {
    var area2 = areaSum / 2;
    areaSum = new Adder();
    return area2;
  }
};
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaPointFirst(x6, y5) {
  areaStream.point = areaPoint;
  x00 = x0 = x6, y00 = y0 = y5;
}
function areaPoint(x6, y5) {
  areaRingSum.add(y0 * x6 - x0 * y5);
  x0 = x6, y0 = y5;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default = areaStream;

// node_modules/d3-geo/src/path/bounds.js
var x02 = Infinity;
var y02 = x02;
var x1 = -x02;
var y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: noop2,
  polygonEnd: noop2,
  result: function() {
    var bounds = [[x02, y02], [x1, y1]];
    x1 = y1 = -(y02 = x02 = Infinity);
    return bounds;
  }
};
function boundsPoint(x6, y5) {
  if (x6 < x02)
    x02 = x6;
  if (x6 > x1)
    x1 = x6;
  if (y5 < y02)
    y02 = y5;
  if (y5 > y1)
    y1 = y5;
}
var bounds_default = boundsStream;

// node_modules/d3-geo/src/path/centroid.js
var X0 = 0;
var Y0 = 0;
var Z0 = 0;
var X1 = 0;
var Y1 = 0;
var Z1 = 0;
var X22 = 0;
var Y22 = 0;
var Z2 = 0;
var x002;
var y002;
var x03;
var y03;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X22 / Z2, Y22 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X22 = Y22 = Z2 = 0;
    return centroid;
  }
};
function centroidPoint(x6, y5) {
  X0 += x6;
  Y0 += y5;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x6, y5) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x03 = x6, y03 = y5);
}
function centroidPointLine(x6, y5) {
  var dx = x6 - x03, dy = y5 - y03, z5 = sqrt(dx * dx + dy * dy);
  X1 += z5 * (x03 + x6) / 2;
  Y1 += z5 * (y03 + y5) / 2;
  Z1 += z5;
  centroidPoint(x03 = x6, y03 = y5);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x6, y5) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x002 = x03 = x6, y002 = y03 = y5);
}
function centroidPointRing(x6, y5) {
  var dx = x6 - x03, dy = y5 - y03, z5 = sqrt(dx * dx + dy * dy);
  X1 += z5 * (x03 + x6) / 2;
  Y1 += z5 * (y03 + y5) / 2;
  Z1 += z5;
  z5 = y03 * x6 - x03 * y5;
  X22 += z5 * (x03 + x6);
  Y22 += z5 * (y03 + y5);
  Z2 += z5 * 3;
  centroidPoint(x03 = x6, y03 = y5);
}
var centroid_default = centroidStream;

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_4) {
    return this._radius = _4, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  },
  point: function(x6, y5) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x6, y5);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x6, y5);
        break;
      }
      default: {
        this._context.moveTo(x6 + this._radius, y5);
        this._context.arc(x6, y5, this._radius, 0, tau2);
        break;
      }
    }
  },
  result: noop2
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();
var lengthRing;
var x003;
var y003;
var x04;
var y04;
var lengthStream = {
  point: noop2,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing)
      lengthPoint(x003, y003);
    lengthStream.point = noop2;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length3 = +lengthSum;
    lengthSum = new Adder();
    return length3;
  }
};
function lengthPointFirst(x6, y5) {
  lengthStream.point = lengthPoint;
  x003 = x04 = x6, y003 = y04 = y5;
}
function lengthPoint(x6, y5) {
  x04 -= x6, y04 -= y5;
  lengthSum.add(sqrt(x04 * x04 + y04 * y04));
  x04 = x6, y04 = y5;
}
var measure_default = lengthStream;

// node_modules/d3-geo/src/path/string.js
var cacheDigits;
var cacheAppend;
var cacheRadius;
var cacheCircle;
var PathString = class {
  constructor(digits) {
    this._append = digits == null ? append2 : appendRound2(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_4) {
    this._radius = +_4;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0)
      this._ += "Z";
    this._point = NaN;
  }
  point(x6, y5) {
    switch (this._point) {
      case 0: {
        this._append`M${x6},${y5}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x6},${y5}`;
        break;
      }
      default: {
        this._append`M${x6},${y5}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r6 = this._radius;
          const s8 = this._;
          this._ = "";
          this._append`m0,${r6}a${r6},${r6} 0 1,1 0,${-2 * r6}a${r6},${r6} 0 1,1 0,${2 * r6}z`;
          cacheRadius = r6;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s8;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result = this._;
    this._ = "";
    return result.length ? result : null;
  }
};
function append2(strings) {
  let i6 = 1;
  this._ += strings[0];
  for (const j5 = strings.length; i6 < j5; ++i6) {
    this._ += arguments[i6] + strings[i6];
  }
}
function appendRound2(digits) {
  const d6 = Math.floor(digits);
  if (!(d6 >= 0))
    throw new RangeError(`invalid digits: ${digits}`);
  if (d6 > 15)
    return append2;
  if (d6 !== cacheDigits) {
    const k6 = 10 ** d6;
    cacheDigits = d6;
    cacheAppend = function append3(strings) {
      let i6 = 1;
      this._ += strings[0];
      for (const j5 = strings.length; i6 < j5; ++i6) {
        this._ += Math.round(arguments[i6] * k6) / k6 + strings[i6];
      }
    };
  }
  return cacheAppend;
}

// node_modules/d3-geo/src/path/index.js
function path_default(projection3, context) {
  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
  function path2(object) {
    if (object) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path2.area = function(object) {
    stream_default(object, projectionStream(area_default));
    return area_default.result();
  };
  path2.measure = function(object) {
    stream_default(object, projectionStream(measure_default));
    return measure_default.result();
  };
  path2.bounds = function(object) {
    stream_default(object, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path2.centroid = function(object) {
    stream_default(object, projectionStream(centroid_default));
    return centroid_default.result();
  };
  path2.projection = function(_4) {
    if (!arguments.length)
      return projection3;
    projectionStream = _4 == null ? (projection3 = null, identity_default4) : (projection3 = _4).stream;
    return path2;
  };
  path2.context = function(_4) {
    if (!arguments.length)
      return context;
    contextStream = _4 == null ? (context = null, new PathString(digits)) : new PathContext(context = _4);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path2;
  };
  path2.pointRadius = function(_4) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _4 === "function" ? _4 : (contextStream.pointRadius(+_4), +_4);
    return path2;
  };
  path2.digits = function(_4) {
    if (!arguments.length)
      return digits;
    if (_4 == null)
      digits = null;
    else {
      const d6 = Math.floor(_4);
      if (!(d6 >= 0))
        throw new RangeError(`invalid digits: ${_4}`);
      digits = d6;
    }
    if (context === null)
      contextStream = new PathString(digits);
    return path2;
  };
  return path2.projection(projection3).digits(digits).context(context);
}

// node_modules/d3-geo/src/transform.js
function transform_default(methods) {
  return {
    stream: transformer(methods)
  };
}
function transformer(methods) {
  return function(stream) {
    var s8 = new TransformStream();
    for (var key in methods)
      s8[key] = methods[key];
    s8.stream = stream;
    return s8;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x6, y5) {
    this.stream.point(x6, y5);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection3, fitBounds, object) {
  var clip = projection3.clipExtent && projection3.clipExtent();
  projection3.scale(150).translate([0, 0]);
  if (clip != null)
    projection3.clipExtent(null);
  stream_default(object, projection3.stream(bounds_default));
  fitBounds(bounds_default.result());
  if (clip != null)
    projection3.clipExtent(clip);
  return projection3;
}
function fitExtent(projection3, extent3, object) {
  return fit(projection3, function(b5) {
    var w5 = extent3[1][0] - extent3[0][0], h5 = extent3[1][1] - extent3[0][1], k6 = Math.min(w5 / (b5[1][0] - b5[0][0]), h5 / (b5[1][1] - b5[0][1])), x6 = +extent3[0][0] + (w5 - k6 * (b5[1][0] + b5[0][0])) / 2, y5 = +extent3[0][1] + (h5 - k6 * (b5[1][1] + b5[0][1])) / 2;
    projection3.scale(150 * k6).translate([x6, y5]);
  }, object);
}
function fitSize(projection3, size, object) {
  return fitExtent(projection3, [[0, 0], size], object);
}
function fitWidth(projection3, width, object) {
  return fit(projection3, function(b5) {
    var w5 = +width, k6 = w5 / (b5[1][0] - b5[0][0]), x6 = (w5 - k6 * (b5[1][0] + b5[0][0])) / 2, y5 = -k6 * b5[0][1];
    projection3.scale(150 * k6).translate([x6, y5]);
  }, object);
}
function fitHeight(projection3, height, object) {
  return fit(projection3, function(b5) {
    var h5 = +height, k6 = h5 / (b5[1][1] - b5[0][1]), x6 = -k6 * b5[0][0], y5 = (h5 - k6 * (b5[1][1] + b5[0][1])) / 2;
    projection3.scale(150 * k6).translate([x6, y5]);
  }, object);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos(30 * radians2);
function resample_default(project2, delta2) {
  return +delta2 ? resample(project2, delta2) : resampleNone(project2);
}
function resampleNone(project2) {
  return transformer({
    point: function(x6, y5) {
      x6 = project2(x6, y5);
      this.stream.point(x6[0], x6[1]);
    }
  });
}
function resample(project2, delta2) {
  function resampleLineTo(x05, y05, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c12, depth, stream) {
    var dx = x12 - x05, dy = y12 - y05, d22 = dx * dx + dy * dy;
    if (d22 > 4 * delta2 && depth--) {
      var a7 = a0 + a1, b5 = b0 + b1, c9 = c0 + c12, m5 = sqrt(a7 * a7 + b5 * b5 + c9 * c9), phi2 = asin(c9 /= m5), lambda2 = abs2(abs2(c9) - 1) < epsilon3 || abs2(lambda0 - lambda1) < epsilon3 ? (lambda0 + lambda1) / 2 : atan2(b5, a7), p5 = project2(lambda2, phi2), x22 = p5[0], y22 = p5[1], dx2 = x22 - x05, dy2 = y22 - y05, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d22 > delta2 || abs2((dx * dx2 + dy * dy2) / d22 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c12 < cosMinDistance) {
        resampleLineTo(x05, y05, lambda0, a0, b0, c0, x22, y22, lambda2, a7 /= m5, b5 /= m5, c9, depth, stream);
        stream.point(x22, y22);
        resampleLineTo(x22, y22, lambda2, a7, b5, c9, x12, y12, lambda1, a1, b1, c12, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x004, y004, a00, b00, c00, lambda0, x05, y05, a0, b0, c0;
    var resampleStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point6(x6, y5) {
      x6 = project2(x6, y5);
      stream.point(x6[0], x6[1]);
    }
    function lineStart() {
      x05 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi2) {
      var c9 = cartesian([lambda, phi2]), p5 = project2(lambda, phi2);
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x05 = p5[0], y05 = p5[1], lambda0 = lambda, a0 = c9[0], b0 = c9[1], c0 = c9[2], maxDepth, stream);
      stream.point(x05, y05);
    }
    function lineEnd() {
      resampleStream.point = point6;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint(lambda00 = lambda, phi2), x004 = x05, y004 = y05, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x004, y004, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer({
  point: function(x6, y5) {
    this.stream.point(x6 * radians2, y5 * radians2);
  }
});
function transformRotate(rotate) {
  return transformer({
    point: function(x6, y5) {
      var r6 = rotate(x6, y5);
      return this.stream.point(r6[0], r6[1]);
    }
  });
}
function scaleTranslate(k6, dx, dy, sx, sy) {
  function transform2(x6, y5) {
    x6 *= sx;
    y5 *= sy;
    return [dx + k6 * x6, dy - k6 * y5];
  }
  transform2.invert = function(x6, y5) {
    return [(x6 - dx) / k6 * sx, (dy - y5) / k6 * sy];
  };
  return transform2;
}
function scaleTranslateRotate(k6, dx, dy, sx, sy, alpha) {
  if (!alpha)
    return scaleTranslate(k6, dx, dy, sx, sy);
  var cosAlpha = cos(alpha), sinAlpha = sin(alpha), a7 = cosAlpha * k6, b5 = sinAlpha * k6, ai = cosAlpha / k6, bi = sinAlpha / k6, ci = (sinAlpha * dy - cosAlpha * dx) / k6, fi = (sinAlpha * dx + cosAlpha * dy) / k6;
  function transform2(x6, y5) {
    x6 *= sx;
    y5 *= sy;
    return [a7 * x6 - b5 * y5 + dx, dy - b5 * x6 - a7 * y5];
  }
  transform2.invert = function(x6, y5) {
    return [sx * (ai * x6 - bi * y5 + ci), sy * (fi - bi * x6 - ai * y5)];
  };
  return transform2;
}
function projection(project2) {
  return projectionMutator(function() {
    return project2;
  })();
}
function projectionMutator(projectAt) {
  var project2, k6 = 150, x6 = 480, y5 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x05 = null, y05, x12, y12, postclip = identity_default4, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
  function projection3(point6) {
    return projectRotateTransform(point6[0] * radians2, point6[1] * radians2);
  }
  function invert(point6) {
    point6 = projectRotateTransform.invert(point6[0], point6[1]);
    return point6 && [point6[0] * degrees3, point6[1] * degrees3];
  }
  projection3.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection3.preclip = function(_4) {
    return arguments.length ? (preclip = _4, theta = void 0, reset()) : preclip;
  };
  projection3.postclip = function(_4) {
    return arguments.length ? (postclip = _4, x05 = y05 = x12 = y12 = null, reset()) : postclip;
  };
  projection3.clipAngle = function(_4) {
    return arguments.length ? (preclip = +_4 ? circle_default(theta = _4 * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees3;
  };
  projection3.clipExtent = function(_4) {
    return arguments.length ? (postclip = _4 == null ? (x05 = y05 = x12 = y12 = null, identity_default4) : clipRectangle(x05 = +_4[0][0], y05 = +_4[0][1], x12 = +_4[1][0], y12 = +_4[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  projection3.scale = function(_4) {
    return arguments.length ? (k6 = +_4, recenter()) : k6;
  };
  projection3.translate = function(_4) {
    return arguments.length ? (x6 = +_4[0], y5 = +_4[1], recenter()) : [x6, y5];
  };
  projection3.center = function(_4) {
    return arguments.length ? (lambda = _4[0] % 360 * radians2, phi2 = _4[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi2 * degrees3];
  };
  projection3.rotate = function(_4) {
    return arguments.length ? (deltaLambda = _4[0] % 360 * radians2, deltaPhi = _4[1] % 360 * radians2, deltaGamma = _4.length > 2 ? _4[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
  };
  projection3.angle = function(_4) {
    return arguments.length ? (alpha = _4 % 360 * radians2, recenter()) : alpha * degrees3;
  };
  projection3.reflectX = function(_4) {
    return arguments.length ? (sx = _4 ? -1 : 1, recenter()) : sx < 0;
  };
  projection3.reflectY = function(_4) {
    return arguments.length ? (sy = _4 ? -1 : 1, recenter()) : sy < 0;
  };
  projection3.precision = function(_4) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _4 * _4), reset()) : sqrt(delta2);
  };
  projection3.fitExtent = function(extent3, object) {
    return fitExtent(projection3, extent3, object);
  };
  projection3.fitSize = function(size, object) {
    return fitSize(projection3, size, object);
  };
  projection3.fitWidth = function(width, object) {
    return fitWidth(projection3, width, object);
  };
  projection3.fitHeight = function(height, object) {
    return fitHeight(projection3, height, object);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k6, 0, 0, sx, sy, alpha).apply(null, project2(lambda, phi2)), transform2 = scaleTranslateRotate(k6, x6 - center2[0], y5 - center2[1], sx, sy, alpha);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project2, transform2);
    projectRotateTransform = compose_default(rotate, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache = cacheStream = null;
    return projection3;
  }
  return function() {
    project2 = projectAt.apply(this, arguments);
    projection3.invert = project2.invert && invert;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi0 = 0, phi1 = pi2 / 3, m5 = projectionMutator(projectAt), p5 = m5(phi0, phi1);
  p5.parallels = function(_4) {
    return arguments.length ? m5(phi0 = _4[0] * radians2, phi1 = _4[1] * radians2) : [phi0 * degrees3, phi1 * degrees3];
  };
  return p5;
}

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos(phi0);
  function forward(lambda, phi2) {
    return [lambda * cosPhi0, sin(phi2) / cosPhi0];
  }
  forward.invert = function(x6, y5) {
    return [x6 / cosPhi0, asin(y5 * cosPhi0)];
  };
  return forward;
}

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y05, y12) {
  var sy0 = sin(y05), n9 = (sy0 + sin(y12)) / 2;
  if (abs2(n9) < epsilon3)
    return cylindricalEqualAreaRaw(y05);
  var c9 = 1 + sy0 * (2 * n9 - sy0), r0 = sqrt(c9) / n9;
  function project2(x6, y5) {
    var r6 = sqrt(c9 - 2 * n9 * sin(y5)) / n9;
    return [r6 * sin(x6 *= n9), r0 - r6 * cos(x6)];
  }
  project2.invert = function(x6, y5) {
    var r0y = r0 - y5, l7 = atan2(x6, abs2(r0y)) * sign(r0y);
    if (r0y * n9 < 0)
      l7 -= pi2 * sign(x6) * sign(r0y);
    return [l7 / n9, asin((c9 - (x6 * x6 + r0y * r0y) * n9 * n9) / (2 * n9))];
  };
  return project2;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n9 = streams.length;
  return {
    point: function(x6, y5) {
      var i6 = -1;
      while (++i6 < n9)
        streams[i6].point(x6, y5);
    },
    sphere: function() {
      var i6 = -1;
      while (++i6 < n9)
        streams[i6].sphere();
    },
    lineStart: function() {
      var i6 = -1;
      while (++i6 < n9)
        streams[i6].lineStart();
    },
    lineEnd: function() {
      var i6 = -1;
      while (++i6 < n9)
        streams[i6].lineEnd();
    },
    polygonStart: function() {
      var i6 = -1;
      while (++i6 < n9)
        streams[i6].polygonStart();
    },
    polygonEnd: function() {
      var i6 = -1;
      while (++i6 < n9)
        streams[i6].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point6, pointStream = { point: function(x6, y5) {
    point6 = [x6, y5];
  } };
  function albersUsa(coordinates) {
    var x6 = coordinates[0], y5 = coordinates[1];
    return point6 = null, (lower48Point.point(x6, y5), point6) || (alaskaPoint.point(x6, y5), point6) || (hawaiiPoint.point(x6, y5), point6);
  }
  albersUsa.invert = function(coordinates) {
    var k6 = lower48.scale(), t6 = lower48.translate(), x6 = (coordinates[0] - t6[0]) / k6, y5 = (coordinates[1] - t6[1]) / k6;
    return (y5 >= 0.12 && y5 < 0.234 && x6 >= -0.425 && x6 < -0.214 ? alaska : y5 >= 0.166 && y5 < 0.234 && x6 >= -0.214 && x6 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_4) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_4), alaska.precision(_4), hawaii.precision(_4);
    return reset();
  };
  albersUsa.scale = function(_4) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_4), alaska.scale(_4 * 0.35), hawaii.scale(_4);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_4) {
    if (!arguments.length)
      return lower48.translate();
    var k6 = lower48.scale(), x6 = +_4[0], y5 = +_4[1];
    lower48Point = lower48.translate(_4).clipExtent([[x6 - 0.455 * k6, y5 - 0.238 * k6], [x6 + 0.455 * k6, y5 + 0.238 * k6]]).stream(pointStream);
    alaskaPoint = alaska.translate([x6 - 0.307 * k6, y5 + 0.201 * k6]).clipExtent([[x6 - 0.425 * k6 + epsilon3, y5 + 0.12 * k6 + epsilon3], [x6 - 0.214 * k6 - epsilon3, y5 + 0.234 * k6 - epsilon3]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x6 - 0.205 * k6, y5 + 0.212 * k6]).clipExtent([[x6 - 0.214 * k6 + epsilon3, y5 + 0.166 * k6 + epsilon3], [x6 - 0.115 * k6 - epsilon3, y5 + 0.234 * k6 - epsilon3]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent3, object) {
    return fitExtent(albersUsa, extent3, object);
  };
  albersUsa.fitSize = function(size, object) {
    return fitSize(albersUsa, size, object);
  };
  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };
  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };
  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale2) {
  return function(x6, y5) {
    var cx = cos(x6), cy = cos(y5), k6 = scale2(cx * cy);
    if (k6 === Infinity)
      return [2, 0];
    return [
      k6 * cy * sin(x6),
      k6 * sin(y5)
    ];
  };
}
function azimuthalInvert(angle) {
  return function(x6, y5) {
    var z5 = sqrt(x6 * x6 + y5 * y5), c9 = angle(z5), sc = sin(c9), cc = cos(c9);
    return [
      atan2(x6 * sc, z5 * cc),
      asin(z5 && y5 * sc / z5)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z5) {
  return 2 * asin(z5 / 2);
});
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c9) {
  return (c9 = acos(c9)) && c9 / sin(c9);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z5) {
  return z5;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log(tan((halfPi + phi2) / 2))];
}
mercatorRaw.invert = function(x6, y5) {
  return [x6, 2 * atan(exp(y5)) - halfPi];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau2);
}
function mercatorProjection(project2) {
  var m5 = projection(project2), center2 = m5.center, scale2 = m5.scale, translate = m5.translate, clipExtent = m5.clipExtent, x05 = null, y05, x12, y12;
  m5.scale = function(_4) {
    return arguments.length ? (scale2(_4), reclip()) : scale2();
  };
  m5.translate = function(_4) {
    return arguments.length ? (translate(_4), reclip()) : translate();
  };
  m5.center = function(_4) {
    return arguments.length ? (center2(_4), reclip()) : center2();
  };
  m5.clipExtent = function(_4) {
    return arguments.length ? (_4 == null ? x05 = y05 = x12 = y12 = null : (x05 = +_4[0][0], y05 = +_4[0][1], x12 = +_4[1][0], y12 = +_4[1][1]), reclip()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  function reclip() {
    var k6 = pi2 * scale2(), t6 = m5(rotation_default(m5.rotate()).invert([0, 0]));
    return clipExtent(x05 == null ? [[t6[0] - k6, t6[1] - k6], [t6[0] + k6, t6[1] + k6]] : project2 === mercatorRaw ? [[Math.max(t6[0] - k6, x05), y05], [Math.min(t6[0] + k6, x12), y12]] : [[x05, Math.max(t6[1] - k6, y05)], [x12, Math.min(t6[1] + k6, y12)]]);
  }
  return reclip();
}

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y5) {
  return tan((halfPi + y5) / 2);
}
function conicConformalRaw(y05, y12) {
  var cy0 = cos(y05), n9 = y05 === y12 ? sin(y05) : log(cy0 / cos(y12)) / log(tany(y12) / tany(y05)), f4 = cy0 * pow(tany(y05), n9) / n9;
  if (!n9)
    return mercatorRaw;
  function project2(x6, y5) {
    if (f4 > 0) {
      if (y5 < -halfPi + epsilon3)
        y5 = -halfPi + epsilon3;
    } else {
      if (y5 > halfPi - epsilon3)
        y5 = halfPi - epsilon3;
    }
    var r6 = f4 / pow(tany(y5), n9);
    return [r6 * sin(n9 * x6), f4 - r6 * cos(n9 * x6)];
  }
  project2.invert = function(x6, y5) {
    var fy = f4 - y5, r6 = sign(n9) * sqrt(x6 * x6 + fy * fy), l7 = atan2(x6, abs2(fy)) * sign(fy);
    if (fy * n9 < 0)
      l7 -= pi2 * sign(x6) * sign(fy);
    return [l7 / n9, 2 * atan(pow(f4 / r6, 1 / n9)) - halfPi];
  };
  return project2;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y05, y12) {
  var cy0 = cos(y05), n9 = y05 === y12 ? sin(y05) : (cy0 - cos(y12)) / (y12 - y05), g6 = cy0 / n9 + y05;
  if (abs2(n9) < epsilon3)
    return equirectangularRaw;
  function project2(x6, y5) {
    var gy = g6 - y5, nx = n9 * x6;
    return [gy * sin(nx), g6 - gy * cos(nx)];
  }
  project2.invert = function(x6, y5) {
    var gy = g6 - y5, l7 = atan2(x6, abs2(gy)) * sign(gy);
    if (gy * n9 < 0)
      l7 -= pi2 * sign(x6) * sign(gy);
    return [l7 / n9, g6 - sign(n9) * sqrt(x6 * x6 + gy * gy)];
  };
  return project2;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A22 = -0.081106;
var A32 = 893e-6;
var A42 = 3796e-6;
var M4 = sqrt(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l7 = asin(M4 * sin(phi2)), l22 = l7 * l7, l62 = l22 * l22 * l22;
  return [
    lambda * cos(l7) / (M4 * (A1 + 3 * A22 * l22 + l62 * (7 * A32 + 9 * A42 * l22))),
    l7 * (A1 + A22 * l22 + l62 * (A32 + A42 * l22))
  ];
}
equalEarthRaw.invert = function(x6, y5) {
  var l7 = y5, l22 = l7 * l7, l62 = l22 * l22 * l22;
  for (var i6 = 0, delta, fy, fpy; i6 < iterations; ++i6) {
    fy = l7 * (A1 + A22 * l22 + l62 * (A32 + A42 * l22)) - y5;
    fpy = A1 + 3 * A22 * l22 + l62 * (7 * A32 + 9 * A42 * l22);
    l7 -= delta = fy / fpy, l22 = l7 * l7, l62 = l22 * l22 * l22;
    if (abs2(delta) < epsilon22)
      break;
  }
  return [
    M4 * x6 * (A1 + 3 * A22 * l22 + l62 * (7 * A32 + 9 * A42 * l22)) / cos(l7),
    asin(sin(l7) / M4)
  ];
};
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x6, y5) {
  var cy = cos(y5), k6 = cos(x6) * cy;
  return [cy * sin(x6) / k6, sin(y5) / k6];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x6, y5) {
  return [cos(y5) * sin(x6), sin(y5)];
}
orthographicRaw.invert = azimuthalInvert(asin);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon3);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x6, y5) {
  var cy = cos(y5), k6 = 1 + cos(x6) * cy;
  return [cy * sin(x6) / k6, sin(y5) / k6];
}
stereographicRaw.invert = azimuthalInvert(function(z5) {
  return 2 * atan(z5);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log(tan((halfPi + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x6, y5) {
  return [-y5, 2 * atan(exp(x6)) - halfPi];
};
function transverseMercator_default() {
  var m5 = mercatorProjection(transverseMercatorRaw), center2 = m5.center, rotate = m5.rotate;
  m5.center = function(_4) {
    return arguments.length ? center2([-_4[1], _4[0]]) : (_4 = center2(), [_4[1], -_4[0]]);
  };
  m5.rotate = function(_4) {
    return arguments.length ? rotate([_4[0], _4[1], _4.length > 2 ? _4[2] + 90 : 90]) : (_4 = rotate(), [_4[0], _4[1], _4[2] - 90]);
  };
  return rotate([0, 0, 90]).scale(159.155);
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range4) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range4).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function")
        this.interpolator(domain);
      else
        this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function")
        this.interpolator(interpolator);
      else
        this.range(interpolator);
      break;
    }
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index2 = new InternMap(), domain = [], range4 = [], unknown = implicit;
  function scale2(d6) {
    let i6 = index2.get(d6);
    if (i6 === void 0) {
      if (unknown !== implicit)
        return unknown;
      index2.set(d6, i6 = domain.push(d6) - 1);
    }
    return range4[i6 % range4.length];
  }
  scale2.domain = function(_4) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index2 = new InternMap();
    for (const value of _4) {
      if (index2.has(value))
        continue;
      index2.set(value, domain.push(value) - 1);
    }
    return scale2;
  };
  scale2.range = function(_4) {
    return arguments.length ? (range4 = Array.from(_4), scale2) : range4.slice();
  };
  scale2.unknown = function(_4) {
    return arguments.length ? (unknown = _4, scale2) : unknown;
  };
  scale2.copy = function() {
    return ordinal(domain, range4).unknown(unknown);
  };
  initRange.apply(scale2, arguments);
  return scale2;
}

// node_modules/d3-scale/src/band.js
function band() {
  var scale2 = ordinal().unknown(void 0), domain = scale2.domain, ordinalRange2 = scale2.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale2.unknown;
  function rescale() {
    var n9 = domain().length, reverse2 = r1 < r0, start2 = reverse2 ? r1 : r0, stop = reverse2 ? r0 : r1;
    step = (stop - start2) / Math.max(1, n9 - paddingInner + paddingOuter * 2);
    if (round)
      step = Math.floor(step);
    start2 += (stop - start2 - step * (n9 - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round)
      start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values2 = range(n9).map(function(i6) {
      return start2 + step * i6;
    });
    return ordinalRange2(reverse2 ? values2.reverse() : values2);
  }
  scale2.domain = function(_4) {
    return arguments.length ? (domain(_4), rescale()) : domain();
  };
  scale2.range = function(_4) {
    return arguments.length ? ([r0, r1] = _4, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale2.rangeRound = function(_4) {
    return [r0, r1] = _4, r0 = +r0, r1 = +r1, round = true, rescale();
  };
  scale2.bandwidth = function() {
    return bandwidth;
  };
  scale2.step = function() {
    return step;
  };
  scale2.round = function(_4) {
    return arguments.length ? (round = !!_4, rescale()) : round;
  };
  scale2.padding = function(_4) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_4), rescale()) : paddingInner;
  };
  scale2.paddingInner = function(_4) {
    return arguments.length ? (paddingInner = Math.min(1, _4), rescale()) : paddingInner;
  };
  scale2.paddingOuter = function(_4) {
    return arguments.length ? (paddingOuter = +_4, rescale()) : paddingOuter;
  };
  scale2.align = function(_4) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _4)), rescale()) : align;
  };
  scale2.copy = function() {
    return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale2) {
  var copy3 = scale2.copy;
  scale2.padding = scale2.paddingOuter;
  delete scale2.paddingInner;
  delete scale2.paddingOuter;
  scale2.copy = function() {
    return pointish(copy3());
  };
  return scale2;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

// node_modules/d3-scale/src/constant.js
function constants(x6) {
  return function() {
    return x6;
  };
}

// node_modules/d3-scale/src/number.js
function number3(x6) {
  return +x6;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity4(x6) {
  return x6;
}
function normalize(a7, b5) {
  return (b5 -= a7 = +a7) ? function(x6) {
    return (x6 - a7) / b5;
  } : constants(isNaN(b5) ? NaN : 0.5);
}
function clamper(a7, b5) {
  var t6;
  if (a7 > b5)
    t6 = a7, a7 = b5, b5 = t6;
  return function(x6) {
    return Math.max(a7, Math.min(b5, x6));
  };
}
function bimap(domain, range4, interpolate2) {
  var d02 = domain[0], d1 = domain[1], r0 = range4[0], r1 = range4[1];
  if (d1 < d02)
    d02 = normalize(d1, d02), r0 = interpolate2(r1, r0);
  else
    d02 = normalize(d02, d1), r0 = interpolate2(r0, r1);
  return function(x6) {
    return r0(d02(x6));
  };
}
function polymap(domain, range4, interpolate2) {
  var j5 = Math.min(domain.length, range4.length) - 1, d6 = new Array(j5), r6 = new Array(j5), i6 = -1;
  if (domain[j5] < domain[0]) {
    domain = domain.slice().reverse();
    range4 = range4.slice().reverse();
  }
  while (++i6 < j5) {
    d6[i6] = normalize(domain[i6], domain[i6 + 1]);
    r6[i6] = interpolate2(range4[i6], range4[i6 + 1]);
  }
  return function(x6) {
    var i7 = bisect_default(domain, x6, 1, j5) - 1;
    return r6[i7](d6[i7](x6));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer2() {
  var domain = unit, range4 = unit, interpolate2 = value_default, transform2, untransform, unknown, clamp2 = identity4, piecewise2, output, input;
  function rescale() {
    var n9 = Math.min(domain.length, range4.length);
    if (clamp2 !== identity4)
      clamp2 = clamper(domain[0], domain[n9 - 1]);
    piecewise2 = n9 > 2 ? polymap : bimap;
    output = input = null;
    return scale2;
  }
  function scale2(x6) {
    return x6 == null || isNaN(x6 = +x6) ? unknown : (output || (output = piecewise2(domain.map(transform2), range4, interpolate2)))(transform2(clamp2(x6)));
  }
  scale2.invert = function(y5) {
    return clamp2(untransform((input || (input = piecewise2(range4, domain.map(transform2), number_default)))(y5)));
  };
  scale2.domain = function(_4) {
    return arguments.length ? (domain = Array.from(_4, number3), rescale()) : domain.slice();
  };
  scale2.range = function(_4) {
    return arguments.length ? (range4 = Array.from(_4), rescale()) : range4.slice();
  };
  scale2.rangeRound = function(_4) {
    return range4 = Array.from(_4), interpolate2 = round_default, rescale();
  };
  scale2.clamp = function(_4) {
    return arguments.length ? (clamp2 = _4 ? true : identity4, rescale()) : clamp2 !== identity4;
  };
  scale2.interpolate = function(_4) {
    return arguments.length ? (interpolate2 = _4, rescale()) : interpolate2;
  };
  scale2.unknown = function(_4) {
    return arguments.length ? (unknown = _4, scale2) : unknown;
  };
  return function(t6, u5) {
    transform2 = t6, untransform = u5;
    return rescale();
  };
}
function continuous() {
  return transformer2()(identity4, identity4);
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start2, stop, count2, specifier) {
  var step = tickStep(start2, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale2) {
  var domain = scale2.domain;
  scale2.ticks = function(count2) {
    var d6 = domain();
    return ticks(d6[0], d6[d6.length - 1], count2 == null ? 10 : count2);
  };
  scale2.tickFormat = function(count2, specifier) {
    var d6 = domain();
    return tickFormat(d6[0], d6[d6.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale2.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d6 = domain();
    var i0 = 0;
    var i1 = d6.length - 1;
    var start2 = d6[i0];
    var stop = d6[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count2);
      if (step === prestep) {
        d6[i0] = start2;
        d6[i1] = stop;
        return domain(d6);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale2;
  };
  return scale2;
}
function linear2() {
  var scale2 = continuous();
  scale2.copy = function() {
    return copy(scale2, linear2());
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}

// node_modules/d3-scale/src/identity.js
function identity5(domain) {
  var unknown;
  function scale2(x6) {
    return x6 == null || isNaN(x6 = +x6) ? unknown : x6;
  }
  scale2.invert = scale2;
  scale2.domain = scale2.range = function(_4) {
    return arguments.length ? (domain = Array.from(_4, number3), scale2) : domain.slice();
  };
  scale2.unknown = function(_4) {
    return arguments.length ? (unknown = _4, scale2) : unknown;
  };
  scale2.copy = function() {
    return identity5(domain).unknown(unknown);
  };
  domain = arguments.length ? Array.from(domain, number3) : [0, 1];
  return linearish(scale2);
}

// node_modules/d3-scale/src/nice.js
function nice(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x05 = domain[i0], x12 = domain[i1], t6;
  if (x12 < x05) {
    t6 = i0, i0 = i1, i1 = t6;
    t6 = x05, x05 = x12, x12 = t6;
  }
  domain[i0] = interval2.floor(x05);
  domain[i1] = interval2.ceil(x12);
  return domain;
}

// node_modules/d3-scale/src/log.js
function transformLog(x6) {
  return Math.log(x6);
}
function transformExp(x6) {
  return Math.exp(x6);
}
function transformLogn(x6) {
  return -Math.log(-x6);
}
function transformExpn(x6) {
  return -Math.exp(-x6);
}
function pow10(x6) {
  return isFinite(x6) ? +("1e" + x6) : x6 < 0 ? 0 : x6;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x6) => Math.pow(base, x6);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x6) => Math.log(x6) / base);
}
function reflect(f4) {
  return (x6, k6) => -f4(-x6, k6);
}
function loggish(transform2) {
  const scale2 = transform2(transformLog, transformExp);
  const domain = scale2.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform2(transformLogn, transformExpn);
    } else {
      transform2(transformLog, transformExp);
    }
    return scale2;
  }
  scale2.base = function(_4) {
    return arguments.length ? (base = +_4, rescale()) : base;
  };
  scale2.domain = function(_4) {
    return arguments.length ? (domain(_4), rescale()) : domain();
  };
  scale2.ticks = (count2) => {
    const d6 = domain();
    let u5 = d6[0];
    let v4 = d6[d6.length - 1];
    const r6 = v4 < u5;
    if (r6)
      [u5, v4] = [v4, u5];
    let i6 = logs(u5);
    let j5 = logs(v4);
    let k6;
    let t6;
    const n9 = count2 == null ? 10 : +count2;
    let z5 = [];
    if (!(base % 1) && j5 - i6 < n9) {
      i6 = Math.floor(i6), j5 = Math.ceil(j5);
      if (u5 > 0)
        for (; i6 <= j5; ++i6) {
          for (k6 = 1; k6 < base; ++k6) {
            t6 = i6 < 0 ? k6 / pows(-i6) : k6 * pows(i6);
            if (t6 < u5)
              continue;
            if (t6 > v4)
              break;
            z5.push(t6);
          }
        }
      else
        for (; i6 <= j5; ++i6) {
          for (k6 = base - 1; k6 >= 1; --k6) {
            t6 = i6 > 0 ? k6 / pows(-i6) : k6 * pows(i6);
            if (t6 < u5)
              continue;
            if (t6 > v4)
              break;
            z5.push(t6);
          }
        }
      if (z5.length * 2 < n9)
        z5 = ticks(u5, v4, n9);
    } else {
      z5 = ticks(i6, j5, Math.min(j5 - i6, n9)).map(pows);
    }
    return r6 ? z5.reverse() : z5;
  };
  scale2.tickFormat = (count2, specifier) => {
    if (count2 == null)
      count2 = 10;
    if (specifier == null)
      specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)
        specifier.trim = true;
      specifier = format(specifier);
    }
    if (count2 === Infinity)
      return specifier;
    const k6 = Math.max(1, base * count2 / scale2.ticks().length);
    return (d6) => {
      let i6 = d6 / pows(Math.round(logs(d6)));
      if (i6 * base < base - 0.5)
        i6 *= base;
      return i6 <= k6 ? specifier(d6) : "";
    };
  };
  scale2.nice = () => {
    return domain(nice(domain(), {
      floor: (x6) => pows(Math.floor(logs(x6))),
      ceil: (x6) => pows(Math.ceil(logs(x6)))
    }));
  };
  return scale2;
}
function log2() {
  const scale2 = loggish(transformer2()).domain([1, 10]);
  scale2.copy = () => copy(scale2, log2()).base(scale2.base());
  initRange.apply(scale2, arguments);
  return scale2;
}

// node_modules/d3-scale/src/symlog.js
function transformSymlog(c9) {
  return function(x6) {
    return Math.sign(x6) * Math.log1p(Math.abs(x6 / c9));
  };
}
function transformSymexp(c9) {
  return function(x6) {
    return Math.sign(x6) * Math.expm1(Math.abs(x6)) * c9;
  };
}
function symlogish(transform2) {
  var c9 = 1, scale2 = transform2(transformSymlog(c9), transformSymexp(c9));
  scale2.constant = function(_4) {
    return arguments.length ? transform2(transformSymlog(c9 = +_4), transformSymexp(c9)) : c9;
  };
  return linearish(scale2);
}
function symlog() {
  var scale2 = symlogish(transformer2());
  scale2.copy = function() {
    return copy(scale2, symlog()).constant(scale2.constant());
  };
  return initRange.apply(scale2, arguments);
}

// node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x6) {
    return x6 < 0 ? -Math.pow(-x6, exponent) : Math.pow(x6, exponent);
  };
}
function transformSqrt(x6) {
  return x6 < 0 ? -Math.sqrt(-x6) : Math.sqrt(x6);
}
function transformSquare(x6) {
  return x6 < 0 ? -x6 * x6 : x6 * x6;
}
function powish(transform2) {
  var scale2 = transform2(identity4, identity4), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform2(identity4, identity4) : exponent === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent), transformPow(1 / exponent));
  }
  scale2.exponent = function(_4) {
    return arguments.length ? (exponent = +_4, rescale()) : exponent;
  };
  return linearish(scale2);
}
function pow2() {
  var scale2 = powish(transformer2());
  scale2.copy = function() {
    return copy(scale2, pow2()).exponent(scale2.exponent());
  };
  initRange.apply(scale2, arguments);
  return scale2;
}

// node_modules/d3-scale/src/quantile.js
function quantile2() {
  var domain = [], range4 = [], thresholds = [], unknown;
  function rescale() {
    var i6 = 0, n9 = Math.max(1, range4.length);
    thresholds = new Array(n9 - 1);
    while (++i6 < n9)
      thresholds[i6 - 1] = quantileSorted(domain, i6 / n9);
    return scale2;
  }
  function scale2(x6) {
    return x6 == null || isNaN(x6 = +x6) ? unknown : range4[bisect_default(thresholds, x6)];
  }
  scale2.invertExtent = function(y5) {
    var i6 = range4.indexOf(y5);
    return i6 < 0 ? [NaN, NaN] : [
      i6 > 0 ? thresholds[i6 - 1] : domain[0],
      i6 < thresholds.length ? thresholds[i6] : domain[domain.length - 1]
    ];
  };
  scale2.domain = function(_4) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (let d6 of _4)
      if (d6 != null && !isNaN(d6 = +d6))
        domain.push(d6);
    domain.sort(ascending);
    return rescale();
  };
  scale2.range = function(_4) {
    return arguments.length ? (range4 = Array.from(_4), rescale()) : range4.slice();
  };
  scale2.unknown = function(_4) {
    return arguments.length ? (unknown = _4, scale2) : unknown;
  };
  scale2.quantiles = function() {
    return thresholds.slice();
  };
  scale2.copy = function() {
    return quantile2().domain(domain).range(range4).unknown(unknown);
  };
  return initRange.apply(scale2, arguments);
}

// node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain = [0.5], range4 = [0, 1], unknown, n9 = 1;
  function scale2(x6) {
    return x6 != null && x6 <= x6 ? range4[bisect_default(domain, x6, 0, n9)] : unknown;
  }
  scale2.domain = function(_4) {
    return arguments.length ? (domain = Array.from(_4), n9 = Math.min(domain.length, range4.length - 1), scale2) : domain.slice();
  };
  scale2.range = function(_4) {
    return arguments.length ? (range4 = Array.from(_4), n9 = Math.min(domain.length, range4.length - 1), scale2) : range4.slice();
  };
  scale2.invertExtent = function(y5) {
    var i6 = range4.indexOf(y5);
    return [domain[i6 - 1], domain[i6]];
  };
  scale2.unknown = function(_4) {
    return arguments.length ? (unknown = _4, scale2) : unknown;
  };
  scale2.copy = function() {
    return threshold().domain(domain).range(range4).unknown(unknown);
  };
  return initRange.apply(scale2, arguments);
}

// node_modules/d3-time/src/interval.js
var t02 = /* @__PURE__ */ new Date();
var t12 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count2, field2) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval2.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval2.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = (date2) => {
    const d02 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d02 < d1 - date2 ? d02 : d1;
  };
  interval2.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = (start2, stop, step) => {
    const range4 = [];
    start2 = interval2.ceil(start2);
    step = step == null ? 1 : Math.floor(step);
    if (!(start2 < stop) || !(step > 0))
      return range4;
    let previous;
    do
      range4.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
    while (previous < start2 && start2 < stop);
    return range4;
  };
  interval2.filter = (test) => {
    return timeInterval((date2) => {
      if (date2 >= date2)
        while (floori(date2), !test(date2))
          date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
      }
    });
  };
  if (count2) {
    interval2.count = (start2, end) => {
      t02.setTime(+start2), t12.setTime(+end);
      floori(t02), floori(t12);
      return Math.floor(count2(t02, t12));
    };
    interval2.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field2 ? (d6) => field2(d6) % step === 0 : (d6) => interval2.count(0, d6) % step === 0);
    };
  }
  return interval2;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date2, step) => {
  date2.setTime(+date2 + step);
}, (start2, end) => {
  return end - start2;
});
millisecond.every = (k6) => {
  k6 = Math.floor(k6);
  if (!isFinite(k6) || !(k6 > 0))
    return null;
  if (!(k6 > 1))
    return millisecond;
  return timeInterval((date2) => {
    date2.setTime(Math.floor(date2 / k6) * k6);
  }, (date2, step) => {
    date2.setTime(+date2 + step * k6);
  }, (start2, end) => {
    return (end - start2) / k6;
  });
};
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start2, end) => {
  return (end - start2) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start2, end) => {
  return (end - start2) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start2, end) => {
  return (end - start2) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start2, end) => {
  return (end - start2) / durationHour;
}, (date2) => {
  return date2.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start2, end) => {
  return (end - start2) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
var utcHours = utcHour.range;

// node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start2, end) => {
  return (end - start2) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start2, end) => {
  return (end - start2) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
var unixDays = unixDay.range;

// node_modules/d3-time/src/week.js
function timeWeekday(i6) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i6) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start2, end) => {
    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i6) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i6) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start2, end) => {
    return (end - start2) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start2, end) => {
  return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start2, end) => {
  return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/year.js
var timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start2, end) => {
  return end.getFullYear() - start2.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k6) => {
  return !isFinite(k6 = Math.floor(k6)) || !(k6 > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k6) * k6);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k6);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start2, end) => {
  return end.getUTCFullYear() - start2.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k6) => {
  return !isFinite(k6 = Math.floor(k6)) || !(k6 > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k6) * k6);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k6);
  });
};
var utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start2, stop, count2) {
    const reverse2 = stop < start2;
    if (reverse2)
      [start2, stop] = [stop, start2];
    const interval2 = count2 && typeof count2.range === "function" ? count2 : tickInterval(start2, stop, count2);
    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
    return reverse2 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start2, stop, count2) {
    const target = Math.abs(stop - start2) / count2;
    const i6 = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i6 === tickIntervals.length)
      return year.every(tickStep(start2 / durationYear, stop / durationYear, count2));
    if (i6 === 0)
      return millisecond.every(Math.max(tickStep(start2, stop, count2), 1));
    const [t6, step] = tickIntervals[target / tickIntervals[i6 - 1][2] < tickIntervals[i6][2] / target ? i6 - 1 : i6];
    return t6.every(step);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// node_modules/d3-time-format/src/locale.js
function localDate(d6) {
  if (0 <= d6.y && d6.y < 100) {
    var date2 = new Date(-1, d6.m, d6.d, d6.H, d6.M, d6.S, d6.L);
    date2.setFullYear(d6.y);
    return date2;
  }
  return new Date(d6.y, d6.m, d6.d, d6.H, d6.M, d6.S, d6.L);
}
function utcDate(d6) {
  if (0 <= d6.y && d6.y < 100) {
    var date2 = new Date(Date.UTC(-1, d6.m, d6.d, d6.H, d6.M, d6.S, d6.L));
    date2.setUTCFullYear(d6.y);
    return date2;
  }
  return new Date(Date.UTC(d6.y, d6.m, d6.d, d6.H, d6.M, d6.S, d6.L));
}
function newDate(y5, m5, d6) {
  return { y: y5, m: m5, d: d6, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats2 = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats2.x = newFormat(locale_date, formats2);
  formats2.X = newFormat(locale_time, formats2);
  formats2.c = newFormat(locale_dateTime, formats2);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats3) {
    return function(date2) {
      var string2 = [], i6 = -1, j5 = 0, n9 = specifier.length, c9, pad4, format3;
      if (!(date2 instanceof Date))
        date2 = /* @__PURE__ */ new Date(+date2);
      while (++i6 < n9) {
        if (specifier.charCodeAt(i6) === 37) {
          string2.push(specifier.slice(j5, i6));
          if ((pad4 = pads[c9 = specifier.charAt(++i6)]) != null)
            c9 = specifier.charAt(++i6);
          else
            pad4 = c9 === "e" ? " " : "0";
          if (format3 = formats3[c9])
            c9 = format3(date2, pad4);
          string2.push(c9);
          j5 = i6 + 1;
        }
      }
      string2.push(specifier.slice(j5, i6));
      return string2.join("");
    };
  }
  function newParse(specifier, Z3) {
    return function(string2) {
      var d6 = newDate(1900, void 0, 1), i6 = parseSpecifier(d6, specifier, string2 += "", 0), week, day;
      if (i6 != string2.length)
        return null;
      if ("Q" in d6)
        return new Date(d6.Q);
      if ("s" in d6)
        return new Date(d6.s * 1e3 + ("L" in d6 ? d6.L : 0));
      if (Z3 && !("Z" in d6))
        d6.Z = 0;
      if ("p" in d6)
        d6.H = d6.H % 12 + d6.p * 12;
      if (d6.m === void 0)
        d6.m = "q" in d6 ? d6.q : 0;
      if ("V" in d6) {
        if (d6.V < 1 || d6.V > 53)
          return null;
        if (!("w" in d6))
          d6.w = 1;
        if ("Z" in d6) {
          week = utcDate(newDate(d6.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d6.V - 1) * 7);
          d6.y = week.getUTCFullYear();
          d6.m = week.getUTCMonth();
          d6.d = week.getUTCDate() + (d6.w + 6) % 7;
        } else {
          week = localDate(newDate(d6.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d6.V - 1) * 7);
          d6.y = week.getFullYear();
          d6.m = week.getMonth();
          d6.d = week.getDate() + (d6.w + 6) % 7;
        }
      } else if ("W" in d6 || "U" in d6) {
        if (!("w" in d6))
          d6.w = "u" in d6 ? d6.u % 7 : "W" in d6 ? 1 : 0;
        day = "Z" in d6 ? utcDate(newDate(d6.y, 0, 1)).getUTCDay() : localDate(newDate(d6.y, 0, 1)).getDay();
        d6.m = 0;
        d6.d = "W" in d6 ? (d6.w + 6) % 7 + d6.W * 7 - (day + 5) % 7 : d6.w + d6.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d6) {
        d6.H += d6.Z / 100 | 0;
        d6.M += d6.Z % 100;
        return utcDate(d6);
      }
      return localDate(d6);
    };
  }
  function parseSpecifier(d6, specifier, string2, j5) {
    var i6 = 0, n9 = specifier.length, m5 = string2.length, c9, parse3;
    while (i6 < n9) {
      if (j5 >= m5)
        return -1;
      c9 = specifier.charCodeAt(i6++);
      if (c9 === 37) {
        c9 = specifier.charAt(i6++);
        parse3 = parses[c9 in pads ? specifier.charAt(i6++) : c9];
        if (!parse3 || (j5 = parse3(d6, string2, j5)) < 0)
          return -1;
      } else if (c9 != string2.charCodeAt(j5++)) {
        return -1;
      }
    }
    return j5;
  }
  function parsePeriod(d6, string2, i6) {
    var n9 = periodRe.exec(string2.slice(i6));
    return n9 ? (d6.p = periodLookup.get(n9[0].toLowerCase()), i6 + n9[0].length) : -1;
  }
  function parseShortWeekday(d6, string2, i6) {
    var n9 = shortWeekdayRe.exec(string2.slice(i6));
    return n9 ? (d6.w = shortWeekdayLookup.get(n9[0].toLowerCase()), i6 + n9[0].length) : -1;
  }
  function parseWeekday(d6, string2, i6) {
    var n9 = weekdayRe.exec(string2.slice(i6));
    return n9 ? (d6.w = weekdayLookup.get(n9[0].toLowerCase()), i6 + n9[0].length) : -1;
  }
  function parseShortMonth(d6, string2, i6) {
    var n9 = shortMonthRe.exec(string2.slice(i6));
    return n9 ? (d6.m = shortMonthLookup.get(n9[0].toLowerCase()), i6 + n9[0].length) : -1;
  }
  function parseMonth(d6, string2, i6) {
    var n9 = monthRe.exec(string2.slice(i6));
    return n9 ? (d6.m = monthLookup.get(n9[0].toLowerCase()), i6 + n9[0].length) : -1;
  }
  function parseLocaleDateTime(d6, string2, i6) {
    return parseSpecifier(d6, locale_dateTime, string2, i6);
  }
  function parseLocaleDate(d6, string2, i6) {
    return parseSpecifier(d6, locale_date, string2, i6);
  }
  function parseLocaleTime(d6, string2, i6) {
    return parseSpecifier(d6, locale_time, string2, i6);
  }
  function formatShortWeekday(d6) {
    return locale_shortWeekdays[d6.getDay()];
  }
  function formatWeekday(d6) {
    return locale_weekdays[d6.getDay()];
  }
  function formatShortMonth(d6) {
    return locale_shortMonths[d6.getMonth()];
  }
  function formatMonth(d6) {
    return locale_months[d6.getMonth()];
  }
  function formatPeriod(d6) {
    return locale_periods[+(d6.getHours() >= 12)];
  }
  function formatQuarter(d6) {
    return 1 + ~~(d6.getMonth() / 3);
  }
  function formatUTCShortWeekday(d6) {
    return locale_shortWeekdays[d6.getUTCDay()];
  }
  function formatUTCWeekday(d6) {
    return locale_weekdays[d6.getUTCDay()];
  }
  function formatUTCShortMonth(d6) {
    return locale_shortMonths[d6.getUTCMonth()];
  }
  function formatUTCMonth(d6) {
    return locale_months[d6.getUTCMonth()];
  }
  function formatUTCPeriod(d6) {
    return locale_periods[+(d6.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d6) {
    return 1 + ~~(d6.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f4 = newFormat(specifier += "", formats2);
      f4.toString = function() {
        return specifier;
      };
      return f4;
    },
    parse: function(specifier) {
      var p5 = newParse(specifier += "", false);
      p5.toString = function() {
        return specifier;
      };
      return p5;
    },
    utcFormat: function(specifier) {
      var f4 = newFormat(specifier += "", utcFormats);
      f4.toString = function() {
        return specifier;
      };
      return f4;
    },
    utcParse: function(specifier) {
      var p5 = newParse(specifier += "", true);
      p5.toString = function() {
        return specifier;
      };
      return p5;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
  var sign3 = value < 0 ? "-" : "", string2 = (sign3 ? -value : value) + "", length3 = string2.length;
  return sign3 + (length3 < width ? new Array(width - length3 + 1).join(fill) + string2 : string2);
}
function requote(s8) {
  return s8.replace(requoteRe, "\\$&");
}
function formatRe(names2) {
  return new RegExp("^(?:" + names2.map(requote).join("|") + ")", "i");
}
function formatLookup(names2) {
  return new Map(names2.map((name, i6) => [name.toLowerCase(), i6]));
}
function parseWeekdayNumberSunday(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 1));
  return n9 ? (d6.w = +n9[0], i6 + n9[0].length) : -1;
}
function parseWeekdayNumberMonday(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 1));
  return n9 ? (d6.u = +n9[0], i6 + n9[0].length) : -1;
}
function parseWeekNumberSunday(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 2));
  return n9 ? (d6.U = +n9[0], i6 + n9[0].length) : -1;
}
function parseWeekNumberISO(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 2));
  return n9 ? (d6.V = +n9[0], i6 + n9[0].length) : -1;
}
function parseWeekNumberMonday(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 2));
  return n9 ? (d6.W = +n9[0], i6 + n9[0].length) : -1;
}
function parseFullYear(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 4));
  return n9 ? (d6.y = +n9[0], i6 + n9[0].length) : -1;
}
function parseYear(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 2));
  return n9 ? (d6.y = +n9[0] + (+n9[0] > 68 ? 1900 : 2e3), i6 + n9[0].length) : -1;
}
function parseZone(d6, string2, i6) {
  var n9 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i6, i6 + 6));
  return n9 ? (d6.Z = n9[1] ? 0 : -(n9[2] + (n9[3] || "00")), i6 + n9[0].length) : -1;
}
function parseQuarter(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 1));
  return n9 ? (d6.q = n9[0] * 3 - 3, i6 + n9[0].length) : -1;
}
function parseMonthNumber(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 2));
  return n9 ? (d6.m = n9[0] - 1, i6 + n9[0].length) : -1;
}
function parseDayOfMonth(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 2));
  return n9 ? (d6.d = +n9[0], i6 + n9[0].length) : -1;
}
function parseDayOfYear(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 3));
  return n9 ? (d6.m = 0, d6.d = +n9[0], i6 + n9[0].length) : -1;
}
function parseHour24(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 2));
  return n9 ? (d6.H = +n9[0], i6 + n9[0].length) : -1;
}
function parseMinutes(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 2));
  return n9 ? (d6.M = +n9[0], i6 + n9[0].length) : -1;
}
function parseSeconds(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 2));
  return n9 ? (d6.S = +n9[0], i6 + n9[0].length) : -1;
}
function parseMilliseconds(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 3));
  return n9 ? (d6.L = +n9[0], i6 + n9[0].length) : -1;
}
function parseMicroseconds(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6, i6 + 6));
  return n9 ? (d6.L = Math.floor(n9[0] / 1e3), i6 + n9[0].length) : -1;
}
function parseLiteralPercent(d6, string2, i6) {
  var n9 = percentRe.exec(string2.slice(i6, i6 + 1));
  return n9 ? i6 + n9[0].length : -1;
}
function parseUnixTimestamp(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6));
  return n9 ? (d6.Q = +n9[0], i6 + n9[0].length) : -1;
}
function parseUnixTimestampSeconds(d6, string2, i6) {
  var n9 = numberRe.exec(string2.slice(i6));
  return n9 ? (d6.s = +n9[0], i6 + n9[0].length) : -1;
}
function formatDayOfMonth(d6, p5) {
  return pad(d6.getDate(), p5, 2);
}
function formatHour24(d6, p5) {
  return pad(d6.getHours(), p5, 2);
}
function formatHour12(d6, p5) {
  return pad(d6.getHours() % 12 || 12, p5, 2);
}
function formatDayOfYear(d6, p5) {
  return pad(1 + timeDay.count(timeYear(d6), d6), p5, 3);
}
function formatMilliseconds(d6, p5) {
  return pad(d6.getMilliseconds(), p5, 3);
}
function formatMicroseconds(d6, p5) {
  return formatMilliseconds(d6, p5) + "000";
}
function formatMonthNumber(d6, p5) {
  return pad(d6.getMonth() + 1, p5, 2);
}
function formatMinutes(d6, p5) {
  return pad(d6.getMinutes(), p5, 2);
}
function formatSeconds(d6, p5) {
  return pad(d6.getSeconds(), p5, 2);
}
function formatWeekdayNumberMonday(d6) {
  var day = d6.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d6, p5) {
  return pad(timeSunday.count(timeYear(d6) - 1, d6), p5, 2);
}
function dISO(d6) {
  var day = d6.getDay();
  return day >= 4 || day === 0 ? timeThursday(d6) : timeThursday.ceil(d6);
}
function formatWeekNumberISO(d6, p5) {
  d6 = dISO(d6);
  return pad(timeThursday.count(timeYear(d6), d6) + (timeYear(d6).getDay() === 4), p5, 2);
}
function formatWeekdayNumberSunday(d6) {
  return d6.getDay();
}
function formatWeekNumberMonday(d6, p5) {
  return pad(timeMonday.count(timeYear(d6) - 1, d6), p5, 2);
}
function formatYear(d6, p5) {
  return pad(d6.getFullYear() % 100, p5, 2);
}
function formatYearISO(d6, p5) {
  d6 = dISO(d6);
  return pad(d6.getFullYear() % 100, p5, 2);
}
function formatFullYear(d6, p5) {
  return pad(d6.getFullYear() % 1e4, p5, 4);
}
function formatFullYearISO(d6, p5) {
  var day = d6.getDay();
  d6 = day >= 4 || day === 0 ? timeThursday(d6) : timeThursday.ceil(d6);
  return pad(d6.getFullYear() % 1e4, p5, 4);
}
function formatZone(d6) {
  var z5 = d6.getTimezoneOffset();
  return (z5 > 0 ? "-" : (z5 *= -1, "+")) + pad(z5 / 60 | 0, "0", 2) + pad(z5 % 60, "0", 2);
}
function formatUTCDayOfMonth(d6, p5) {
  return pad(d6.getUTCDate(), p5, 2);
}
function formatUTCHour24(d6, p5) {
  return pad(d6.getUTCHours(), p5, 2);
}
function formatUTCHour12(d6, p5) {
  return pad(d6.getUTCHours() % 12 || 12, p5, 2);
}
function formatUTCDayOfYear(d6, p5) {
  return pad(1 + utcDay.count(utcYear(d6), d6), p5, 3);
}
function formatUTCMilliseconds(d6, p5) {
  return pad(d6.getUTCMilliseconds(), p5, 3);
}
function formatUTCMicroseconds(d6, p5) {
  return formatUTCMilliseconds(d6, p5) + "000";
}
function formatUTCMonthNumber(d6, p5) {
  return pad(d6.getUTCMonth() + 1, p5, 2);
}
function formatUTCMinutes(d6, p5) {
  return pad(d6.getUTCMinutes(), p5, 2);
}
function formatUTCSeconds(d6, p5) {
  return pad(d6.getUTCSeconds(), p5, 2);
}
function formatUTCWeekdayNumberMonday(d6) {
  var dow = d6.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d6, p5) {
  return pad(utcSunday.count(utcYear(d6) - 1, d6), p5, 2);
}
function UTCdISO(d6) {
  var day = d6.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d6) : utcThursday.ceil(d6);
}
function formatUTCWeekNumberISO(d6, p5) {
  d6 = UTCdISO(d6);
  return pad(utcThursday.count(utcYear(d6), d6) + (utcYear(d6).getUTCDay() === 4), p5, 2);
}
function formatUTCWeekdayNumberSunday(d6) {
  return d6.getUTCDay();
}
function formatUTCWeekNumberMonday(d6, p5) {
  return pad(utcMonday.count(utcYear(d6) - 1, d6), p5, 2);
}
function formatUTCYear(d6, p5) {
  return pad(d6.getUTCFullYear() % 100, p5, 2);
}
function formatUTCYearISO(d6, p5) {
  d6 = UTCdISO(d6);
  return pad(d6.getUTCFullYear() % 100, p5, 2);
}
function formatUTCFullYear(d6, p5) {
  return pad(d6.getUTCFullYear() % 1e4, p5, 4);
}
function formatUTCFullYearISO(d6, p5) {
  var day = d6.getUTCDay();
  d6 = day >= 4 || day === 0 ? utcThursday(d6) : utcThursday.ceil(d6);
  return pad(d6.getUTCFullYear() % 1e4, p5, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d6) {
  return +d6;
}
function formatUnixTimestampSeconds(d6) {
  return Math.floor(+d6 / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-scale/src/time.js
function date(t6) {
  return new Date(t6);
}
function number4(t6) {
  return t6 instanceof Date ? +t6 : +/* @__PURE__ */ new Date(+t6);
}
function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3) {
  var scale2 = continuous(), invert = scale2.invert, domain = scale2.domain;
  var formatMillisecond = format3(".%L"), formatSecond = format3(":%S"), formatMinute = format3("%I:%M"), formatHour = format3("%I %p"), formatDay = format3("%a %d"), formatWeek = format3("%b %d"), formatMonth = format3("%B"), formatYear3 = format3("%Y");
  function tickFormat2(date2) {
    return (second3(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear3)(date2);
  }
  scale2.invert = function(y5) {
    return new Date(invert(y5));
  };
  scale2.domain = function(_4) {
    return arguments.length ? domain(Array.from(_4, number4)) : domain().map(date);
  };
  scale2.ticks = function(interval2) {
    var d6 = domain();
    return ticks2(d6[0], d6[d6.length - 1], interval2 == null ? 10 : interval2);
  };
  scale2.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format3(specifier);
  };
  scale2.nice = function(interval2) {
    var d6 = domain();
    if (!interval2 || typeof interval2.range !== "function")
      interval2 = tickInterval(d6[0], d6[d6.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice(d6, interval2)) : scale2;
  };
  scale2.copy = function() {
    return copy(scale2, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3));
  };
  return scale2;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/sequential.js
function copy2(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}

// node_modules/d3-scale/src/diverging.js
function transformer3() {
  var x05 = 0, x12 = 0.5, x22 = 1, s8 = 1, t03, t13, t23, k10, k21, interpolator = identity4, transform2, clamp2 = false, unknown;
  function scale2(x6) {
    return isNaN(x6 = +x6) ? unknown : (x6 = 0.5 + ((x6 = +transform2(x6)) - t13) * (s8 * x6 < s8 * t13 ? k10 : k21), interpolator(clamp2 ? Math.max(0, Math.min(1, x6)) : x6));
  }
  scale2.domain = function(_4) {
    return arguments.length ? ([x05, x12, x22] = _4, t03 = transform2(x05 = +x05), t13 = transform2(x12 = +x12), t23 = transform2(x22 = +x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t23 ? 0 : 0.5 / (t23 - t13), s8 = t13 < t03 ? -1 : 1, scale2) : [x05, x12, x22];
  };
  scale2.clamp = function(_4) {
    return arguments.length ? (clamp2 = !!_4, scale2) : clamp2;
  };
  scale2.interpolator = function(_4) {
    return arguments.length ? (interpolator = _4, scale2) : interpolator;
  };
  function range4(interpolate2) {
    return function(_4) {
      var r0, r1, r22;
      return arguments.length ? ([r0, r1, r22] = _4, interpolator = piecewise(interpolate2, [r0, r1, r22]), scale2) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale2.range = range4(value_default);
  scale2.rangeRound = range4(round_default);
  scale2.unknown = function(_4) {
    return arguments.length ? (unknown = _4, scale2) : unknown;
  };
  return function(t6) {
    transform2 = t6, t03 = t6(x05), t13 = t6(x12), t23 = t6(x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t23 ? 0 : 0.5 / (t23 - t13), s8 = t13 < t03 ? -1 : 1;
    return scale2;
  };
}
function diverging() {
  var scale2 = linearish(transformer3()(identity4));
  scale2.copy = function() {
    return copy2(scale2, diverging());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingLog() {
  var scale2 = loggish(transformer3()).domain([0.1, 1, 10]);
  scale2.copy = function() {
    return copy2(scale2, divergingLog()).base(scale2.base());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingSymlog() {
  var scale2 = symlogish(transformer3());
  scale2.copy = function() {
    return copy2(scale2, divergingSymlog()).constant(scale2.constant());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingPow() {
  var scale2 = powish(transformer3());
  scale2.copy = function() {
    return copy2(scale2, divergingPow()).exponent(scale2.exponent());
  };
  return initInterpolator.apply(scale2, arguments);
}

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n9 = specifier.length / 6 | 0, colors2 = new Array(n9), i6 = 0;
  while (i6 < n9)
    colors2[i6] = "#" + specifier.slice(i6 * 6, ++i6 * 6);
  return colors2;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
function cividis_default(t6) {
  t6 = Math.max(0, Math.min(1, t6));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t6 * (35.34 - t6 * (2381.73 - t6 * (6402.7 - t6 * (7024.72 - t6 * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t6 * (170.73 + t6 * (52.82 - t6 * (131.46 - t6 * (176.58 - t6 * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t6 * (442.36 - t6 * (2482.43 - t6 * (6167.24 - t6 * (6614.94 - t6 * 2475.67))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c5 = cubehelix();
function rainbow_default(t6) {
  if (t6 < 0 || t6 > 1)
    t6 -= Math.floor(t6);
  var ts = Math.abs(t6 - 0.5);
  c5.h = 360 * t6 - 100;
  c5.s = 1.5 - 1.5 * ts;
  c5.l = 0.8 - 0.9 * ts;
  return c5 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c6 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;
function sinebow_default(t6) {
  var x6;
  t6 = (0.5 - t6) * Math.PI;
  c6.r = 255 * (x6 = Math.sin(t6)) * x6;
  c6.g = 255 * (x6 = Math.sin(t6 + pi_1_3)) * x6;
  c6.b = 255 * (x6 = Math.sin(t6 + pi_2_3)) * x6;
  return c6 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
function turbo_default(t6) {
  t6 = Math.max(0, Math.min(1, t6));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t6 * (1172.33 - t6 * (10793.56 - t6 * (33300.12 - t6 * (38394.49 - t6 * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t6 * (557.33 + t6 * (1225.33 - t6 * (3574.96 - t6 * (1073.77 + t6 * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t6 * (3211.1 - t6 * (15327.97 - t6 * (27814 - t6 * (22569.18 - t6 * 6838.66))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range4) {
  var n9 = range4.length;
  return function(t6) {
    return range4[Math.max(0, Math.min(n9 - 1, Math.floor(t6 * n9)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/d3-shape/src/constant.js
function constant_default5(x6) {
  return function constant3() {
    return x6;
  };
}

// node_modules/d3-shape/src/math.js
var cos2 = Math.cos;
var min3 = Math.min;
var sin2 = Math.sin;
var sqrt3 = Math.sqrt;
var epsilon4 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var tau3 = 2 * pi3;

// node_modules/d3-shape/src/path.js
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_4) {
    if (!arguments.length)
      return digits;
    if (_4 == null) {
      digits = null;
    } else {
      const d6 = Math.floor(_4);
      if (!(d6 >= 0))
        throw new RangeError(`invalid digits: ${_4}`);
      digits = d6;
    }
    return shape;
  };
  return () => new Path(digits);
}

// node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;
function array_default(x6) {
  return typeof x6 === "object" && "length" in x6 ? x6 : Array.from(x6);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y5) {
    x6 = +x6, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x6, y5) : this._context.moveTo(x6, y5);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x6, y5);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-shape/src/point.js
function x5(p5) {
  return p5[0];
}
function y4(p5) {
  return p5[1];
}

// node_modules/d3-shape/src/line.js
function line_default2(x6, y5) {
  var defined2 = constant_default5(true), context = null, curve = linear_default, output = null, path2 = withPath(line);
  x6 = typeof x6 === "function" ? x6 : x6 === void 0 ? x5 : constant_default5(x6);
  y5 = typeof y5 === "function" ? y5 : y5 === void 0 ? y4 : constant_default5(y5);
  function line(data) {
    var i6, n9 = (data = array_default(data)).length, d6, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path2());
    for (i6 = 0; i6 <= n9; ++i6) {
      if (!(i6 < n9 && defined2(d6 = data[i6], i6, data)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x6(d6, i6, data), +y5(d6, i6, data));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line.x = function(_4) {
    return arguments.length ? (x6 = typeof _4 === "function" ? _4 : constant_default5(+_4), line) : x6;
  };
  line.y = function(_4) {
    return arguments.length ? (y5 = typeof _4 === "function" ? _4 : constant_default5(+_4), line) : y5;
  };
  line.defined = function(_4) {
    return arguments.length ? (defined2 = typeof _4 === "function" ? _4 : constant_default5(!!_4), line) : defined2;
  };
  line.curve = function(_4) {
    return arguments.length ? (curve = _4, context != null && (output = curve(context)), line) : curve;
  };
  line.context = function(_4) {
    return arguments.length ? (_4 == null ? context = output = null : output = curve(context = _4), line) : context;
  };
  return line;
}

// node_modules/d3-shape/src/area.js
function area_default2(x05, y05, y12) {
  var x12 = null, defined2 = constant_default5(true), context = null, curve = linear_default, output = null, path2 = withPath(area2);
  x05 = typeof x05 === "function" ? x05 : x05 === void 0 ? x5 : constant_default5(+x05);
  y05 = typeof y05 === "function" ? y05 : y05 === void 0 ? constant_default5(0) : constant_default5(+y05);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y4 : constant_default5(+y12);
  function area2(data) {
    var i6, j5, k6, n9 = (data = array_default(data)).length, d6, defined0 = false, buffer, x0z = new Array(n9), y0z = new Array(n9);
    if (context == null)
      output = curve(buffer = path2());
    for (i6 = 0; i6 <= n9; ++i6) {
      if (!(i6 < n9 && defined2(d6 = data[i6], i6, data)) === defined0) {
        if (defined0 = !defined0) {
          j5 = i6;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k6 = i6 - 1; k6 >= j5; --k6) {
            output.point(x0z[k6], y0z[k6]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i6] = +x05(d6, i6, data), y0z[i6] = +y05(d6, i6, data);
        output.point(x12 ? +x12(d6, i6, data) : x0z[i6], y12 ? +y12(d6, i6, data) : y0z[i6]);
      }
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default2().defined(defined2).curve(curve).context(context);
  }
  area2.x = function(_4) {
    return arguments.length ? (x05 = typeof _4 === "function" ? _4 : constant_default5(+_4), x12 = null, area2) : x05;
  };
  area2.x0 = function(_4) {
    return arguments.length ? (x05 = typeof _4 === "function" ? _4 : constant_default5(+_4), area2) : x05;
  };
  area2.x1 = function(_4) {
    return arguments.length ? (x12 = _4 == null ? null : typeof _4 === "function" ? _4 : constant_default5(+_4), area2) : x12;
  };
  area2.y = function(_4) {
    return arguments.length ? (y05 = typeof _4 === "function" ? _4 : constant_default5(+_4), y12 = null, area2) : y05;
  };
  area2.y0 = function(_4) {
    return arguments.length ? (y05 = typeof _4 === "function" ? _4 : constant_default5(+_4), area2) : y05;
  };
  area2.y1 = function(_4) {
    return arguments.length ? (y12 = _4 == null ? null : typeof _4 === "function" ? _4 : constant_default5(+_4), area2) : y12;
  };
  area2.lineX0 = area2.lineY0 = function() {
    return arealine().x(x05).y(y05);
  };
  area2.lineY1 = function() {
    return arealine().x(x05).y(y12);
  };
  area2.lineX1 = function() {
    return arealine().x(x12).y(y05);
  };
  area2.defined = function(_4) {
    return arguments.length ? (defined2 = typeof _4 === "function" ? _4 : constant_default5(!!_4), area2) : defined2;
  };
  area2.curve = function(_4) {
    return arguments.length ? (curve = _4, context != null && (output = curve(context)), area2) : curve;
  };
  area2.context = function(_4) {
    return arguments.length ? (_4 == null ? context = output = null : output = curve(context = _4), area2) : context;
  };
  return area2;
}

// node_modules/d3-shape/src/curve/bump.js
var Bump = class {
  constructor(context, x6) {
    this._context = context;
    this._x = x6;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x6, y5) {
    x6 = +x6, y5 = +y5;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line)
          this._context.lineTo(x6, y5);
        else
          this._context.moveTo(x6, y5);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        if (this._x)
          this._context.bezierCurveTo(this._x0 = (this._x0 + x6) / 2, this._y0, this._x0, y5, x6, y5);
        else
          this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y5) / 2, x6, this._y0, x6, y5);
        break;
      }
    }
    this._x0 = x6, this._y0 = y5;
  }
};
function bumpX(context) {
  return new Bump(context, true);
}
function bumpY(context) {
  return new Bump(context, false);
}

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt32 = sqrt3(3);
var asterisk_default = {
  draw(context, size) {
    const r6 = sqrt3(size + min3(size / 28, 0.75)) * 0.59436;
    const t6 = r6 / 2;
    const u5 = t6 * sqrt32;
    context.moveTo(0, r6);
    context.lineTo(0, -r6);
    context.moveTo(-u5, -t6);
    context.lineTo(u5, t6);
    context.moveTo(-u5, t6);
    context.lineTo(u5, -t6);
  }
};

// node_modules/d3-shape/src/symbol/circle.js
var circle_default2 = {
  draw(context, size) {
    const r6 = sqrt3(size / pi3);
    context.moveTo(r6, 0);
    context.arc(0, 0, r6, 0, tau3);
  }
};

// node_modules/d3-shape/src/symbol/cross.js
var cross_default = {
  draw(context, size) {
    const r6 = sqrt3(size / 5) / 2;
    context.moveTo(-3 * r6, -r6);
    context.lineTo(-r6, -r6);
    context.lineTo(-r6, -3 * r6);
    context.lineTo(r6, -3 * r6);
    context.lineTo(r6, -r6);
    context.lineTo(3 * r6, -r6);
    context.lineTo(3 * r6, r6);
    context.lineTo(r6, r6);
    context.lineTo(r6, 3 * r6);
    context.lineTo(-r6, 3 * r6);
    context.lineTo(-r6, r6);
    context.lineTo(-3 * r6, r6);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt3(1 / 3);
var tan30_2 = tan30 * 2;
var diamond_default = {
  draw(context, size) {
    const y5 = sqrt3(size / tan30_2);
    const x6 = y5 * tan30;
    context.moveTo(0, -y5);
    context.lineTo(x6, 0);
    context.lineTo(0, y5);
    context.lineTo(-x6, 0);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/diamond2.js
var diamond2_default = {
  draw(context, size) {
    const r6 = sqrt3(size) * 0.62625;
    context.moveTo(0, -r6);
    context.lineTo(r6, 0);
    context.lineTo(0, r6);
    context.lineTo(-r6, 0);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/plus.js
var plus_default = {
  draw(context, size) {
    const r6 = sqrt3(size - min3(size / 7, 2)) * 0.87559;
    context.moveTo(-r6, 0);
    context.lineTo(r6, 0);
    context.moveTo(0, r6);
    context.lineTo(0, -r6);
  }
};

// node_modules/d3-shape/src/symbol/square.js
var square_default = {
  draw(context, size) {
    const w5 = sqrt3(size);
    const x6 = -w5 / 2;
    context.rect(x6, x6, w5, w5);
  }
};

// node_modules/d3-shape/src/symbol/square2.js
var square2_default = {
  draw(context, size) {
    const r6 = sqrt3(size) * 0.4431;
    context.moveTo(r6, r6);
    context.lineTo(r6, -r6);
    context.lineTo(-r6, -r6);
    context.lineTo(-r6, r6);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/star.js
var ka = 0.8908130915292852;
var kr = sin2(pi3 / 10) / sin2(7 * pi3 / 10);
var kx = sin2(tau3 / 10) * kr;
var ky = -cos2(tau3 / 10) * kr;
var star_default = {
  draw(context, size) {
    const r6 = sqrt3(size * ka);
    const x6 = kx * r6;
    const y5 = ky * r6;
    context.moveTo(0, -r6);
    context.lineTo(x6, y5);
    for (let i6 = 1; i6 < 5; ++i6) {
      const a7 = tau3 * i6 / 5;
      const c9 = cos2(a7);
      const s8 = sin2(a7);
      context.lineTo(s8 * r6, -c9 * r6);
      context.lineTo(c9 * x6 - s8 * y5, s8 * x6 + c9 * y5);
    }
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt33 = sqrt3(3);
var triangle_default = {
  draw(context, size) {
    const y5 = -sqrt3(size / (sqrt33 * 3));
    context.moveTo(0, y5 * 2);
    context.lineTo(-sqrt33 * y5, -y5);
    context.lineTo(sqrt33 * y5, -y5);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt34 = sqrt3(3);
var triangle2_default = {
  draw(context, size) {
    const s8 = sqrt3(size) * 0.6824;
    const t6 = s8 / 2;
    const u5 = s8 * sqrt34 / 2;
    context.moveTo(0, -s8);
    context.lineTo(u5, t6);
    context.lineTo(-u5, t6);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/wye.js
var c7 = -0.5;
var s7 = sqrt3(3) / 2;
var k5 = 1 / sqrt3(12);
var a5 = (k5 / 2 + 1) * 3;
var wye_default = {
  draw(context, size) {
    const r6 = sqrt3(size / a5);
    const x05 = r6 / 2, y05 = r6 * k5;
    const x12 = x05, y12 = r6 * k5 + r6;
    const x22 = -x12, y22 = y12;
    context.moveTo(x05, y05);
    context.lineTo(x12, y12);
    context.lineTo(x22, y22);
    context.lineTo(c7 * x05 - s7 * y05, s7 * x05 + c7 * y05);
    context.lineTo(c7 * x12 - s7 * y12, s7 * x12 + c7 * y12);
    context.lineTo(c7 * x22 - s7 * y22, s7 * x22 + c7 * y22);
    context.lineTo(c7 * x05 + s7 * y05, c7 * y05 - s7 * x05);
    context.lineTo(c7 * x12 + s7 * y12, c7 * y12 - s7 * x12);
    context.lineTo(c7 * x22 + s7 * y22, c7 * y22 - s7 * x22);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/times.js
var times_default = {
  draw(context, size) {
    const r6 = sqrt3(size - min3(size / 6, 1.7)) * 0.6189;
    context.moveTo(-r6, -r6);
    context.lineTo(r6, r6);
    context.moveTo(-r6, r6);
    context.lineTo(r6, -r6);
  }
};

// node_modules/d3-shape/src/symbol.js
var symbolsFill = [
  circle_default2,
  cross_default,
  diamond_default,
  square_default,
  star_default,
  triangle_default,
  wye_default
];
var symbolsStroke = [
  circle_default2,
  plus_default,
  times_default,
  triangle2_default,
  asterisk_default,
  square2_default,
  diamond2_default
];

// node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-shape/src/curve/basis.js
function point2(that, x6, y5) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x6) / 6,
    (that._y0 + 4 * that._y1 + y5) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point2(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y5) {
    x6 = +x6, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x6, y5) : this._context.moveTo(x6, y5);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point2(this, x6, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = x6;
    this._y0 = this._y1, this._y1 = y5;
  }
};
function basis_default2(context) {
  return new Basis(context);
}

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x6, y5) {
    x6 = +x6, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x6, this._y2 = y5;
        break;
      case 1:
        this._point = 2;
        this._x3 = x6, this._y3 = y5;
        break;
      case 2:
        this._point = 3;
        this._x4 = x6, this._y4 = y5;
        this._context.moveTo((this._x0 + 4 * this._x1 + x6) / 6, (this._y0 + 4 * this._y1 + y5) / 6);
        break;
      default:
        point2(this, x6, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = x6;
    this._y0 = this._y1, this._y1 = y5;
  }
};
function basisClosed_default2(context) {
  return new BasisClosed(context);
}

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y5) {
    x6 = +x6, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x05 = (this._x0 + 4 * this._x1 + x6) / 6, y05 = (this._y0 + 4 * this._y1 + y5) / 6;
        this._line ? this._context.lineTo(x05, y05) : this._context.moveTo(x05, y05);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x6, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = x6;
    this._y0 = this._y1, this._y1 = y5;
  }
};
function basisOpen_default(context) {
  return new BasisOpen(context);
}

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x6 = this._x, y5 = this._y, j5 = x6.length - 1;
    if (j5 > 0) {
      var x05 = x6[0], y05 = y5[0], dx = x6[j5] - x05, dy = y5[j5] - y05, i6 = -1, t6;
      while (++i6 <= j5) {
        t6 = i6 / j5;
        this._basis.point(
          this._beta * x6[i6] + (1 - this._beta) * (x05 + t6 * dx),
          this._beta * y5[i6] + (1 - this._beta) * (y05 + t6 * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x6, y5) {
    this._x.push(+x6);
    this._y.push(+y5);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point3(that, x6, y5) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x6),
    that._y2 + that._k * (that._y1 - y5),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point3(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y5) {
    x6 = +x6, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x6, y5) : this._context.moveTo(x6, y5);
        break;
      case 1:
        this._point = 2;
        this._x1 = x6, this._y1 = y5;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x6, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x6;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x6, y5) {
    x6 = +x6, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x6, this._y3 = y5;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x6, this._y4 = y5);
        break;
      case 2:
        this._point = 3;
        this._x5 = x6, this._y5 = y5;
        break;
      default:
        point3(this, x6, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x6;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y5) {
    x6 = +x6, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x6, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x6;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point4(that, x6, y5) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon4) {
    var a7 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n9 = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a7 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n9;
    y12 = (y12 * a7 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n9;
  }
  if (that._l23_a > epsilon4) {
    var b5 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m5 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b5 + that._x1 * that._l23_2a - x6 * that._l12_2a) / m5;
    y22 = (y22 * b5 + that._y1 * that._l23_2a - y5 * that._l12_2a) / m5;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y5) {
    x6 = +x6, y5 = +y5;
    if (this._point) {
      var x23 = this._x2 - x6, y23 = this._y2 - y5;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x6, y5) : this._context.moveTo(x6, y5);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point4(this, x6, y5);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x6;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x6, y5) {
    x6 = +x6, y5 = +y5;
    if (this._point) {
      var x23 = this._x2 - x6, y23 = this._y2 - y5;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x6, this._y3 = y5;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x6, this._y4 = y5);
        break;
      case 2:
        this._point = 3;
        this._x5 = x6, this._y5 = y5;
        break;
      default:
        point4(this, x6, y5);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x6;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y5) {
    x6 = +x6, y5 = +y5;
    if (this._point) {
      var x23 = this._x2 - x6, y23 = this._y2 - y5;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point4(this, x6, y5);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x6;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x6, y5) {
    x6 = +x6, y5 = +y5;
    if (this._point)
      this._context.lineTo(x6, y5);
    else
      this._point = 1, this._context.moveTo(x6, y5);
  }
};
function linearClosed_default(context) {
  return new LinearClosed(context);
}

// node_modules/d3-shape/src/curve/monotone.js
function sign2(x6) {
  return x6 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p5 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign2(s0) + sign2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p5)) || 0;
}
function slope2(that, t6) {
  var h5 = that._x1 - that._x0;
  return h5 ? (3 * (that._y1 - that._y0) / h5 - t6) / 2 : t6;
}
function point5(that, t03, t13) {
  var x05 = that._x0, y05 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x05) / 3;
  that._context.bezierCurveTo(x05 + dx, y05 + dx * t03, x12 - dx, y12 - dx * t13, x12, y12);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point5(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y5) {
    var t13 = NaN;
    x6 = +x6, y5 = +y5;
    if (x6 === this._x1 && y5 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x6, y5) : this._context.moveTo(x6, y5);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point5(this, slope2(this, t13 = slope3(this, x6, y5)), t13);
        break;
      default:
        point5(this, this._t0, t13 = slope3(this, x6, y5));
        break;
    }
    this._x0 = this._x1, this._x1 = x6;
    this._y0 = this._y1, this._y1 = y5;
    this._t0 = t13;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x6, y5) {
  MonotoneX.prototype.point.call(this, y5, x6);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x6, y5) {
    this._context.moveTo(y5, x6);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x6, y5) {
    this._context.lineTo(y5, x6);
  },
  bezierCurveTo: function(x12, y12, x22, y22, x6, y5) {
    this._context.bezierCurveTo(y12, x12, y22, x22, y5, x6);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x6 = this._x, y5 = this._y, n9 = x6.length;
    if (n9) {
      this._line ? this._context.lineTo(x6[0], y5[0]) : this._context.moveTo(x6[0], y5[0]);
      if (n9 === 2) {
        this._context.lineTo(x6[1], y5[1]);
      } else {
        var px = controlPoints(x6), py = controlPoints(y5);
        for (var i0 = 0, i1 = 1; i1 < n9; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x6[i1], y5[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n9 === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x6, y5) {
    this._x.push(+x6);
    this._y.push(+y5);
  }
};
function controlPoints(x6) {
  var i6, n9 = x6.length - 1, m5, a7 = new Array(n9), b5 = new Array(n9), r6 = new Array(n9);
  a7[0] = 0, b5[0] = 2, r6[0] = x6[0] + 2 * x6[1];
  for (i6 = 1; i6 < n9 - 1; ++i6)
    a7[i6] = 1, b5[i6] = 4, r6[i6] = 4 * x6[i6] + 2 * x6[i6 + 1];
  a7[n9 - 1] = 2, b5[n9 - 1] = 7, r6[n9 - 1] = 8 * x6[n9 - 1] + x6[n9];
  for (i6 = 1; i6 < n9; ++i6)
    m5 = a7[i6] / b5[i6 - 1], b5[i6] -= m5, r6[i6] -= m5 * r6[i6 - 1];
  a7[n9 - 1] = r6[n9 - 1] / b5[n9 - 1];
  for (i6 = n9 - 2; i6 >= 0; --i6)
    a7[i6] = (r6[i6] - a7[i6 + 1]) / b5[i6];
  b5[n9 - 1] = (x6[n9] + a7[n9 - 1]) / 2;
  for (i6 = 0; i6 < n9 - 1; ++i6)
    b5[i6] = 2 * x6[i6 + 1] - a7[i6 + 1];
  return [a7, b5];
}
function natural_default(context) {
  return new Natural(context);
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t6) {
  this._context = context;
  this._t = t6;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x6, y5) {
    x6 = +x6, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x6, y5) : this._context.moveTo(x6, y5);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y5);
          this._context.lineTo(x6, y5);
        } else {
          var x12 = this._x * (1 - this._t) + x6 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y5);
        }
        break;
      }
    }
    this._x = x6, this._y = y5;
  }
};
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}

// node_modules/d3-zoom/src/transform.js
function Transform(k6, x6, y5) {
  this.k = k6;
  this.x = x6;
  this.y = y5;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k6) {
    return k6 === 1 ? this : new Transform(this.k * k6, this.x, this.y);
  },
  translate: function(x6, y5) {
    return x6 === 0 & y5 === 0 ? this : new Transform(this.k, this.x + this.k * x6, this.y + this.k * y5);
  },
  apply: function(point6) {
    return [point6[0] * this.k + this.x, point6[1] * this.k + this.y];
  },
  applyX: function(x6) {
    return x6 * this.k + this.x;
  },
  applyY: function(y5) {
    return y5 * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x6) {
    return (x6 - this.x) / this.k;
  },
  invertY: function(y5) {
    return (y5 - this.y) / this.k;
  },
  rescaleX: function(x6) {
    return x6.copy().domain(x6.range().map(this.invertX, this).map(x6.invert, x6));
  },
  rescaleY: function(y5) {
    return y5.copy().domain(y5.range().map(this.invertY, this).map(y5.invert, y5));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity6 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom)
    if (!(node = node.parentNode))
      return identity6;
  return node.__zoom;
}

// node_modules/@observablehq/plot/src/defined.js
function defined(x6) {
  return x6 != null && !Number.isNaN(x6);
}
function ascendingDefined2(a7, b5) {
  return +defined(b5) - +defined(a7) || ascending(a7, b5);
}
function descendingDefined(a7, b5) {
  return +defined(b5) - +defined(a7) || descending(a7, b5);
}
function nonempty(x6) {
  return x6 != null && `${x6}` !== "";
}
function finite(x6) {
  return isFinite(x6) ? x6 : NaN;
}
function positive(x6) {
  return x6 > 0 && isFinite(x6) ? x6 : NaN;
}
function negative(x6) {
  return x6 < 0 && isFinite(x6) ? x6 : NaN;
}

// node_modules/isoformat/src/format.js
function format2(date2, fallback) {
  if (!(date2 instanceof Date))
    date2 = /* @__PURE__ */ new Date(+date2);
  if (isNaN(date2))
    return typeof fallback === "function" ? fallback(date2) : fallback;
  const hours = date2.getUTCHours();
  const minutes = date2.getUTCMinutes();
  const seconds2 = date2.getUTCSeconds();
  const milliseconds2 = date2.getUTCMilliseconds();
  return `${formatYear2(date2.getUTCFullYear(), 4)}-${pad3(date2.getUTCMonth() + 1, 2)}-${pad3(date2.getUTCDate(), 2)}${hours || minutes || seconds2 || milliseconds2 ? `T${pad3(hours, 2)}:${pad3(minutes, 2)}${seconds2 || milliseconds2 ? `:${pad3(seconds2, 2)}${milliseconds2 ? `.${pad3(milliseconds2, 3)}` : ``}` : ``}Z` : ``}`;
}
function formatYear2(year) {
  return year < 0 ? `-${pad3(-year, 6)}` : year > 9999 ? `+${pad3(year, 6)}` : pad3(year, 4);
}
function pad3(value, width) {
  return `${value}`.padStart(width, "0");
}

// node_modules/isoformat/src/parse.js
var re2 = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
function parse(string2, fallback) {
  if (!re2.test(string2 += ""))
    return typeof fallback === "function" ? fallback(string2) : fallback;
  return new Date(string2);
}

// node_modules/@observablehq/plot/src/time.js
var durationSecond2 = 1e3;
var durationMinute2 = durationSecond2 * 60;
var durationHour2 = durationMinute2 * 60;
var durationDay2 = durationHour2 * 24;
var durationWeek2 = durationDay2 * 7;
var durationMonth2 = durationDay2 * 30;
var durationYear2 = durationDay2 * 365;
var formats = [
  ["millisecond", 0.5 * durationSecond2],
  ["second", durationSecond2],
  ["second", 30 * durationSecond2],
  ["minute", durationMinute2],
  ["minute", 30 * durationMinute2],
  ["hour", durationHour2],
  ["hour", 12 * durationHour2],
  ["day", durationDay2],
  ["day", 2 * durationDay2],
  ["week", durationWeek2],
  ["month", durationMonth2],
  ["month", 3 * durationMonth2],
  ["year", durationYear2]
];
var timeIntervals = /* @__PURE__ */ new Map([
  ["second", second],
  ["minute", timeMinute],
  ["hour", timeHour],
  ["day", timeDay],
  // TODO local time equivalent of unixDay?
  ["week", timeSunday],
  ["month", timeMonth],
  ["year", timeYear],
  ["monday", timeMonday],
  ["tuesday", timeTuesday],
  ["wednesday", timeWednesday],
  ["thursday", timeThursday],
  ["friday", timeFriday],
  ["saturday", timeSaturday],
  ["sunday", timeSunday]
]);
var utcIntervals = /* @__PURE__ */ new Map([
  ["second", second],
  ["minute", utcMinute],
  ["hour", utcHour],
  ["day", unixDay],
  ["week", utcSunday],
  ["month", utcMonth],
  ["year", utcYear],
  ["monday", utcMonday],
  ["tuesday", utcTuesday],
  ["wednesday", utcWednesday],
  ["thursday", utcThursday],
  ["friday", utcFriday],
  ["saturday", utcSaturday],
  ["sunday", utcSunday]
]);
function parseInterval(input, intervals) {
  let name = `${input}`.toLowerCase();
  if (name.endsWith("s"))
    name = name.slice(0, -1);
  let period = 1;
  const match = /^(?:(\d+)\s+)/.exec(name);
  if (match) {
    name = name.slice(match[0].length);
    period = +match[1];
  }
  switch (name) {
    case "quarter":
      name = "month";
      period *= 3;
      break;
    case "half":
      name = "month";
      period *= 6;
      break;
  }
  let interval2 = intervals.get(name);
  if (!interval2)
    throw new Error(`unknown interval: ${input}`);
  if (!(period > 1))
    return interval2;
  if (!interval2.every)
    throw new Error(`non-periodic interval: ${name}`);
  return interval2.every(period);
}
function maybeTimeInterval(interval2) {
  return parseInterval(interval2, timeIntervals);
}
function maybeUtcInterval(interval2) {
  return parseInterval(interval2, utcIntervals);
}
function isUtcYear(i6) {
  if (!i6)
    return false;
  const date2 = i6.floor(new Date(Date.UTC(2e3, 11, 31)));
  return utcYear(date2) >= date2;
}
function isTimeYear(i6) {
  if (!i6)
    return false;
  const date2 = i6.floor(new Date(2e3, 11, 31));
  return timeYear(date2) >= date2;
}
function formatTimeTicks(scale2, data, ticks2, anchor) {
  const format3 = scale2.type === "time" ? timeFormat : utcFormat;
  const template2 = anchor === "left" || anchor === "right" ? (f1, f22) => `
${f1}
${f22}` : anchor === "top" ? (f1, f22) => `${f22}
${f1}` : (f1, f22) => `${f1}
${f22}`;
  switch (getTimeTicksInterval(scale2, data, ticks2)) {
    case "millisecond":
      return formatConditional(format3(".%L"), format3(":%M:%S"), template2);
    case "second":
      return formatConditional(format3(":%S"), format3("%-I:%M"), template2);
    case "minute":
      return formatConditional(format3("%-I:%M"), format3("%p"), template2);
    case "hour":
      return formatConditional(format3("%-I %p"), format3("%b %-d"), template2);
    case "day":
      return formatConditional(format3("%-d"), format3("%b"), template2);
    case "week":
      return formatConditional(format3("%-d"), format3("%b"), template2);
    case "month":
      return formatConditional(format3("%b"), format3("%Y"), template2);
    case "year":
      return format3("%Y");
  }
  throw new Error("unable to format time ticks");
}
function getTimeTicksInterval(scale2, data, ticks2) {
  const medianStep = median(pairs(data, (a7, b5) => Math.abs(b5 - a7) || NaN));
  if (medianStep > 0)
    return formats[bisector(([, step2]) => step2).right(formats, medianStep, 1, formats.length) - 1][0];
  const [start2, stop] = extent(scale2.domain());
  const count2 = typeof ticks2 === "number" ? ticks2 : 10;
  const step = Math.abs(stop - start2) / count2;
  return formats[bisector(([, step2]) => Math.log(step2)).center(formats, Math.log(step))][0];
}
function formatConditional(format1, format22, template2) {
  return (x6, i6, X3) => {
    const f1 = format1(x6, i6);
    const f22 = format22(x6, i6);
    const j5 = i6 - orderof(X3);
    return i6 !== j5 && X3[j5] !== void 0 && f22 === format22(X3[j5], j5) ? f1 : template2(f1, f22);
  };
}

// node_modules/@observablehq/plot/src/options.js
var TypedArray = Object.getPrototypeOf(Uint8Array);
var objectToString2 = Object.prototype.toString;
function valueof(data, value, type3) {
  const valueType = typeof value;
  return valueType === "string" ? maybeTypedMap(data, field(value), type3) : valueType === "function" ? maybeTypedMap(data, value, type3) : valueType === "number" || value instanceof Date || valueType === "boolean" ? map3(data, constant2(value), type3) : typeof value?.transform === "function" ? maybeTypedArrayify(value.transform(data), type3) : maybeTypedArrayify(value, type3);
}
function maybeTypedMap(data, f4, type3) {
  return map3(data, type3?.prototype instanceof TypedArray ? floater(f4) : f4, type3);
}
function maybeTypedArrayify(data, type3) {
  return type3 === void 0 ? arrayify2(data) : data instanceof type3 ? data : type3.prototype instanceof TypedArray && !(data instanceof TypedArray) ? type3.from(data, coerceNumber) : type3.from(data);
}
function floater(f4) {
  return (d6, i6) => coerceNumber(f4(d6, i6));
}
var singleton = [null];
var field = (name) => (d6) => d6[name];
var indexOf = { transform: range2 };
var identity7 = { transform: (d6) => d6 };
var one2 = () => 1;
var yes = () => true;
var string = (x6) => x6 == null ? x6 : `${x6}`;
var number5 = (x6) => x6 == null ? x6 : +x6;
var first = (x6) => x6 ? x6[0] : void 0;
var second2 = (x6) => x6 ? x6[1] : void 0;
var constant2 = (x6) => () => x6;
function percentile(reduce) {
  const p5 = +`${reduce}`.slice(1) / 100;
  return (I4, f4) => quantile(I4, p5, f4);
}
function coerceNumbers(values2) {
  return values2 instanceof TypedArray ? values2 : map3(values2, coerceNumber, Float64Array);
}
function coerceNumber(x6) {
  return x6 == null ? NaN : Number(x6);
}
function coerceDates(values2) {
  return map3(values2, coerceDate);
}
function coerceDate(x6) {
  return x6 instanceof Date && !isNaN(x6) ? x6 : typeof x6 === "string" ? parse(x6) : x6 == null || isNaN(x6 = +x6) ? void 0 : new Date(x6);
}
function maybeColorChannel(value, defaultValue) {
  if (value === void 0)
    value = defaultValue;
  return value === null ? [void 0, "none"] : isColor(value) ? [void 0, value] : [value, void 0];
}
function maybeNumberChannel(value, defaultValue) {
  if (value === void 0)
    value = defaultValue;
  return value === null || typeof value === "number" ? [void 0, value] : [value, void 0];
}
function maybeKeyword(input, name, allowed) {
  if (input != null)
    return keyword(input, name, allowed);
}
function keyword(input, name, allowed) {
  const i6 = `${input}`.toLowerCase();
  if (!allowed.includes(i6))
    throw new Error(`invalid ${name}: ${input}`);
  return i6;
}
function arrayify2(data) {
  return data == null || data instanceof Array || data instanceof TypedArray ? data : Array.from(data);
}
function map3(values2, f4, type3 = Array) {
  return values2 == null ? values2 : values2 instanceof type3 ? values2.map(f4) : type3.from(values2, f4);
}
function slice2(values2, type3 = Array) {
  return values2 instanceof type3 ? values2.slice() : type3.from(values2);
}
function hasY({ y: y5, y1: y12, y2: y22 }) {
  return y5 !== void 0 || y12 !== void 0 || y22 !== void 0;
}
function isObject2(option) {
  return option?.toString === objectToString2;
}
function isScaleOptions(option) {
  return isObject2(option) && (option.type !== void 0 || option.domain !== void 0);
}
function isOptions(option) {
  return isObject2(option) && typeof option.transform !== "function";
}
function isDomainSort(sort2) {
  return isOptions(sort2) && sort2.value === void 0 && sort2.channel === void 0;
}
function maybeZero(x6, x12, x22, x32 = identity7) {
  if (x12 === void 0 && x22 === void 0) {
    x12 = 0, x22 = x6 === void 0 ? x32 : x6;
  } else if (x12 === void 0) {
    x12 = x6 === void 0 ? 0 : x6;
  } else if (x22 === void 0) {
    x22 = x6 === void 0 ? 0 : x6;
  }
  return [x12, x22];
}
function maybeTuple(x6, y5) {
  return x6 === void 0 && y5 === void 0 ? [first, second2] : [x6, y5];
}
function maybeZ({ z: z5, fill, stroke } = {}) {
  if (z5 === void 0)
    [z5] = maybeColorChannel(fill);
  if (z5 === void 0)
    [z5] = maybeColorChannel(stroke);
  return z5;
}
function range2(data) {
  const n9 = data.length;
  const r6 = new Uint32Array(n9);
  for (let i6 = 0; i6 < n9; ++i6)
    r6[i6] = i6;
  return r6;
}
function take(values2, index2) {
  return map3(index2, (i6) => values2[i6]);
}
function subarray(I4, i6, j5) {
  return I4.subarray ? I4.subarray(i6, j5) : I4.slice(i6, j5);
}
function keyof2(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
function maybeInput(key, options) {
  if (options[key] !== void 0)
    return options[key];
  switch (key) {
    case "x1":
    case "x2":
      key = "x";
      break;
    case "y1":
    case "y2":
      key = "y";
      break;
  }
  return options[key];
}
function column(source) {
  let value;
  return [
    {
      transform: () => value,
      label: labelof(source)
    },
    (v4) => value = v4
  ];
}
function maybeColumn(source) {
  return source == null ? [source] : column(source);
}
function labelof(value, defaultValue) {
  return typeof value === "string" ? value : value && value.label !== void 0 ? value.label : defaultValue;
}
function mid(x12, x22) {
  return {
    transform(data) {
      const X12 = x12.transform(data);
      const X23 = x22.transform(data);
      return isTemporal(X12) || isTemporal(X23) ? map3(X12, (_4, i6) => new Date((+X12[i6] + +X23[i6]) / 2)) : map3(X12, (_4, i6) => (+X12[i6] + +X23[i6]) / 2, Float64Array);
    },
    label: x12.label
  };
}
function maybeApplyInterval(V4, scale2) {
  const t6 = maybeIntervalTransform(scale2?.interval, scale2?.type);
  return t6 ? map3(V4, t6) : V4;
}
function maybeIntervalTransform(interval2, type3) {
  const i6 = maybeInterval(interval2, type3);
  return i6 && ((v4) => defined(v4) ? i6.floor(v4) : v4);
}
function maybeInterval(interval2, type3) {
  if (interval2 == null)
    return;
  if (typeof interval2 === "number") {
    if (0 < interval2 && interval2 < 1 && Number.isInteger(1 / interval2))
      interval2 = -1 / interval2;
    const n9 = Math.abs(interval2);
    return interval2 < 0 ? {
      floor: (d6) => Math.floor(d6 * n9) / n9,
      offset: (d6) => (d6 * n9 + 1) / n9,
      // note: no optional step for simplicity
      range: (lo, hi) => range(Math.ceil(lo * n9), hi * n9).map((x6) => x6 / n9)
    } : {
      floor: (d6) => Math.floor(d6 / n9) * n9,
      offset: (d6) => d6 + n9,
      // note: no optional step for simplicity
      range: (lo, hi) => range(Math.ceil(lo / n9), hi / n9).map((x6) => x6 * n9)
    };
  }
  if (typeof interval2 === "string")
    return (type3 === "time" ? maybeTimeInterval : maybeUtcInterval)(interval2);
  if (typeof interval2.floor !== "function")
    throw new Error("invalid interval; missing floor method");
  if (typeof interval2.offset !== "function")
    throw new Error("invalid interval; missing offset method");
  return interval2;
}
function maybeRangeInterval(interval2, type3) {
  interval2 = maybeInterval(interval2, type3);
  if (interval2 && typeof interval2.range !== "function")
    throw new Error("invalid interval: missing range method");
  return interval2;
}
function maybeNiceInterval(interval2, type3) {
  interval2 = maybeRangeInterval(interval2, type3);
  if (interval2 && typeof interval2.ceil !== "function")
    throw new Error("invalid interval: missing ceil method");
  return interval2;
}
function maybeValue(value) {
  return value === void 0 || isOptions(value) ? value : { value };
}
function numberChannel(source) {
  return source == null ? null : {
    transform: (data) => valueof(data, source, Float64Array),
    label: labelof(source)
  };
}
function isIterable(value) {
  return value && typeof value[Symbol.iterator] === "function";
}
function isTextual(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return typeof value !== "object" || value instanceof Date;
  }
}
function isOrdinal(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    const type3 = typeof value;
    return type3 === "string" || type3 === "boolean";
  }
}
function isTemporal(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return value instanceof Date;
  }
}
function isTemporalString(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return typeof value === "string" && isNaN(value) && parse(value);
  }
}
function isNumericString(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    if (typeof value !== "string")
      return false;
    if (!value.trim())
      continue;
    return !isNaN(value);
  }
}
function isNumeric(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return typeof value === "number";
  }
}
function isEvery(values2, is) {
  let every;
  for (const value of values2) {
    if (value == null)
      continue;
    if (!is(value))
      return false;
    every = true;
  }
  return every;
}
function isColor(value) {
  if (typeof value !== "string")
    return false;
  value = value.toLowerCase().trim();
  return value === "none" || value === "currentcolor" || value.startsWith("url(") && value.endsWith(")") || // <funciri>, e.g. pattern or gradient
  value.startsWith("var(") && value.endsWith(")") || // CSS variable
  color(value) !== null;
}
function isOpacity(value) {
  return typeof value === "number" && (0 <= value && value <= 1 || isNaN(value));
}
function isNoneish(value) {
  return value == null || isNone(value);
}
function isNone(value) {
  return /^\s*none\s*$/i.test(value);
}
function isRound(value) {
  return /^\s*round\s*$/i.test(value);
}
function maybeAnchor(value, name) {
  return maybeKeyword(value, name, [
    "middle",
    "top-left",
    "top",
    "top-right",
    "right",
    "bottom-right",
    "bottom",
    "bottom-left",
    "left"
  ]);
}
function maybeFrameAnchor(value = "middle") {
  return maybeAnchor(value, "frameAnchor");
}
function orderof(values2) {
  if (values2 == null)
    return;
  const first2 = values2[0];
  const last2 = values2[values2.length - 1];
  return descending(first2, last2);
}
function inherit2(options = {}, ...rest) {
  let o8 = options;
  for (const defaults8 of rest) {
    for (const key in defaults8) {
      if (o8[key] === void 0) {
        const value = defaults8[key];
        if (o8 === options)
          o8 = { ...o8, [key]: value };
        else
          o8[key] = value;
      }
    }
  }
  return o8;
}
function named2(things) {
  console.warn("named iterables are deprecated; please use an object instead");
  const names2 = /* @__PURE__ */ new Set();
  return Object.fromEntries(
    Array.from(things, (thing) => {
      const { name } = thing;
      if (name == null)
        throw new Error("missing name");
      const key = `${name}`;
      if (key === "__proto__")
        throw new Error(`illegal name: ${key}`);
      if (names2.has(key))
        throw new Error(`duplicate name: ${key}`);
      names2.add(key);
      return [name, thing];
    })
  );
}
function maybeNamed(things) {
  return isIterable(things) ? named2(things) : things;
}

// node_modules/@observablehq/plot/src/scales/index.js
var position = Symbol("position");
var color2 = Symbol("color");
var radius = Symbol("radius");
var length2 = Symbol("length");
var opacity = Symbol("opacity");
var symbol = Symbol("symbol");
var projection2 = Symbol("projection");
var registry = /* @__PURE__ */ new Map([
  ["x", position],
  ["y", position],
  ["fx", position],
  ["fy", position],
  ["r", radius],
  ["color", color2],
  ["opacity", opacity],
  ["symbol", symbol],
  ["length", length2],
  ["projection", projection2]
]);

// node_modules/@observablehq/plot/src/symbol.js
var sqrt35 = Math.sqrt(3);
var sqrt4_3 = 2 / sqrt35;
var symbolHexagon = {
  draw(context, size) {
    const rx = Math.sqrt(size / Math.PI), ry = rx * sqrt4_3, hy = ry / 2;
    context.moveTo(0, ry);
    context.lineTo(rx, hy);
    context.lineTo(rx, -hy);
    context.lineTo(0, -ry);
    context.lineTo(-rx, -hy);
    context.lineTo(-rx, hy);
    context.closePath();
  }
};
var symbols = /* @__PURE__ */ new Map([
  ["asterisk", asterisk_default],
  ["circle", circle_default2],
  ["cross", cross_default],
  ["diamond", diamond_default],
  ["diamond2", diamond2_default],
  ["hexagon", symbolHexagon],
  ["plus", plus_default],
  ["square", square_default],
  ["square2", square2_default],
  ["star", star_default],
  ["times", times_default],
  ["triangle", triangle_default],
  ["triangle2", triangle2_default],
  ["wye", wye_default]
]);
function isSymbolObject(value) {
  return value && typeof value.draw === "function";
}
function isSymbol2(value) {
  if (isSymbolObject(value))
    return true;
  if (typeof value !== "string")
    return false;
  return symbols.has(value.toLowerCase());
}
function maybeSymbol(symbol2) {
  if (symbol2 == null || isSymbolObject(symbol2))
    return symbol2;
  const value = symbols.get(`${symbol2}`.toLowerCase());
  if (value)
    return value;
  throw new Error(`invalid symbol: ${symbol2}`);
}

// node_modules/@observablehq/plot/src/transforms/basic.js
function basic({ filter: f1, sort: s1, reverse: r1, transform: t13, initializer: i1, ...options } = {}, transform2) {
  if (t13 === void 0) {
    if (f1 != null)
      t13 = filterTransform(f1);
    if (s1 != null && !isDomainSort(s1))
      t13 = composeTransform(t13, sortTransform(s1));
    if (r1)
      t13 = composeTransform(t13, reverseTransform);
  }
  if (transform2 != null && i1 != null)
    throw new Error("transforms cannot be applied after initializers");
  return {
    ...options,
    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },
    transform: composeTransform(t13, transform2)
  };
}
function initializer({ filter: f1, sort: s1, reverse: r1, initializer: i1, ...options } = {}, initializer2) {
  if (i1 === void 0) {
    if (f1 != null)
      i1 = filterTransform(f1);
    if (s1 != null && !isDomainSort(s1))
      i1 = composeInitializer(i1, sortTransform(s1));
    if (r1)
      i1 = composeInitializer(i1, reverseTransform);
  }
  return {
    ...options,
    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },
    initializer: composeInitializer(i1, initializer2)
  };
}
function composeTransform(t13, t23) {
  if (t13 == null)
    return t23 === null ? void 0 : t23;
  if (t23 == null)
    return t13 === null ? void 0 : t13;
  return function(data, facets, plotOptions) {
    ({ data, facets } = t13.call(this, data, facets, plotOptions));
    return t23.call(this, arrayify2(data), facets, plotOptions);
  };
}
function composeInitializer(i1, i22) {
  if (i1 == null)
    return i22 === null ? void 0 : i22;
  if (i22 == null)
    return i1 === null ? void 0 : i1;
  return function(data, facets, channels, ...args) {
    let c12, d1, f1, c23, d22, f22;
    ({ data: d1 = data, facets: f1 = facets, channels: c12 } = i1.call(this, data, facets, channels, ...args));
    ({ data: d22 = d1, facets: f22 = f1, channels: c23 } = i22.call(this, d1, f1, { ...channels, ...c12 }, ...args));
    return { data: d22, facets: f22, channels: { ...c12, ...c23 } };
  };
}
function filterTransform(value) {
  return (data, facets) => {
    const V4 = valueof(data, value);
    return { data, facets: facets.map((I4) => I4.filter((i6) => V4[i6])) };
  };
}
function reverseTransform(data, facets) {
  return { data, facets: facets.map((I4) => I4.slice().reverse()) };
}
function sortTransform(value) {
  return (typeof value === "function" && value.length !== 1 ? sortData : sortValue)(value);
}
function sortData(compare) {
  return (data, facets) => {
    const compareData = (i6, j5) => compare(data[i6], data[j5]);
    return { data, facets: facets.map((I4) => I4.slice().sort(compareData)) };
  };
}
function sortValue(value) {
  let channel, order;
  ({ channel, value, order } = { ...maybeValue(value) });
  const negate = channel?.startsWith("-");
  if (negate)
    channel = channel.slice(1);
  if (order === void 0)
    order = negate ? descendingDefined : ascendingDefined2;
  if (typeof order !== "function") {
    switch (`${order}`.toLowerCase()) {
      case "ascending":
        order = ascendingDefined2;
        break;
      case "descending":
        order = descendingDefined;
        break;
      default:
        throw new Error(`invalid order: ${order}`);
    }
  }
  return (data, facets, channels) => {
    let V4;
    if (channel === void 0) {
      V4 = valueof(data, value);
    } else {
      if (channels === void 0)
        throw new Error("channel sort requires an initializer");
      V4 = channels[channel];
      if (!V4)
        return {};
      V4 = V4.value;
    }
    const compareValue = (i6, j5) => order(V4[i6], V4[j5]);
    return { data, facets: facets.map((I4) => I4.slice().sort(compareValue)) };
  };
}

// node_modules/@observablehq/plot/src/transforms/group.js
function hasOutput(outputs, ...names2) {
  for (const { name } of outputs) {
    if (names2.includes(name)) {
      return true;
    }
  }
  return false;
}
function maybeOutputs(outputs, inputs, asOutput = maybeOutput) {
  const entries = Object.entries(outputs);
  if (inputs.title != null && outputs.title === void 0)
    entries.push(["title", reduceTitle]);
  if (inputs.href != null && outputs.href === void 0)
    entries.push(["href", reduceFirst]);
  return entries.filter(([, reduce]) => reduce !== void 0).map(([name, reduce]) => reduce === null ? nullOutput(name) : asOutput(name, reduce, inputs));
}
function maybeOutput(name, reduce, inputs, asEvaluator = maybeEvaluator) {
  let scale2;
  if (isObject2(reduce) && "reduce" in reduce)
    scale2 = reduce.scale, reduce = reduce.reduce;
  const evaluator = asEvaluator(name, reduce, inputs);
  const [output, setOutput] = column(evaluator.label);
  let O3;
  return {
    name,
    output: scale2 === void 0 ? output : { value: output, scale: scale2 },
    initialize(data) {
      evaluator.initialize(data);
      O3 = setOutput([]);
    },
    scope(scope, I4) {
      evaluator.scope(scope, I4);
    },
    reduce(I4, extent3) {
      O3.push(evaluator.reduce(I4, extent3));
    }
  };
}
function nullOutput(name) {
  return { name, initialize() {
  }, scope() {
  }, reduce() {
  } };
}
function maybeEvaluator(name, reduce, inputs, asReduce = maybeReduce) {
  const input = maybeInput(name, inputs);
  const reducer2 = asReduce(reduce, input);
  let V4, context;
  return {
    label: labelof(reducer2 === reduceCount ? null : input, reducer2.label),
    initialize(data) {
      V4 = input === void 0 ? data : valueof(data, input);
      if (reducer2.scope === "data") {
        context = reducer2.reduceIndex(range2(data), V4);
      }
    },
    scope(scope, I4) {
      if (reducer2.scope === scope) {
        context = reducer2.reduceIndex(I4, V4);
      }
    },
    reduce(I4, extent3) {
      return reducer2.scope == null ? reducer2.reduceIndex(I4, V4, extent3) : reducer2.reduceIndex(I4, V4, context, extent3);
    }
  };
}
function maybeGroup(I4, X3) {
  return X3 ? sort(
    group(I4, (i6) => X3[i6]),
    first
  ) : [[, I4]];
}
function maybeReduce(reduce, value, fallback = invalidReduce) {
  if (reduce == null)
    return fallback(reduce);
  if (typeof reduce.reduceIndex === "function")
    return reduce;
  if (typeof reduce.reduce === "function" && isObject2(reduce))
    return reduceReduce(reduce);
  if (typeof reduce === "function")
    return reduceFunction(reduce);
  if (/^p\d{2}$/i.test(reduce))
    return reduceAccessor(percentile(reduce));
  switch (`${reduce}`.toLowerCase()) {
    case "first":
      return reduceFirst;
    case "last":
      return reduceLast;
    case "identity":
      return reduceIdentity;
    case "count":
      return reduceCount;
    case "distinct":
      return reduceDistinct;
    case "sum":
      return value == null ? reduceCount : reduceSum;
    case "proportion":
      return reduceProportion(value, "data");
    case "proportion-facet":
      return reduceProportion(value, "facet");
    case "deviation":
      return reduceAccessor(deviation);
    case "min":
      return reduceAccessor(min);
    case "min-index":
      return reduceAccessor(minIndex);
    case "max":
      return reduceAccessor(max);
    case "max-index":
      return reduceAccessor(maxIndex);
    case "mean":
      return reduceMaybeTemporalAccessor(mean);
    case "median":
      return reduceMaybeTemporalAccessor(median);
    case "variance":
      return reduceAccessor(variance);
    case "mode":
      return reduceAccessor(mode);
  }
  return fallback(reduce);
}
function invalidReduce(reduce) {
  throw new Error(`invalid reduce: ${reduce}`);
}
function maybeSubgroup(outputs, inputs) {
  for (const name in inputs) {
    const value = inputs[name];
    if (value !== void 0 && !outputs.some((o8) => o8.name === name)) {
      return value;
    }
  }
}
function maybeSort(facets, sort2, reverse2) {
  if (sort2) {
    const S4 = sort2.output.transform();
    const compare = (i6, j5) => ascendingDefined2(S4[i6], S4[j5]);
    facets.forEach((f4) => f4.sort(compare));
  }
  if (reverse2) {
    facets.forEach((f4) => f4.reverse());
  }
}
function reduceReduce(reduce) {
  console.warn("deprecated reduce interface; implement reduceIndex instead.");
  return { ...reduce, reduceIndex: reduce.reduce.bind(reduce) };
}
function reduceFunction(f4) {
  return {
    reduceIndex(I4, X3, extent3) {
      return f4(take(X3, I4), extent3);
    }
  };
}
function reduceAccessor(f4) {
  return {
    reduceIndex(I4, X3) {
      return f4(I4, (i6) => X3[i6]);
    }
  };
}
function reduceMaybeTemporalAccessor(f4) {
  return {
    reduceIndex(I4, X3) {
      const x6 = f4(I4, (i6) => X3[i6]);
      return isTemporal(X3) ? new Date(x6) : x6;
    }
  };
}
var reduceIdentity = {
  reduceIndex(I4, X3) {
    return take(X3, I4);
  }
};
var reduceFirst = {
  reduceIndex(I4, X3) {
    return X3[I4[0]];
  }
};
var reduceTitle = {
  reduceIndex(I4, X3) {
    const n9 = 5;
    const groups2 = sort(
      rollup(
        I4,
        (V4) => V4.length,
        (i6) => X3[i6]
      ),
      second2
    );
    const top2 = groups2.slice(-n9).reverse();
    if (top2.length < groups2.length) {
      const bottom2 = groups2.slice(0, 1 - n9);
      top2[n9 - 1] = [`\u2026 ${bottom2.length.toLocaleString("en-US")} more`, sum(bottom2, second2)];
    }
    return top2.map(([key, value]) => `${key} (${value.toLocaleString("en-US")})`).join("\n");
  }
};
var reduceLast = {
  reduceIndex(I4, X3) {
    return X3[I4[I4.length - 1]];
  }
};
var reduceCount = {
  label: "Frequency",
  reduceIndex(I4) {
    return I4.length;
  }
};
var reduceDistinct = {
  label: "Distinct",
  reduceIndex(I4, X3) {
    const s8 = new InternSet();
    for (const i6 of I4)
      s8.add(X3[i6]);
    return s8.size;
  }
};
var reduceSum = reduceAccessor(sum);
function reduceProportion(value, scope) {
  return value == null ? { scope, label: "Frequency", reduceIndex: (I4, V4, basis2 = 1) => I4.length / basis2 } : { scope, reduceIndex: (I4, V4, basis2 = 1) => sum(I4, (i6) => V4[i6]) / basis2 };
}

// node_modules/@observablehq/plot/src/channel.js
function createChannel(data, { scale: scale2, type: type3, value, filter: filter2, hint }, name) {
  if (hint === void 0 && typeof value?.transform === "function")
    hint = value.hint;
  return inferChannelScale(name, {
    scale: scale2,
    type: type3,
    value: valueof(data, value),
    label: labelof(value),
    filter: filter2,
    hint
  });
}
function createChannels(channels, data) {
  return Object.fromEntries(
    Object.entries(channels).map(([name, channel]) => [name, createChannel(data, channel, name)])
  );
}
function valueObject(channels, scales) {
  const values2 = Object.fromEntries(
    Object.entries(channels).map(([name, { scale: scaleName, value }]) => {
      const scale2 = scaleName == null ? null : scales[scaleName];
      return [name, scale2 == null ? value : map3(value, scale2)];
    })
  );
  values2.channels = channels;
  return values2;
}
function inferChannelScale(name, channel) {
  const { scale: scale2, value } = channel;
  if (scale2 === true || scale2 === "auto") {
    switch (name) {
      case "fill":
      case "stroke":
      case "color":
        channel.scale = scale2 !== true && isEvery(value, isColor) ? null : "color";
        break;
      case "fillOpacity":
      case "strokeOpacity":
      case "opacity":
        channel.scale = scale2 !== true && isEvery(value, isOpacity) ? null : "opacity";
        break;
      case "symbol":
        if (scale2 !== true && isEvery(value, isSymbol2)) {
          channel.scale = null;
          channel.value = map3(value, maybeSymbol);
        } else {
          channel.scale = "symbol";
        }
        break;
      default:
        channel.scale = registry.has(name) ? name : null;
        break;
    }
  } else if (scale2 === false) {
    channel.scale = null;
  } else if (scale2 != null && !registry.has(scale2)) {
    throw new Error(`unknown scale: ${scale2}`);
  }
  return channel;
}
function channelDomain(data, facets, channels, facetChannels, options) {
  const { order: defaultOrder, reverse: defaultReverse, reduce: defaultReduce = true, limit: defaultLimit } = options;
  for (const x6 in options) {
    if (!registry.has(x6))
      continue;
    let { value: y5, order = defaultOrder, reverse: reverse2 = defaultReverse, reduce = defaultReduce, limit = defaultLimit } = maybeValue(options[x6]);
    const negate = y5?.startsWith("-");
    if (negate)
      y5 = y5.slice(1);
    order = order === void 0 ? negate !== (y5 === "width" || y5 === "height") ? descendingGroup : ascendingGroup : maybeOrder(order);
    if (reduce == null || reduce === false)
      continue;
    const X3 = x6 === "fx" || x6 === "fy" ? reindexFacetChannel(facets, facetChannels[x6]) : findScaleChannel(channels, x6);
    if (!X3)
      throw new Error(`missing channel for scale: ${x6}`);
    const XV = X3.value;
    const [lo = 0, hi = Infinity] = isIterable(limit) ? limit : limit < 0 ? [limit] : [0, limit];
    if (y5 == null) {
      X3.domain = () => {
        let domain = Array.from(new InternSet(XV));
        if (reverse2)
          domain = domain.reverse();
        if (lo !== 0 || hi !== Infinity)
          domain = domain.slice(lo, hi);
        return domain;
      };
    } else {
      const YV = y5 === "data" ? data : y5 === "height" ? difference(channels, "y1", "y2") : y5 === "width" ? difference(channels, "x1", "x2") : values(channels, y5, y5 === "y" ? "y2" : y5 === "x" ? "x2" : void 0);
      const reducer2 = maybeReduce(reduce === true ? "max" : reduce, YV);
      X3.domain = () => {
        let domain = rollups(
          range2(XV),
          (I4) => reducer2.reduceIndex(I4, YV),
          (i6) => XV[i6]
        );
        if (order)
          domain.sort(order);
        if (reverse2)
          domain.reverse();
        if (lo !== 0 || hi !== Infinity)
          domain = domain.slice(lo, hi);
        return domain.map(first);
      };
    }
  }
}
function findScaleChannel(channels, scale2) {
  for (const name in channels) {
    const channel = channels[name];
    if (channel.scale === scale2)
      return channel;
  }
}
function reindexFacetChannel(facets, channel) {
  const originalFacets = facets.original;
  if (originalFacets === facets)
    return channel;
  const V1 = channel.value;
  const V22 = channel.value = [];
  for (let i6 = 0; i6 < originalFacets.length; ++i6) {
    const vi = V1[originalFacets[i6][0]];
    for (const j5 of facets[i6])
      V22[j5] = vi;
  }
  return channel;
}
function difference(channels, k1, k22) {
  const X12 = values(channels, k1);
  const X23 = values(channels, k22);
  return map3(X23, (x22, i6) => Math.abs(x22 - X12[i6]), Float64Array);
}
function values(channels, name, alias) {
  let channel = channels[name];
  if (!channel && alias !== void 0)
    channel = channels[alias];
  if (channel)
    return channel.value;
  throw new Error(`missing channel: ${name}`);
}
function maybeOrder(order) {
  if (order == null || typeof order === "function")
    return order;
  switch (`${order}`.toLowerCase()) {
    case "ascending":
      return ascendingGroup;
    case "descending":
      return descendingGroup;
  }
  throw new Error(`invalid order: ${order}`);
}
function ascendingGroup([ak, av], [bk, bv]) {
  return ascendingDefined2(av, bv) || ascendingDefined2(ak, bk);
}
function descendingGroup([ak, av], [bk, bv]) {
  return descendingDefined(av, bv) || ascendingDefined2(ak, bk);
}
function getSource(channels, key) {
  let channel = channels[key];
  if (!channel)
    return;
  while (channel.source)
    channel = channel.source;
  return channel.source === null ? null : channel;
}

// node_modules/@observablehq/plot/src/context.js
function createContext(options = {}) {
  const { document: document2 = typeof window !== "undefined" ? window.document : void 0 } = options;
  return { document: document2 };
}
function create2(name, { document: document2 }) {
  return select_default2(creator_default(name).call(document2.documentElement));
}

// node_modules/@observablehq/plot/src/warnings.js
var warnings = 0;
function consumeWarnings() {
  const w5 = warnings;
  warnings = 0;
  return w5;
}
function warn(message) {
  console.warn(message);
  ++warnings;
}

// node_modules/@observablehq/plot/src/projection.js
var pi4 = Math.PI;
var tau4 = 2 * pi4;
var defaultAspectRatio = 0.618;
function createProjection({
  projection: projection3,
  inset: globalInset = 0,
  insetTop = globalInset,
  insetRight = globalInset,
  insetBottom = globalInset,
  insetLeft = globalInset
} = {}, dimensions) {
  if (projection3 == null)
    return;
  if (typeof projection3.stream === "function")
    return projection3;
  let options;
  let domain;
  let clip = "frame";
  if (isObject2(projection3)) {
    let inset;
    ({
      type: projection3,
      domain,
      inset,
      insetTop = inset !== void 0 ? inset : insetTop,
      insetRight = inset !== void 0 ? inset : insetRight,
      insetBottom = inset !== void 0 ? inset : insetBottom,
      insetLeft = inset !== void 0 ? inset : insetLeft,
      clip = clip,
      ...options
    } = projection3);
    if (projection3 == null)
      return;
  }
  if (typeof projection3 !== "function")
    ({ type: projection3 } = namedProjection(projection3));
  const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;
  const dx = width - marginLeft - marginRight - insetLeft - insetRight;
  const dy = height - marginTop - marginBottom - insetTop - insetBottom;
  projection3 = projection3?.({ width: dx, height: dy, clip, ...options });
  if (projection3 == null)
    return;
  clip = maybePostClip(clip, marginLeft, marginTop, width - marginRight, height - marginBottom);
  let tx = marginLeft + insetLeft;
  let ty = marginTop + insetTop;
  let transform2;
  if (domain != null) {
    const [[x05, y05], [x12, y12]] = path_default(projection3).bounds(domain);
    const k6 = Math.min(dx / (x12 - x05), dy / (y12 - y05));
    if (k6 > 0) {
      tx -= (k6 * (x05 + x12) - dx) / 2;
      ty -= (k6 * (y05 + y12) - dy) / 2;
      transform2 = transform_default({
        point(x6, y5) {
          this.stream.point(x6 * k6 + tx, y5 * k6 + ty);
        }
      });
    } else {
      warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);
    }
  }
  transform2 ??= tx === 0 && ty === 0 ? identity8() : transform_default({
    point(x6, y5) {
      this.stream.point(x6 + tx, y5 + ty);
    }
  });
  return { stream: (s8) => projection3.stream(transform2.stream(clip(s8))) };
}
function namedProjection(projection3) {
  switch (`${projection3}`.toLowerCase()) {
    case "albers-usa":
      return scaleProjection(albersUsa_default, 0.7463, 0.4673);
    case "albers":
      return conicProjection2(albers_default, 0.7463, 0.4673);
    case "azimuthal-equal-area":
      return scaleProjection(azimuthalEqualArea_default, 4, 4);
    case "azimuthal-equidistant":
      return scaleProjection(azimuthalEquidistant_default, tau4, tau4);
    case "conic-conformal":
      return conicProjection2(conicConformal_default, tau4, tau4);
    case "conic-equal-area":
      return conicProjection2(conicEqualArea_default, 6.1702, 2.9781);
    case "conic-equidistant":
      return conicProjection2(conicEquidistant_default, 7.312, 3.6282);
    case "equal-earth":
      return scaleProjection(equalEarth_default, 5.4133, 2.6347);
    case "equirectangular":
      return scaleProjection(equirectangular_default, tau4, pi4);
    case "gnomonic":
      return scaleProjection(gnomonic_default, 3.4641, 3.4641);
    case "identity":
      return { type: identity8 };
    case "reflect-y":
      return { type: reflectY };
    case "mercator":
      return scaleProjection(mercator_default, tau4, tau4);
    case "orthographic":
      return scaleProjection(orthographic_default, 2, 2);
    case "stereographic":
      return scaleProjection(stereographic_default, 2, 2);
    case "transverse-mercator":
      return scaleProjection(transverseMercator_default, tau4, tau4);
    default:
      throw new Error(`unknown projection type: ${projection3}`);
  }
}
function maybePostClip(clip, x12, y12, x22, y22) {
  if (clip === false || clip == null || typeof clip === "number")
    return (s8) => s8;
  if (clip === true)
    clip = "frame";
  switch (`${clip}`.toLowerCase()) {
    case "frame":
      return clipRectangle(x12, y12, x22, y22);
    default:
      throw new Error(`unknown projection clip type: ${clip}`);
  }
}
function scaleProjection(createProjection2, kx2, ky2) {
  return {
    type: ({ width, height, rotate, precision = 0.15, clip }) => {
      const projection3 = createProjection2();
      if (precision != null)
        projection3.precision?.(precision);
      if (rotate != null)
        projection3.rotate?.(rotate);
      if (typeof clip === "number")
        projection3.clipAngle?.(clip);
      projection3.scale(Math.min(width / kx2, height / ky2));
      projection3.translate([width / 2, height / 2]);
      return projection3;
    },
    aspectRatio: ky2 / kx2
  };
}
function conicProjection2(createProjection2, kx2, ky2) {
  const { type: type3, aspectRatio } = scaleProjection(createProjection2, kx2, ky2);
  return {
    type: (options) => {
      const { parallels, domain, width, height } = options;
      const projection3 = type3(options);
      if (parallels != null) {
        projection3.parallels(parallels);
        if (domain === void 0) {
          projection3.fitSize([width, height], { type: "Sphere" });
        }
      }
      return projection3;
    },
    aspectRatio
  };
}
var identity8 = constant2({ stream: (stream) => stream });
var reflectY = constant2(
  transform_default({
    point(x6, y5) {
      this.stream.point(x6, -y5);
    }
  })
);
function project(cx, cy, values2, projection3) {
  const x6 = values2[cx];
  const y5 = values2[cy];
  const n9 = x6.length;
  const X3 = values2[cx] = new Float64Array(n9).fill(NaN);
  const Y3 = values2[cy] = new Float64Array(n9).fill(NaN);
  let i6;
  const stream = projection3.stream({
    point(x7, y6) {
      X3[i6] = x7;
      Y3[i6] = y6;
    }
  });
  for (i6 = 0; i6 < n9; ++i6) {
    stream.point(x6[i6], y5[i6]);
  }
}
function hasProjection({ projection: projection3 } = {}) {
  if (projection3 == null)
    return false;
  if (typeof projection3.stream === "function")
    return true;
  if (isObject2(projection3))
    projection3 = projection3.type;
  return projection3 != null;
}
function projectionAspectRatio(projection3) {
  if (typeof projection3?.stream === "function")
    return defaultAspectRatio;
  if (isObject2(projection3))
    projection3 = projection3.type;
  if (projection3 == null)
    return;
  if (typeof projection3 !== "function") {
    const { aspectRatio } = namedProjection(projection3);
    if (aspectRatio)
      return aspectRatio;
  }
  return defaultAspectRatio;
}
function getGeometryChannels(channel) {
  const X3 = [];
  const Y3 = [];
  const x6 = { scale: "x", value: X3 };
  const y5 = { scale: "y", value: Y3 };
  const sink = {
    point(x7, y6) {
      X3.push(x7);
      Y3.push(y6);
    },
    lineStart() {
    },
    lineEnd() {
    },
    polygonStart() {
    },
    polygonEnd() {
    },
    sphere() {
    }
  };
  for (const object of channel.value)
    stream_default(object, sink);
  return [x6, y5];
}

// node_modules/@observablehq/plot/src/scales/schemes.js
var categoricalSchemes = /* @__PURE__ */ new Map([
  ["accent", Accent_default],
  ["category10", category10_default],
  ["dark2", Dark2_default],
  ["paired", Paired_default],
  ["pastel1", Pastel1_default],
  ["pastel2", Pastel2_default],
  ["set1", Set1_default],
  ["set2", Set2_default],
  ["set3", Set3_default],
  ["tableau10", Tableau10_default]
]);
function isCategoricalScheme(scheme28) {
  return scheme28 != null && categoricalSchemes.has(`${scheme28}`.toLowerCase());
}
var ordinalSchemes = new Map([
  ...categoricalSchemes,
  // diverging
  ["brbg", scheme112(scheme, BrBG_default)],
  ["prgn", scheme112(scheme2, PRGn_default)],
  ["piyg", scheme112(scheme3, PiYG_default)],
  ["puor", scheme112(scheme4, PuOr_default)],
  ["rdbu", scheme112(scheme5, RdBu_default)],
  ["rdgy", scheme112(scheme6, RdGy_default)],
  ["rdylbu", scheme112(scheme7, RdYlBu_default)],
  ["rdylgn", scheme112(scheme8, RdYlGn_default)],
  ["spectral", scheme112(scheme9, Spectral_default)],
  // reversed diverging (for temperature data)
  ["burd", scheme11r(scheme5, RdBu_default)],
  ["buylrd", scheme11r(scheme7, RdYlBu_default)],
  // sequential (single-hue)
  ["blues", scheme92(scheme22, Blues_default)],
  ["greens", scheme92(scheme23, Greens_default)],
  ["greys", scheme92(scheme24, Greys_default)],
  ["oranges", scheme92(scheme27, Oranges_default)],
  ["purples", scheme92(scheme25, Purples_default)],
  ["reds", scheme92(scheme26, Reds_default)],
  // sequential (multi-hue)
  ["turbo", schemei(turbo_default)],
  ["viridis", schemei(viridis_default)],
  ["magma", schemei(magma)],
  ["inferno", schemei(inferno)],
  ["plasma", schemei(plasma)],
  ["cividis", schemei(cividis_default)],
  ["cubehelix", schemei(cubehelix_default2)],
  ["warm", schemei(warm)],
  ["cool", schemei(cool)],
  ["bugn", scheme92(scheme10, BuGn_default)],
  ["bupu", scheme92(scheme11, BuPu_default)],
  ["gnbu", scheme92(scheme12, GnBu_default)],
  ["orrd", scheme92(scheme13, OrRd_default)],
  ["pubu", scheme92(scheme15, PuBu_default)],
  ["pubugn", scheme92(scheme14, PuBuGn_default)],
  ["purd", scheme92(scheme16, PuRd_default)],
  ["rdpu", scheme92(scheme17, RdPu_default)],
  ["ylgn", scheme92(scheme19, YlGn_default)],
  ["ylgnbu", scheme92(scheme18, YlGnBu_default)],
  ["ylorbr", scheme92(scheme20, YlOrBr_default)],
  ["ylorrd", scheme92(scheme21, YlOrRd_default)],
  // cyclical
  ["rainbow", schemeicyclical(rainbow_default)],
  ["sinebow", schemeicyclical(sinebow_default)]
]);
function scheme92(scheme28, interpolate2) {
  return ({ length: n9 }) => {
    if (n9 === 1)
      return [scheme28[3][1]];
    if (n9 === 2)
      return [scheme28[3][1], scheme28[3][2]];
    n9 = Math.max(3, Math.floor(n9));
    return n9 > 9 ? quantize_default(interpolate2, n9) : scheme28[n9];
  };
}
function scheme112(scheme28, interpolate2) {
  return ({ length: n9 }) => {
    if (n9 === 2)
      return [scheme28[3][0], scheme28[3][2]];
    n9 = Math.max(3, Math.floor(n9));
    return n9 > 11 ? quantize_default(interpolate2, n9) : scheme28[n9];
  };
}
function scheme11r(scheme28, interpolate2) {
  return ({ length: n9 }) => {
    if (n9 === 2)
      return [scheme28[3][2], scheme28[3][0]];
    n9 = Math.max(3, Math.floor(n9));
    return n9 > 11 ? quantize_default((t6) => interpolate2(1 - t6), n9) : scheme28[n9].slice().reverse();
  };
}
function schemei(interpolate2) {
  return ({ length: n9 }) => quantize_default(interpolate2, Math.max(2, Math.floor(n9)));
}
function schemeicyclical(interpolate2) {
  return ({ length: n9 }) => quantize_default(interpolate2, Math.floor(n9) + 1).slice(0, -1);
}
function ordinalScheme(scheme28) {
  const s8 = `${scheme28}`.toLowerCase();
  if (!ordinalSchemes.has(s8))
    throw new Error(`unknown ordinal scheme: ${s8}`);
  return ordinalSchemes.get(s8);
}
function ordinalRange(scheme28, length3) {
  const s8 = ordinalScheme(scheme28);
  const r6 = typeof s8 === "function" ? s8({ length: length3 }) : s8;
  return r6.length !== length3 ? r6.slice(0, length3) : r6;
}
function maybeBooleanRange(domain, scheme28 = "greys") {
  const range4 = /* @__PURE__ */ new Set();
  const [f4, t6] = ordinalRange(scheme28, 2);
  for (const value of domain) {
    if (value == null)
      continue;
    if (value === true)
      range4.add(t6);
    else if (value === false)
      range4.add(f4);
    else
      return;
  }
  return [...range4];
}
var quantitativeSchemes = /* @__PURE__ */ new Map([
  // diverging
  ["brbg", BrBG_default],
  ["prgn", PRGn_default],
  ["piyg", PiYG_default],
  ["puor", PuOr_default],
  ["rdbu", RdBu_default],
  ["rdgy", RdGy_default],
  ["rdylbu", RdYlBu_default],
  ["rdylgn", RdYlGn_default],
  ["spectral", Spectral_default],
  // reversed diverging (for temperature data)
  ["burd", (t6) => RdBu_default(1 - t6)],
  ["buylrd", (t6) => RdYlBu_default(1 - t6)],
  // sequential (single-hue)
  ["blues", Blues_default],
  ["greens", Greens_default],
  ["greys", Greys_default],
  ["purples", Purples_default],
  ["reds", Reds_default],
  ["oranges", Oranges_default],
  // sequential (multi-hue)
  ["turbo", turbo_default],
  ["viridis", viridis_default],
  ["magma", magma],
  ["inferno", inferno],
  ["plasma", plasma],
  ["cividis", cividis_default],
  ["cubehelix", cubehelix_default2],
  ["warm", warm],
  ["cool", cool],
  ["bugn", BuGn_default],
  ["bupu", BuPu_default],
  ["gnbu", GnBu_default],
  ["orrd", OrRd_default],
  ["pubugn", PuBuGn_default],
  ["pubu", PuBu_default],
  ["purd", PuRd_default],
  ["rdpu", RdPu_default],
  ["ylgnbu", YlGnBu_default],
  ["ylgn", YlGn_default],
  ["ylorbr", YlOrBr_default],
  ["ylorrd", YlOrRd_default],
  // cyclical
  ["rainbow", rainbow_default],
  ["sinebow", sinebow_default]
]);
function quantitativeScheme(scheme28) {
  const s8 = `${scheme28}`.toLowerCase();
  if (!quantitativeSchemes.has(s8))
    throw new Error(`unknown quantitative scheme: ${s8}`);
  return quantitativeSchemes.get(s8);
}
var divergingSchemes = /* @__PURE__ */ new Set([
  "brbg",
  "prgn",
  "piyg",
  "puor",
  "rdbu",
  "rdgy",
  "rdylbu",
  "rdylgn",
  "spectral",
  "burd",
  "buylrd"
]);
function isDivergingScheme(scheme28) {
  return scheme28 != null && divergingSchemes.has(`${scheme28}`.toLowerCase());
}

// node_modules/@observablehq/plot/src/scales/quantitative.js
var flip2 = (i6) => (t6) => i6(1 - t6);
var unit2 = [0, 1];
var interpolators = /* @__PURE__ */ new Map([
  // numbers
  ["number", number_default],
  // color spaces
  ["rgb", rgb_default],
  ["hsl", hsl_default],
  ["hcl", hcl_default],
  ["lab", lab2]
]);
function maybeInterpolator(interpolate2) {
  const i6 = `${interpolate2}`.toLowerCase();
  if (!interpolators.has(i6))
    throw new Error(`unknown interpolator: ${i6}`);
  return interpolators.get(i6);
}
function createScaleQ(key, scale2, channels, {
  type: type3,
  nice: nice2,
  clamp: clamp2,
  zero: zero3,
  domain = inferAutoDomain(key, channels),
  unknown,
  round,
  scheme: scheme28,
  interval: interval2,
  range: range4 = registry.get(key) === radius ? inferRadialRange(channels, domain) : registry.get(key) === length2 ? inferLengthRange(channels, domain) : registry.get(key) === opacity ? unit2 : void 0,
  interpolate: interpolate2 = registry.get(key) === color2 ? scheme28 == null && range4 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : type3 === "cyclical" ? "rainbow" : "turbo") : round ? round_default : number_default,
  reverse: reverse2
}) {
  interval2 = maybeRangeInterval(interval2, type3);
  if (type3 === "cyclical" || type3 === "sequential")
    type3 = "linear";
  if (typeof interpolate2 !== "function")
    interpolate2 = maybeInterpolator(interpolate2);
  reverse2 = !!reverse2;
  if (range4 !== void 0) {
    const n9 = (domain = arrayify2(domain)).length;
    const m5 = (range4 = arrayify2(range4)).length;
    if (n9 !== m5) {
      if (interpolate2.length === 1)
        throw new Error("invalid piecewise interpolator");
      interpolate2 = piecewise(interpolate2, range4);
      range4 = void 0;
    }
  }
  if (interpolate2.length === 1) {
    if (reverse2) {
      interpolate2 = flip2(interpolate2);
      reverse2 = false;
    }
    if (range4 === void 0) {
      range4 = Float64Array.from(domain, (_4, i6) => i6 / (domain.length - 1));
      if (range4.length === 2)
        range4 = unit2;
    }
    scale2.interpolate((range4 === unit2 ? constant2 : interpolatePiecewise)(interpolate2));
  } else {
    scale2.interpolate(interpolate2);
  }
  if (zero3) {
    const [min4, max4] = extent(domain);
    if (min4 > 0 || max4 < 0) {
      domain = slice2(domain);
      if (orderof(domain) !== Math.sign(min4))
        domain[domain.length - 1] = 0;
      else
        domain[0] = 0;
    }
  }
  if (reverse2)
    domain = reverse(domain);
  scale2.domain(domain).unknown(unknown);
  if (nice2)
    scale2.nice(maybeNice(nice2, type3)), domain = scale2.domain();
  if (range4 !== void 0)
    scale2.range(range4);
  if (clamp2)
    scale2.clamp(clamp2);
  return { type: type3, domain, range: range4, scale: scale2, interpolate: interpolate2, interval: interval2 };
}
function maybeNice(nice2, type3) {
  return nice2 === true ? void 0 : typeof nice2 === "number" ? nice2 : maybeNiceInterval(nice2, type3);
}
function createScaleLinear(key, channels, options) {
  return createScaleQ(key, linear2(), channels, options);
}
function createScaleSqrt(key, channels, options) {
  return createScalePow(key, channels, { ...options, exponent: 0.5 });
}
function createScalePow(key, channels, { exponent = 1, ...options }) {
  return createScaleQ(key, pow2().exponent(exponent), channels, { ...options, type: "pow" });
}
function createScaleLog(key, channels, { base = 10, domain = inferLogDomain(channels), ...options }) {
  return createScaleQ(key, log2().base(base), channels, { ...options, domain });
}
function createScaleSymlog(key, channels, { constant: constant3 = 1, ...options }) {
  return createScaleQ(key, symlog().constant(constant3), channels, options);
}
function createScaleQuantile(key, channels, {
  range: range4,
  quantiles = range4 === void 0 ? 5 : (range4 = [...range4]).length,
  // deprecated; use n instead
  n: n9 = quantiles,
  scheme: scheme28 = "rdylbu",
  domain = inferQuantileDomain(channels),
  unknown,
  interpolate: interpolate2,
  reverse: reverse2
}) {
  if (range4 === void 0) {
    range4 = interpolate2 !== void 0 ? quantize_default(interpolate2, n9) : registry.get(key) === color2 ? ordinalRange(scheme28, n9) : void 0;
  }
  if (domain.length > 0) {
    domain = quantile2(domain, range4 === void 0 ? { length: n9 } : range4).quantiles();
  }
  return createScaleThreshold(key, channels, { domain, range: range4, reverse: reverse2, unknown });
}
function createScaleQuantize(key, channels, {
  range: range4,
  n: n9 = range4 === void 0 ? 5 : (range4 = [...range4]).length,
  scheme: scheme28 = "rdylbu",
  domain = inferAutoDomain(key, channels),
  unknown,
  interpolate: interpolate2,
  reverse: reverse2
}) {
  const [min4, max4] = extent(domain);
  let thresholds;
  if (range4 === void 0) {
    thresholds = ticks(min4, max4, n9);
    if (thresholds[0] <= min4)
      thresholds.splice(0, 1);
    if (thresholds[thresholds.length - 1] >= max4)
      thresholds.pop();
    n9 = thresholds.length + 1;
    range4 = interpolate2 !== void 0 ? quantize_default(interpolate2, n9) : registry.get(key) === color2 ? ordinalRange(scheme28, n9) : void 0;
  } else {
    thresholds = quantize_default(number_default(min4, max4), n9 + 1).slice(1, -1);
    if (min4 instanceof Date)
      thresholds = thresholds.map((x6) => new Date(x6));
  }
  if (orderof(arrayify2(domain)) < 0)
    thresholds.reverse();
  return createScaleThreshold(key, channels, { domain: thresholds, range: range4, reverse: reverse2, unknown });
}
function createScaleThreshold(key, channels, {
  domain = [0],
  // explicit thresholds in ascending order
  unknown,
  scheme: scheme28 = "rdylbu",
  interpolate: interpolate2,
  range: range4 = interpolate2 !== void 0 ? quantize_default(interpolate2, domain.length + 1) : registry.get(key) === color2 ? ordinalRange(scheme28, domain.length + 1) : void 0,
  reverse: reverse2
}) {
  domain = arrayify2(domain);
  const sign3 = orderof(domain);
  if (!isNaN(sign3) && !isOrdered(domain, sign3))
    throw new Error(`the ${key} scale has a non-monotonic domain`);
  if (reverse2)
    range4 = reverse(range4);
  return {
    type: "threshold",
    scale: threshold(sign3 < 0 ? reverse(domain) : domain, range4 === void 0 ? [] : range4).unknown(unknown),
    domain,
    range: range4
  };
}
function isOrdered(domain, sign3) {
  for (let i6 = 1, n9 = domain.length, d6 = domain[0]; i6 < n9; ++i6) {
    const s8 = descending(d6, d6 = domain[i6]);
    if (s8 !== 0 && s8 !== sign3)
      return false;
  }
  return true;
}
function createScaleIdentity() {
  return { type: "identity", scale: identity5() };
}
function inferDomain(channels, f4 = finite) {
  return channels.length ? [
    min(channels, ({ value }) => value === void 0 ? value : min(value, f4)),
    max(channels, ({ value }) => value === void 0 ? value : max(value, f4))
  ] : [0, 1];
}
function inferAutoDomain(key, channels) {
  const type3 = registry.get(key);
  return (type3 === radius || type3 === opacity || type3 === length2 ? inferZeroDomain : inferDomain)(channels);
}
function inferZeroDomain(channels) {
  return [0, channels.length ? max(channels, ({ value }) => value === void 0 ? value : max(value, finite)) : 1];
}
function inferRadialRange(channels, domain) {
  const hint = channels.find(({ radius: radius2 }) => radius2 !== void 0);
  if (hint !== void 0)
    return [0, hint.radius];
  const h25 = quantile(channels, 0.5, ({ value }) => value === void 0 ? NaN : quantile(value, 0.25, positive));
  const range4 = domain.map((d6) => 3 * Math.sqrt(d6 / h25));
  const k6 = 30 / max(range4);
  return k6 < 1 ? range4.map((r6) => r6 * k6) : range4;
}
function inferLengthRange(channels, domain) {
  const h50 = median(channels, ({ value }) => value === void 0 ? NaN : median(value, Math.abs));
  const range4 = domain.map((d6) => 12 * d6 / h50);
  const k6 = 60 / max(range4);
  return k6 < 1 ? range4.map((r6) => r6 * k6) : range4;
}
function inferLogDomain(channels) {
  for (const { value } of channels) {
    if (value !== void 0) {
      for (let v4 of value) {
        if (v4 > 0)
          return inferDomain(channels, positive);
        if (v4 < 0)
          return inferDomain(channels, negative);
      }
    }
  }
  return [1, 10];
}
function inferQuantileDomain(channels) {
  const domain = [];
  for (const { value } of channels) {
    if (value === void 0)
      continue;
    for (const v4 of value)
      domain.push(v4);
  }
  return domain;
}
function interpolatePiecewise(interpolate2) {
  return (i6, j5) => (t6) => interpolate2(i6 + t6 * (j5 - i6));
}

// node_modules/@observablehq/plot/src/scales/diverging.js
function createScaleD(key, scale2, transform2, channels, {
  type: type3,
  nice: nice2,
  clamp: clamp2,
  domain = inferDomain(channels),
  unknown,
  pivot = 0,
  scheme: scheme28,
  range: range4,
  symmetric = true,
  interpolate: interpolate2 = registry.get(key) === color2 ? scheme28 == null && range4 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : "rdbu") : number_default,
  reverse: reverse2
}) {
  pivot = +pivot;
  domain = arrayify2(domain);
  let [min4, max4] = domain;
  if (domain.length > 2)
    warn(`Warning: the diverging ${key} scale domain contains extra elements.`);
  if (descending(min4, max4) < 0)
    [min4, max4] = [max4, min4], reverse2 = !reverse2;
  min4 = Math.min(min4, pivot);
  max4 = Math.max(max4, pivot);
  if (typeof interpolate2 !== "function") {
    interpolate2 = maybeInterpolator(interpolate2);
  }
  if (range4 !== void 0) {
    interpolate2 = interpolate2.length === 1 ? interpolatePiecewise(interpolate2)(...range4) : piecewise(interpolate2, range4);
  }
  if (reverse2)
    interpolate2 = flip2(interpolate2);
  if (symmetric) {
    const mid2 = transform2.apply(pivot);
    const mindelta = mid2 - transform2.apply(min4);
    const maxdelta = transform2.apply(max4) - mid2;
    if (mindelta < maxdelta)
      min4 = transform2.invert(mid2 - maxdelta);
    else if (mindelta > maxdelta)
      max4 = transform2.invert(mid2 + mindelta);
  }
  scale2.domain([min4, pivot, max4]).unknown(unknown).interpolator(interpolate2);
  if (clamp2)
    scale2.clamp(clamp2);
  if (nice2)
    scale2.nice(nice2);
  return { type: type3, domain: [min4, max4], pivot, interpolate: interpolate2, scale: scale2 };
}
function createScaleDiverging(key, channels, options) {
  return createScaleD(key, diverging(), transformIdentity, channels, options);
}
function createScaleDivergingSqrt(key, channels, options) {
  return createScaleDivergingPow(key, channels, { ...options, exponent: 0.5 });
}
function createScaleDivergingPow(key, channels, { exponent = 1, ...options }) {
  return createScaleD(key, divergingPow().exponent(exponent = +exponent), transformPow2(exponent), channels, {
    ...options,
    type: "diverging-pow"
  });
}
function createScaleDivergingLog(key, channels, { base = 10, pivot = 1, domain = inferDomain(channels, pivot < 0 ? negative : positive), ...options }) {
  return createScaleD(key, divergingLog().base(base = +base), transformLog2, channels, {
    domain,
    pivot,
    ...options
  });
}
function createScaleDivergingSymlog(key, channels, { constant: constant3 = 1, ...options }) {
  return createScaleD(
    key,
    divergingSymlog().constant(constant3 = +constant3),
    transformSymlog2(constant3),
    channels,
    options
  );
}
var transformIdentity = {
  apply(x6) {
    return x6;
  },
  invert(x6) {
    return x6;
  }
};
var transformLog2 = {
  apply: Math.log,
  invert: Math.exp
};
var transformSqrt2 = {
  apply(x6) {
    return Math.sign(x6) * Math.sqrt(Math.abs(x6));
  },
  invert(x6) {
    return Math.sign(x6) * (x6 * x6);
  }
};
function transformPow2(exponent) {
  return exponent === 0.5 ? transformSqrt2 : {
    apply(x6) {
      return Math.sign(x6) * Math.pow(Math.abs(x6), exponent);
    },
    invert(x6) {
      return Math.sign(x6) * Math.pow(Math.abs(x6), 1 / exponent);
    }
  };
}
function transformSymlog2(constant3) {
  return {
    apply(x6) {
      return Math.sign(x6) * Math.log1p(Math.abs(x6 / constant3));
    },
    invert(x6) {
      return Math.sign(x6) * Math.expm1(Math.abs(x6)) * constant3;
    }
  };
}

// node_modules/@observablehq/plot/src/scales/temporal.js
function createScaleT(key, scale2, channels, options) {
  return createScaleQ(key, scale2, channels, options);
}
function createScaleTime(key, channels, options) {
  return createScaleT(key, time(), channels, options);
}
function createScaleUtc(key, channels, options) {
  return createScaleT(key, utcTime(), channels, options);
}

// node_modules/@observablehq/plot/src/scales/ordinal.js
var ordinalImplicit = Symbol("ordinal");
function createScaleO(key, scale2, channels, { type: type3, interval: interval2, domain, range: range4, reverse: reverse2, hint }) {
  interval2 = maybeRangeInterval(interval2, type3);
  if (domain === void 0)
    domain = inferDomain2(channels, interval2, key);
  if (type3 === "categorical" || type3 === ordinalImplicit)
    type3 = "ordinal";
  if (reverse2)
    domain = reverse(domain);
  scale2.domain(domain);
  if (range4 !== void 0) {
    if (typeof range4 === "function")
      range4 = range4(domain);
    scale2.range(range4);
  }
  return { type: type3, domain, range: range4, scale: scale2, hint, interval: interval2 };
}
function createScaleOrdinal(key, channels, { type: type3, interval: interval2, domain, range: range4, scheme: scheme28, unknown, ...options }) {
  interval2 = maybeRangeInterval(interval2, type3);
  if (domain === void 0)
    domain = inferDomain2(channels, interval2, key);
  let hint;
  if (registry.get(key) === symbol) {
    hint = inferSymbolHint(channels);
    range4 = range4 === void 0 ? inferSymbolRange(hint) : map3(range4, maybeSymbol);
  } else if (registry.get(key) === color2) {
    if (range4 === void 0 && (type3 === "ordinal" || type3 === ordinalImplicit)) {
      range4 = maybeBooleanRange(domain, scheme28);
      if (range4 !== void 0)
        scheme28 = void 0;
    }
    if (scheme28 === void 0 && range4 === void 0) {
      scheme28 = type3 === "ordinal" ? "turbo" : "tableau10";
    }
    if (scheme28 !== void 0) {
      if (range4 !== void 0) {
        const interpolate2 = quantitativeScheme(scheme28);
        const t03 = range4[0], d6 = range4[1] - range4[0];
        range4 = ({ length: n9 }) => quantize_default((t6) => interpolate2(t03 + d6 * t6), n9);
      } else {
        range4 = ordinalScheme(scheme28);
      }
    }
  }
  if (unknown === implicit) {
    throw new Error(`implicit unknown on ${key} scale is not supported`);
  }
  return createScaleO(key, ordinal().unknown(unknown), channels, { ...options, type: type3, domain, range: range4, hint });
}
function createScalePoint(key, channels, { align = 0.5, padding = 0.5, ...options }) {
  return maybeRound(point().align(align).padding(padding), channels, options, key);
}
function createScaleBand(key, channels, {
  align = 0.5,
  padding = 0.1,
  paddingInner = padding,
  paddingOuter = key === "fx" || key === "fy" ? 0 : padding,
  ...options
}) {
  return maybeRound(
    band().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter),
    channels,
    options,
    key
  );
}
function maybeRound(scale2, channels, options, key) {
  let { round } = options;
  if (round !== void 0)
    scale2.round(round = !!round);
  scale2 = createScaleO(key, scale2, channels, options);
  scale2.round = round;
  return scale2;
}
function inferDomain2(channels, interval2, key) {
  const values2 = new InternSet();
  for (const { value, domain } of channels) {
    if (domain !== void 0)
      return domain();
    if (value === void 0)
      continue;
    for (const v4 of value)
      values2.add(v4);
  }
  if (interval2 !== void 0) {
    const [min4, max4] = extent(values2).map(interval2.floor, interval2);
    return interval2.range(min4, interval2.offset(max4));
  }
  if (values2.size > 1e4 && registry.get(key) === position) {
    throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);
  }
  return sort(values2, ascendingDefined2);
}
function inferHint(channels, key) {
  let value;
  for (const { hint } of channels) {
    const candidate = hint?.[key];
    if (candidate === void 0)
      continue;
    if (value === void 0)
      value = candidate;
    else if (value !== candidate)
      return;
  }
  return value;
}
function inferSymbolHint(channels) {
  return {
    fill: inferHint(channels, "fill"),
    stroke: inferHint(channels, "stroke")
  };
}
function inferSymbolRange(hint) {
  return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;
}

// node_modules/@observablehq/plot/src/scales.js
function createScales(channelsByScale, {
  label: globalLabel,
  inset: globalInset = 0,
  insetTop: globalInsetTop = globalInset,
  insetRight: globalInsetRight = globalInset,
  insetBottom: globalInsetBottom = globalInset,
  insetLeft: globalInsetLeft = globalInset,
  round,
  nice: nice2,
  clamp: clamp2,
  zero: zero3,
  align,
  padding,
  projection: projection3,
  facet: { label: facetLabel = globalLabel } = {},
  ...options
} = {}) {
  const scales = {};
  for (const [key, channels] of channelsByScale) {
    const scaleOptions = options[key];
    const scale2 = createScale(key, channels, {
      round: registry.get(key) === position ? round : void 0,
      // only for position
      nice: nice2,
      clamp: clamp2,
      zero: zero3,
      align,
      padding,
      projection: projection3,
      ...scaleOptions
    });
    if (scale2) {
      let {
        label = key === "fx" || key === "fy" ? facetLabel : globalLabel,
        percent,
        transform: transform2,
        inset,
        insetTop = inset !== void 0 ? inset : key === "y" ? globalInsetTop : 0,
        // not fy
        insetRight = inset !== void 0 ? inset : key === "x" ? globalInsetRight : 0,
        // not fx
        insetBottom = inset !== void 0 ? inset : key === "y" ? globalInsetBottom : 0,
        // not fy
        insetLeft = inset !== void 0 ? inset : key === "x" ? globalInsetLeft : 0
        // not fx
      } = scaleOptions || {};
      if (transform2 == null)
        transform2 = void 0;
      else if (typeof transform2 !== "function")
        throw new Error("invalid scale transform; not a function");
      scale2.percent = !!percent;
      scale2.label = label === void 0 ? inferScaleLabel(channels, scale2) : label;
      scale2.transform = transform2;
      if (key === "x" || key === "fx") {
        scale2.insetLeft = +insetLeft;
        scale2.insetRight = +insetRight;
      } else if (key === "y" || key === "fy") {
        scale2.insetTop = +insetTop;
        scale2.insetBottom = +insetBottom;
      }
      scales[key] = scale2;
    }
  }
  return scales;
}
function createScaleFunctions(scales) {
  return Object.fromEntries(
    Object.entries(scales).filter(([, { scale: scale2 }]) => scale2).map(([name, { scale: scale2, type: type3, interval: interval2, label }]) => {
      scale2.type = type3;
      if (interval2 != null)
        scale2.interval = interval2;
      if (label != null)
        scale2.label = label;
      return [name, scale2];
    })
  );
}
function autoScaleRange(scales, dimensions) {
  const { x: x6, y: y5, fx, fy } = scales;
  const superdimensions = fx || fy ? outerDimensions(dimensions) : dimensions;
  if (fx)
    autoScaleRangeX(fx, superdimensions);
  if (fy)
    autoScaleRangeY(fy, superdimensions);
  const subdimensions = fx || fy ? innerDimensions(scales, dimensions) : dimensions;
  if (x6)
    autoScaleRangeX(x6, subdimensions);
  if (y5)
    autoScaleRangeY(y5, subdimensions);
}
function inferScaleLabel(channels = [], scale2) {
  let label;
  for (const { label: l7 } of channels) {
    if (l7 === void 0)
      continue;
    if (label === void 0)
      label = l7;
    else if (label !== l7)
      return;
  }
  if (label === void 0)
    return;
  if (!isOrdinalScale(scale2) && scale2.percent)
    label = `${label} (%)`;
  return { inferred: true, toString: () => label };
}
function outerDimensions(dimensions) {
  const {
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    width,
    height,
    facet: {
      marginTop: facetMarginTop,
      marginRight: facetMarginRight,
      marginBottom: facetMarginBottom,
      marginLeft: facetMarginLeft
    }
  } = dimensions;
  return {
    marginTop: Math.max(marginTop, facetMarginTop),
    marginRight: Math.max(marginRight, facetMarginRight),
    marginBottom: Math.max(marginBottom, facetMarginBottom),
    marginLeft: Math.max(marginLeft, facetMarginLeft),
    width,
    height
  };
}
function innerDimensions({ fx, fy }, dimensions) {
  const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);
  return {
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    width: fx ? fx.scale.bandwidth() + marginLeft + marginRight : width,
    height: fy ? fy.scale.bandwidth() + marginTop + marginBottom : height,
    facet: { width, height }
  };
}
function autoScaleRangeX(scale2, dimensions) {
  if (scale2.range === void 0) {
    const { insetLeft, insetRight } = scale2;
    const { width, marginLeft = 0, marginRight = 0 } = dimensions;
    const left2 = marginLeft + insetLeft;
    const right2 = width - marginRight - insetRight;
    scale2.range = [left2, Math.max(left2, right2)];
    if (!isOrdinalScale(scale2))
      scale2.range = piecewiseRange(scale2);
    scale2.scale.range(scale2.range);
  }
  autoScaleRound(scale2);
}
function autoScaleRangeY(scale2, dimensions) {
  if (scale2.range === void 0) {
    const { insetTop, insetBottom } = scale2;
    const { height, marginTop = 0, marginBottom = 0 } = dimensions;
    const top2 = marginTop + insetTop;
    const bottom2 = height - marginBottom - insetBottom;
    scale2.range = [Math.max(top2, bottom2), top2];
    if (!isOrdinalScale(scale2))
      scale2.range = piecewiseRange(scale2);
    else
      scale2.range.reverse();
    scale2.scale.range(scale2.range);
  }
  autoScaleRound(scale2);
}
function autoScaleRound(scale2) {
  if (scale2.round === void 0 && isBandScale(scale2) && roundError(scale2) <= 30) {
    scale2.scale.round(true);
  }
}
function roundError({ scale: scale2 }) {
  const n9 = scale2.domain().length;
  const [start2, stop] = scale2.range();
  const paddingInner = scale2.paddingInner ? scale2.paddingInner() : 1;
  const paddingOuter = scale2.paddingOuter ? scale2.paddingOuter() : scale2.padding();
  const m5 = n9 - paddingInner;
  const step = Math.abs(stop - start2) / Math.max(1, m5 + paddingOuter * 2);
  return (step - Math.floor(step)) * m5;
}
function piecewiseRange(scale2) {
  const length3 = scale2.scale.domain().length + isThresholdScale(scale2);
  if (!(length3 > 2))
    return scale2.range;
  const [start2, end] = scale2.range;
  return Array.from({ length: length3 }, (_4, i6) => start2 + i6 / (length3 - 1) * (end - start2));
}
function createScale(key, channels = [], options = {}) {
  const type3 = inferScaleType(key, channels, options);
  if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== "fx" && key !== "fy" && isOrdinalScale({ type: type3 })) {
    const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
    if (values2.some(isTemporal))
      warn(
        `Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
          type3
        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type3
        )}".`
      );
    else if (values2.some(isTemporalString))
      warn(
        `Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
          type3
        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type3
        )}".`
      );
    else if (values2.some(isNumericString))
      warn(
        `Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${formatScaleType(
          type3
        )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type3
        )}".`
      );
  }
  options.type = type3;
  switch (type3) {
    case "diverging":
    case "diverging-sqrt":
    case "diverging-pow":
    case "diverging-log":
    case "diverging-symlog":
    case "cyclical":
    case "sequential":
    case "linear":
    case "sqrt":
    case "threshold":
    case "quantile":
    case "pow":
    case "log":
    case "symlog":
      options = coerceType(channels, options, coerceNumbers);
      break;
    case "identity":
      switch (registry.get(key)) {
        case position:
          options = coerceType(channels, options, coerceNumbers);
          break;
        case symbol:
          options = coerceType(channels, options, coerceSymbols);
          break;
      }
      break;
    case "utc":
    case "time":
      options = coerceType(channels, options, coerceDates);
      break;
  }
  switch (type3) {
    case "diverging":
      return createScaleDiverging(key, channels, options);
    case "diverging-sqrt":
      return createScaleDivergingSqrt(key, channels, options);
    case "diverging-pow":
      return createScaleDivergingPow(key, channels, options);
    case "diverging-log":
      return createScaleDivergingLog(key, channels, options);
    case "diverging-symlog":
      return createScaleDivergingSymlog(key, channels, options);
    case "categorical":
    case "ordinal":
    case ordinalImplicit:
      return createScaleOrdinal(key, channels, options);
    case "cyclical":
    case "sequential":
    case "linear":
      return createScaleLinear(key, channels, options);
    case "sqrt":
      return createScaleSqrt(key, channels, options);
    case "threshold":
      return createScaleThreshold(key, channels, options);
    case "quantile":
      return createScaleQuantile(key, channels, options);
    case "quantize":
      return createScaleQuantize(key, channels, options);
    case "pow":
      return createScalePow(key, channels, options);
    case "log":
      return createScaleLog(key, channels, options);
    case "symlog":
      return createScaleSymlog(key, channels, options);
    case "utc":
      return createScaleUtc(key, channels, options);
    case "time":
      return createScaleTime(key, channels, options);
    case "point":
      return createScalePoint(key, channels, options);
    case "band":
      return createScaleBand(key, channels, options);
    case "identity":
      return registry.get(key) === position ? createScaleIdentity() : { type: "identity" };
    case void 0:
      return;
    default:
      throw new Error(`unknown scale type: ${type3}`);
  }
}
function formatScaleType(type3) {
  return typeof type3 === "symbol" ? type3.description : type3;
}
var typeProjection = { toString: () => "projection" };
function inferScaleType(key, channels, { type: type3, domain, range: range4, scheme: scheme28, pivot, projection: projection3 }) {
  if (key === "fx" || key === "fy")
    return "band";
  if ((key === "x" || key === "y") && projection3 != null)
    type3 = typeProjection;
  for (const { type: t6 } of channels) {
    if (t6 === void 0)
      continue;
    else if (type3 === void 0)
      type3 = t6;
    else if (type3 !== t6)
      throw new Error(`scale incompatible with channel: ${type3} !== ${t6}`);
  }
  if (type3 === typeProjection)
    return;
  if (type3 !== void 0)
    return type3;
  if (domain === void 0 && !channels.some(({ value }) => value !== void 0))
    return;
  const kind = registry.get(key);
  if (kind === radius)
    return "sqrt";
  if (kind === opacity || kind === length2)
    return "linear";
  if (kind === symbol)
    return "ordinal";
  if ((domain || range4 || []).length > 2)
    return asOrdinalType(kind);
  if (domain !== void 0) {
    if (isOrdinal(domain))
      return asOrdinalType(kind);
    if (isTemporal(domain))
      return "utc";
  } else {
    const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
    if (values2.some(isOrdinal))
      return asOrdinalType(kind);
    if (values2.some(isTemporal))
      return "utc";
  }
  if (kind === color2) {
    if (pivot != null || isDivergingScheme(scheme28))
      return "diverging";
    if (isCategoricalScheme(scheme28))
      return "categorical";
  }
  return "linear";
}
function asOrdinalType(kind) {
  switch (kind) {
    case position:
      return "point";
    case color2:
      return ordinalImplicit;
    default:
      return "ordinal";
  }
}
function isTemporalScale({ type: type3 }) {
  return type3 === "time" || type3 === "utc";
}
function isOrdinalScale({ type: type3 }) {
  return type3 === "ordinal" || type3 === "point" || type3 === "band" || type3 === ordinalImplicit;
}
function isThresholdScale({ type: type3 }) {
  return type3 === "threshold";
}
function isBandScale({ type: type3 }) {
  return type3 === "point" || type3 === "band";
}
function isCollapsed(scale2) {
  if (scale2 === void 0)
    return true;
  const domain = scale2.domain();
  const value = scale2(domain[0]);
  for (let i6 = 1, n9 = domain.length; i6 < n9; ++i6) {
    if (scale2(domain[i6]) - value) {
      return false;
    }
  }
  return true;
}
function coerceType(channels, { domain, ...options }, coerceValues) {
  for (const c9 of channels) {
    if (c9.value !== void 0) {
      c9.value = coerceValues(c9.value);
    }
  }
  return {
    domain: domain === void 0 ? domain : coerceValues(domain),
    ...options
  };
}
function coerceSymbols(values2) {
  return map3(values2, maybeSymbol);
}
function exposeScales(scaleDescriptors) {
  return (key) => {
    if (!registry.has(key = `${key}`))
      throw new Error(`unknown scale: ${key}`);
    return key in scaleDescriptors ? exposeScale(scaleDescriptors[key]) : void 0;
  };
}
function exposeScale({ scale: scale2, type: type3, domain, range: range4, interpolate: interpolate2, interval: interval2, transform: transform2, percent, pivot }) {
  if (type3 === "identity")
    return { type: "identity", apply: (d6) => d6, invert: (d6) => d6 };
  const unknown = scale2.unknown ? scale2.unknown() : void 0;
  return {
    type: type3,
    domain: slice2(domain),
    // defensive copy
    ...range4 !== void 0 && { range: slice2(range4) },
    // defensive copy
    ...transform2 !== void 0 && { transform: transform2 },
    ...percent && { percent },
    // only exposed if truthy
    ...unknown !== void 0 && { unknown },
    ...interval2 !== void 0 && { interval: interval2 },
    // quantitative
    ...interpolate2 !== void 0 && { interpolate: interpolate2 },
    ...scale2.clamp && { clamp: scale2.clamp() },
    // diverging (always asymmetric; we never want to apply the symmetric transform twice)
    ...pivot !== void 0 && { pivot, symmetric: false },
    // log, diverging-log
    ...scale2.base && { base: scale2.base() },
    // pow, diverging-pow
    ...scale2.exponent && { exponent: scale2.exponent() },
    // symlog, diverging-symlog
    ...scale2.constant && { constant: scale2.constant() },
    // band, point
    ...scale2.align && { align: scale2.align(), round: scale2.round() },
    ...scale2.padding && (scale2.paddingInner ? { paddingInner: scale2.paddingInner(), paddingOuter: scale2.paddingOuter() } : { padding: scale2.padding() }),
    ...scale2.bandwidth && { bandwidth: scale2.bandwidth(), step: scale2.step() },
    // utilities
    apply: (t6) => scale2(t6),
    ...scale2.invert && { invert: (t6) => scale2.invert(t6) }
  };
}

// node_modules/@observablehq/plot/src/memoize.js
function memoize1(compute) {
  let cacheValue, cacheKeys;
  return (...keys2) => {
    if (cacheKeys?.length !== keys2.length || cacheKeys.some((k6, i6) => k6 !== keys2[i6])) {
      cacheKeys = keys2;
      cacheValue = compute(...keys2);
    }
    return cacheValue;
  };
}

// node_modules/@observablehq/plot/src/format.js
var numberFormat = memoize1((locale3) => {
  return new Intl.NumberFormat(locale3);
});
var monthFormat = memoize1((locale3, month) => {
  return new Intl.DateTimeFormat(locale3, { timeZone: "UTC", ...month && { month } });
});
var weekdayFormat = memoize1((locale3, weekday) => {
  return new Intl.DateTimeFormat(locale3, { timeZone: "UTC", ...weekday && { weekday } });
});
function formatNumber(locale3 = "en-US") {
  const format3 = numberFormat(locale3);
  return (i6) => i6 != null && !isNaN(i6) ? format3.format(i6) : void 0;
}
function formatIsoDate(date2) {
  return format2(date2, "Invalid Date");
}
function formatAuto(locale3 = "en-US") {
  const number6 = formatNumber(locale3);
  return (v4) => (v4 instanceof Date ? formatIsoDate : typeof v4 === "number" ? number6 : string)(v4);
}
var formatDefault = formatAuto();

// node_modules/@observablehq/plot/src/style.js
var offset = (typeof window !== "undefined" ? window.devicePixelRatio > 1 : typeof it === "undefined") ? 0 : 0.5;
var nextClipId = 0;
function getClipId() {
  return `plot-clip-${++nextClipId}`;
}
function styles(mark, {
  title,
  href,
  ariaLabel: variaLabel,
  ariaDescription,
  ariaHidden,
  target,
  fill,
  fillOpacity,
  stroke,
  strokeWidth,
  strokeOpacity,
  strokeLinejoin,
  strokeLinecap,
  strokeMiterlimit,
  strokeDasharray,
  strokeDashoffset,
  opacity: opacity2,
  mixBlendMode,
  imageFilter,
  paintOrder,
  pointerEvents,
  shapeRendering,
  channels
}, {
  ariaLabel: cariaLabel,
  fill: defaultFill = "currentColor",
  fillOpacity: defaultFillOpacity,
  stroke: defaultStroke = "none",
  strokeOpacity: defaultStrokeOpacity,
  strokeWidth: defaultStrokeWidth,
  strokeLinecap: defaultStrokeLinecap,
  strokeLinejoin: defaultStrokeLinejoin,
  strokeMiterlimit: defaultStrokeMiterlimit,
  paintOrder: defaultPaintOrder
}) {
  if (defaultFill === null) {
    fill = null;
    fillOpacity = null;
  }
  if (defaultStroke === null) {
    stroke = null;
    strokeOpacity = null;
  }
  if (isNoneish(defaultFill)) {
    if (!isNoneish(defaultStroke) && (!isNoneish(fill) || channels?.fill))
      defaultStroke = "none";
  } else {
    if (isNoneish(defaultStroke) && (!isNoneish(stroke) || channels?.stroke))
      defaultFill = "none";
  }
  const [vfill, cfill] = maybeColorChannel(fill, defaultFill);
  const [vfillOpacity, cfillOpacity] = maybeNumberChannel(fillOpacity, defaultFillOpacity);
  const [vstroke, cstroke] = maybeColorChannel(stroke, defaultStroke);
  const [vstrokeOpacity, cstrokeOpacity] = maybeNumberChannel(strokeOpacity, defaultStrokeOpacity);
  const [vopacity, copacity] = maybeNumberChannel(opacity2);
  if (!isNone(cstroke)) {
    if (strokeWidth === void 0)
      strokeWidth = defaultStrokeWidth;
    if (strokeLinecap === void 0)
      strokeLinecap = defaultStrokeLinecap;
    if (strokeLinejoin === void 0)
      strokeLinejoin = defaultStrokeLinejoin;
    if (strokeMiterlimit === void 0 && !isRound(strokeLinejoin))
      strokeMiterlimit = defaultStrokeMiterlimit;
    if (!isNone(cfill) && paintOrder === void 0)
      paintOrder = defaultPaintOrder;
  }
  const [vstrokeWidth, cstrokeWidth] = maybeNumberChannel(strokeWidth);
  if (defaultFill !== null) {
    mark.fill = impliedString(cfill, "currentColor");
    mark.fillOpacity = impliedNumber(cfillOpacity, 1);
  }
  if (defaultStroke !== null) {
    mark.stroke = impliedString(cstroke, "none");
    mark.strokeWidth = impliedNumber(cstrokeWidth, 1);
    mark.strokeOpacity = impliedNumber(cstrokeOpacity, 1);
    mark.strokeLinejoin = impliedString(strokeLinejoin, "miter");
    mark.strokeLinecap = impliedString(strokeLinecap, "butt");
    mark.strokeMiterlimit = impliedNumber(strokeMiterlimit, 4);
    mark.strokeDasharray = impliedString(strokeDasharray, "none");
    mark.strokeDashoffset = impliedString(strokeDashoffset, "0");
  }
  mark.target = string(target);
  mark.ariaLabel = string(cariaLabel);
  mark.ariaDescription = string(ariaDescription);
  mark.ariaHidden = string(ariaHidden);
  mark.opacity = impliedNumber(copacity, 1);
  mark.mixBlendMode = impliedString(mixBlendMode, "normal");
  mark.imageFilter = impliedString(imageFilter, "none");
  mark.paintOrder = impliedString(paintOrder, "normal");
  mark.pointerEvents = impliedString(pointerEvents, "auto");
  mark.shapeRendering = impliedString(shapeRendering, "auto");
  return {
    title: { value: title, optional: true, filter: null },
    href: { value: href, optional: true, filter: null },
    ariaLabel: { value: variaLabel, optional: true, filter: null },
    fill: { value: vfill, scale: "auto", optional: true },
    fillOpacity: { value: vfillOpacity, scale: "auto", optional: true },
    stroke: { value: vstroke, scale: "auto", optional: true },
    strokeOpacity: { value: vstrokeOpacity, scale: "auto", optional: true },
    strokeWidth: { value: vstrokeWidth, optional: true },
    opacity: { value: vopacity, scale: "auto", optional: true }
  };
}
function applyTitle(selection2, L4) {
  if (L4)
    selection2.filter((i6) => nonempty(L4[i6])).append("title").call(applyText, L4);
}
function applyTitleGroup(selection2, L4) {
  if (L4)
    selection2.filter(([i6]) => nonempty(L4[i6])).append("title").call(applyTextGroup, L4);
}
function applyText(selection2, T5) {
  if (T5)
    selection2.text((i6) => formatDefault(T5[i6]));
}
function applyTextGroup(selection2, T5) {
  if (T5)
    selection2.text(([i6]) => formatDefault(T5[i6]));
}
function applyChannelStyles(selection2, { target, tip: tip2 }, {
  ariaLabel: AL,
  title: T5,
  fill: F4,
  fillOpacity: FO,
  stroke: S4,
  strokeOpacity: SO,
  strokeWidth: SW,
  opacity: O3,
  href: H4
}) {
  if (AL)
    applyAttr(selection2, "aria-label", (i6) => AL[i6]);
  if (F4)
    applyAttr(selection2, "fill", (i6) => F4[i6]);
  if (FO)
    applyAttr(selection2, "fill-opacity", (i6) => FO[i6]);
  if (S4)
    applyAttr(selection2, "stroke", (i6) => S4[i6]);
  if (SO)
    applyAttr(selection2, "stroke-opacity", (i6) => SO[i6]);
  if (SW)
    applyAttr(selection2, "stroke-width", (i6) => SW[i6]);
  if (O3)
    applyAttr(selection2, "opacity", (i6) => O3[i6]);
  if (H4)
    applyHref(selection2, (i6) => H4[i6], target);
  if (!tip2)
    applyTitle(selection2, T5);
}
function applyGroupedChannelStyles(selection2, { target, tip: tip2 }, {
  ariaLabel: AL,
  title: T5,
  fill: F4,
  fillOpacity: FO,
  stroke: S4,
  strokeOpacity: SO,
  strokeWidth: SW,
  opacity: O3,
  href: H4
}) {
  if (AL)
    applyAttr(selection2, "aria-label", ([i6]) => AL[i6]);
  if (F4)
    applyAttr(selection2, "fill", ([i6]) => F4[i6]);
  if (FO)
    applyAttr(selection2, "fill-opacity", ([i6]) => FO[i6]);
  if (S4)
    applyAttr(selection2, "stroke", ([i6]) => S4[i6]);
  if (SO)
    applyAttr(selection2, "stroke-opacity", ([i6]) => SO[i6]);
  if (SW)
    applyAttr(selection2, "stroke-width", ([i6]) => SW[i6]);
  if (O3)
    applyAttr(selection2, "opacity", ([i6]) => O3[i6]);
  if (H4)
    applyHref(selection2, ([i6]) => H4[i6], target);
  if (!tip2)
    applyTitleGroup(selection2, T5);
}
function groupAesthetics({
  ariaLabel: AL,
  title: T5,
  fill: F4,
  fillOpacity: FO,
  stroke: S4,
  strokeOpacity: SO,
  strokeWidth: SW,
  opacity: O3,
  href: H4
}, { tip: tip2 }) {
  return [AL, tip2 ? void 0 : T5, F4, FO, S4, SO, SW, O3, H4].filter((c9) => c9 !== void 0);
}
function groupZ(I4, Z3, z5) {
  const G3 = group(I4, (i6) => Z3[i6]);
  if (z5 === void 0 && G3.size > 1 + I4.length >> 1) {
    warn(
      `Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null.`
    );
  }
  return G3.values();
}
function* groupIndex(I4, position2, mark, channels) {
  const { z: z5 } = mark;
  const { z: Z3 } = channels;
  const A6 = groupAesthetics(channels, mark);
  const C5 = [...position2, ...A6];
  for (const G3 of Z3 ? groupZ(I4, Z3, z5) : [I4]) {
    let Ag;
    let Gg;
    out:
      for (const i6 of G3) {
        for (const c9 of C5) {
          if (!defined(c9[i6])) {
            if (Gg)
              Gg.push(-1);
            continue out;
          }
        }
        if (Ag === void 0) {
          if (Gg)
            yield Gg;
          Ag = A6.map((c9) => keyof2(c9[i6])), Gg = [i6];
          continue;
        }
        Gg.push(i6);
        for (let j5 = 0; j5 < A6.length; ++j5) {
          const k6 = keyof2(A6[j5][i6]);
          if (k6 !== Ag[j5]) {
            yield Gg;
            Ag = A6.map((c9) => keyof2(c9[i6])), Gg = [i6];
            continue out;
          }
        }
      }
    if (Gg)
      yield Gg;
  }
}
function maybeClip(clip) {
  if (clip === true)
    clip = "frame";
  else if (clip === false)
    clip = null;
  return maybeKeyword(clip, "clip", ["frame", "sphere"]);
}
function applyClip(selection2, mark, dimensions, context) {
  let clipUrl;
  switch (mark.clip) {
    case "frame": {
      const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;
      const id2 = getClipId();
      clipUrl = `url(#${id2})`;
      selection2 = create2("svg:g", context).call(
        (g6) => g6.append("svg:clipPath").attr("id", id2).append("rect").attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginRight - marginLeft).attr("height", height - marginTop - marginBottom)
      ).each(function() {
        this.appendChild(selection2.node());
        selection2.node = () => this;
      });
      break;
    }
    case "sphere": {
      const { projection: projection3 } = context;
      if (!projection3)
        throw new Error(`the "sphere" clip option requires a projection`);
      const id2 = getClipId();
      clipUrl = `url(#${id2})`;
      selection2.append("clipPath").attr("id", id2).append("path").attr("d", path_default(projection3)({ type: "Sphere" }));
      break;
    }
  }
  applyAttr(selection2, "aria-label", mark.ariaLabel);
  applyAttr(selection2, "aria-description", mark.ariaDescription);
  applyAttr(selection2, "aria-hidden", mark.ariaHidden);
  applyAttr(selection2, "clip-path", clipUrl);
}
function applyIndirectStyles(selection2, mark, dimensions, context) {
  applyClip(selection2, mark, dimensions, context);
  applyAttr(selection2, "fill", mark.fill);
  applyAttr(selection2, "fill-opacity", mark.fillOpacity);
  applyAttr(selection2, "stroke", mark.stroke);
  applyAttr(selection2, "stroke-width", mark.strokeWidth);
  applyAttr(selection2, "stroke-opacity", mark.strokeOpacity);
  applyAttr(selection2, "stroke-linejoin", mark.strokeLinejoin);
  applyAttr(selection2, "stroke-linecap", mark.strokeLinecap);
  applyAttr(selection2, "stroke-miterlimit", mark.strokeMiterlimit);
  applyAttr(selection2, "stroke-dasharray", mark.strokeDasharray);
  applyAttr(selection2, "stroke-dashoffset", mark.strokeDashoffset);
  applyAttr(selection2, "shape-rendering", mark.shapeRendering);
  applyAttr(selection2, "filter", mark.imageFilter);
  applyAttr(selection2, "paint-order", mark.paintOrder);
  const { pointerEvents = context.pointerSticky === false ? "none" : void 0 } = mark;
  applyAttr(selection2, "pointer-events", pointerEvents);
}
function applyDirectStyles(selection2, mark) {
  applyStyle(selection2, "mix-blend-mode", mark.mixBlendMode);
  applyAttr(selection2, "opacity", mark.opacity);
}
function applyHref(selection2, href, target) {
  selection2.each(function(i6) {
    const h5 = href(i6);
    if (h5 != null) {
      const a7 = this.ownerDocument.createElementNS(namespaces_default.svg, "a");
      a7.setAttribute("fill", "inherit");
      a7.setAttributeNS(namespaces_default.xlink, "href", h5);
      if (target != null)
        a7.setAttribute("target", target);
      this.parentNode.insertBefore(a7, this).appendChild(this);
    }
  });
}
function applyAttr(selection2, name, value) {
  if (value != null)
    selection2.attr(name, value);
}
function applyStyle(selection2, name, value) {
  if (value != null)
    selection2.style(name, value);
}
function applyTransform(selection2, mark, { x: x6, y: y5 }, tx = offset, ty = offset) {
  tx += mark.dx;
  ty += mark.dy;
  if (x6?.bandwidth)
    tx += x6.bandwidth() / 2;
  if (y5?.bandwidth)
    ty += y5.bandwidth() / 2;
  if (tx || ty)
    selection2.attr("transform", `translate(${tx},${ty})`);
}
function impliedString(value, impliedValue) {
  if ((value = string(value)) !== impliedValue)
    return value;
}
function impliedNumber(value, impliedValue) {
  if ((value = number5(value)) !== impliedValue)
    return value;
}
var validClassName = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/i;
function maybeClassName(name) {
  if (name === void 0)
    return "plot-d6a7b5";
  name = `${name}`;
  if (!validClassName.test(name))
    throw new Error(`invalid class name: ${name}`);
  return name;
}
function applyInlineStyles(selection2, style) {
  if (typeof style === "string") {
    selection2.property("style", style);
  } else if (style != null) {
    for (const element of selection2) {
      Object.assign(element.style, style);
    }
  }
}
function applyFrameAnchor({ frameAnchor }, { width, height, marginTop, marginRight, marginBottom, marginLeft }) {
  return [
    /left$/.test(frameAnchor) ? marginLeft : /right$/.test(frameAnchor) ? width - marginRight : (marginLeft + width - marginRight) / 2,
    /^top/.test(frameAnchor) ? marginTop : /^bottom/.test(frameAnchor) ? height - marginBottom : (marginTop + height - marginBottom) / 2
  ];
}

// node_modules/@observablehq/plot/src/dimensions.js
function createDimensions(scales, marks2, options = {}) {
  let marginTopDefault = 0.5 - offset, marginRightDefault = 0.5 + offset, marginBottomDefault = 0.5 + offset, marginLeftDefault = 0.5 - offset;
  for (const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } of marks2) {
    if (marginTop2 > marginTopDefault)
      marginTopDefault = marginTop2;
    if (marginRight2 > marginRightDefault)
      marginRightDefault = marginRight2;
    if (marginBottom2 > marginBottomDefault)
      marginBottomDefault = marginBottom2;
    if (marginLeft2 > marginLeftDefault)
      marginLeftDefault = marginLeft2;
  }
  let {
    margin,
    marginTop = margin !== void 0 ? margin : marginTopDefault,
    marginRight = margin !== void 0 ? margin : marginRightDefault,
    marginBottom = margin !== void 0 ? margin : marginBottomDefault,
    marginLeft = margin !== void 0 ? margin : marginLeftDefault
  } = options;
  marginTop = +marginTop;
  marginRight = +marginRight;
  marginBottom = +marginBottom;
  marginLeft = +marginLeft;
  let {
    width = 640,
    height = autoHeight(scales, options, {
      width,
      marginTopDefault,
      marginRightDefault,
      marginBottomDefault,
      marginLeftDefault
    }) + Math.max(0, marginTop - marginTopDefault + marginBottom - marginBottomDefault)
  } = options;
  width = +width;
  height = +height;
  const dimensions = {
    width,
    height,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft
  };
  if (scales.fx || scales.fy) {
    let {
      margin: facetMargin,
      marginTop: facetMarginTop = facetMargin !== void 0 ? facetMargin : marginTop,
      marginRight: facetMarginRight = facetMargin !== void 0 ? facetMargin : marginRight,
      marginBottom: facetMarginBottom = facetMargin !== void 0 ? facetMargin : marginBottom,
      marginLeft: facetMarginLeft = facetMargin !== void 0 ? facetMargin : marginLeft
    } = options.facet ?? {};
    facetMarginTop = +facetMarginTop;
    facetMarginRight = +facetMarginRight;
    facetMarginBottom = +facetMarginBottom;
    facetMarginLeft = +facetMarginLeft;
    dimensions.facet = {
      marginTop: facetMarginTop,
      marginRight: facetMarginRight,
      marginBottom: facetMarginBottom,
      marginLeft: facetMarginLeft
    };
  }
  return dimensions;
}
function autoHeight({ x: x6, y: y5, fy, fx }, { projection: projection3, aspectRatio }, { width, marginTopDefault, marginRightDefault, marginBottomDefault, marginLeftDefault }) {
  const nfy = fy ? fy.scale.domain().length : 1;
  const ar = projectionAspectRatio(projection3);
  if (ar) {
    const nfx = fx ? fx.scale.domain().length : 1;
    const far = (1.1 * nfy - 0.1) / (1.1 * nfx - 0.1) * ar;
    const lar = Math.max(0.1, Math.min(10, far));
    return Math.round((width - marginLeftDefault - marginRightDefault) * lar + marginTopDefault + marginBottomDefault);
  }
  const ny = y5 ? isOrdinalScale(y5) ? y5.scale.domain().length : Math.max(7, 17 / nfy) : 1;
  if (aspectRatio != null) {
    aspectRatio = +aspectRatio;
    if (!(isFinite(aspectRatio) && aspectRatio > 0))
      throw new Error(`invalid aspectRatio: ${aspectRatio}`);
    const ratio = aspectRatioLength("y", y5) / (aspectRatioLength("x", x6) * aspectRatio);
    const fxb = fx ? fx.scale.bandwidth() : 1;
    const fyb = fy ? fy.scale.bandwidth() : 1;
    const w5 = fxb * (width - marginLeftDefault - marginRightDefault) - x6.insetLeft - x6.insetRight;
    return (ratio * w5 + y5.insetTop + y5.insetBottom) / fyb + marginTopDefault + marginBottomDefault;
  }
  return !!(y5 || fy) * Math.max(1, Math.min(60, ny * nfy)) * 20 + !!fx * 30 + 60;
}
function aspectRatioLength(k6, scale2) {
  if (!scale2)
    throw new Error(`aspectRatio requires ${k6} scale`);
  const { type: type3, domain } = scale2;
  let transform2;
  switch (type3) {
    case "linear":
    case "utc":
    case "time":
      transform2 = Number;
      break;
    case "pow": {
      const exponent = scale2.scale.exponent();
      transform2 = (x6) => Math.pow(x6, exponent);
      break;
    }
    case "log":
      transform2 = Math.log;
      break;
    case "point":
    case "band":
      return domain.length;
    default:
      throw new Error(`unsupported ${k6} scale for aspectRatio: ${type3}`);
  }
  const [min4, max4] = extent(domain);
  return Math.abs(transform2(max4) - transform2(min4));
}

// node_modules/@observablehq/plot/src/facet.js
function createFacets(channelsByScale, options) {
  const { fx, fy } = createScales(channelsByScale, options);
  const fxDomain = fx?.scale.domain();
  const fyDomain = fy?.scale.domain();
  return fxDomain && fyDomain ? cross(fxDomain, fyDomain).map(([x6, y5], i6) => ({ x: x6, y: y5, i: i6 })) : fxDomain ? fxDomain.map((x6, i6) => ({ x: x6, i: i6 })) : fyDomain ? fyDomain.map((y5, i6) => ({ y: y5, i: i6 })) : void 0;
}
function recreateFacets(facets, { x: X3, y: Y3 }) {
  X3 &&= facetIndex(X3);
  Y3 &&= facetIndex(Y3);
  return facets.filter(
    X3 && Y3 ? (f4) => X3.has(f4.x) && Y3.has(f4.y) : X3 ? (f4) => X3.has(f4.x) : (f4) => Y3.has(f4.y)
  ).sort(
    X3 && Y3 ? (a7, b5) => X3.get(a7.x) - X3.get(b5.x) || Y3.get(a7.y) - Y3.get(b5.y) : X3 ? (a7, b5) => X3.get(a7.x) - X3.get(b5.x) : (a7, b5) => Y3.get(a7.y) - Y3.get(b5.y)
  );
}
function facetGroups(data, { fx, fy }) {
  const I4 = range2(data);
  const FX = fx?.value;
  const FY = fy?.value;
  return fx && fy ? rollup(
    I4,
    (G3) => (G3.fx = FX[G3[0]], G3.fy = FY[G3[0]], G3),
    (i6) => FX[i6],
    (i6) => FY[i6]
  ) : fx ? rollup(
    I4,
    (G3) => (G3.fx = FX[G3[0]], G3),
    (i6) => FX[i6]
  ) : rollup(
    I4,
    (G3) => (G3.fy = FY[G3[0]], G3),
    (i6) => FY[i6]
  );
}
function facetTranslator(fx, fy, { marginTop, marginLeft }) {
  return fx && fy ? ({ x: x6, y: y5 }) => `translate(${fx(x6) - marginLeft},${fy(y5) - marginTop})` : fx ? ({ x: x6 }) => `translate(${fx(x6) - marginLeft},0)` : ({ y: y5 }) => `translate(0,${fy(y5) - marginTop})`;
}
function facetExclude(index2) {
  const ex = [];
  const e9 = new Uint32Array(sum(index2, (d6) => d6.length));
  for (const i6 of index2) {
    let n9 = 0;
    for (const j5 of index2) {
      if (i6 === j5)
        continue;
      e9.set(j5, n9);
      n9 += j5.length;
    }
    ex.push(e9.slice(0, n9));
  }
  return ex;
}
var facetAnchors = /* @__PURE__ */ new Map([
  ["top", facetAnchorTop],
  ["right", facetAnchorRight],
  ["bottom", facetAnchorBottom],
  ["left", facetAnchorLeft],
  ["top-left", and(facetAnchorTop, facetAnchorLeft)],
  ["top-right", and(facetAnchorTop, facetAnchorRight)],
  ["bottom-left", and(facetAnchorBottom, facetAnchorLeft)],
  ["bottom-right", and(facetAnchorBottom, facetAnchorRight)],
  ["top-empty", facetAnchorTopEmpty],
  ["right-empty", facetAnchorRightEmpty],
  ["bottom-empty", facetAnchorBottomEmpty],
  ["left-empty", facetAnchorLeftEmpty],
  ["empty", facetAnchorEmpty]
]);
function maybeFacetAnchor(facetAnchor) {
  if (facetAnchor == null)
    return null;
  const anchor = facetAnchors.get(`${facetAnchor}`.toLowerCase());
  if (anchor)
    return anchor;
  throw new Error(`invalid facet anchor: ${facetAnchor}`);
}
var indexCache = /* @__PURE__ */ new WeakMap();
function facetIndex(V4) {
  let I4 = indexCache.get(V4);
  if (!I4)
    indexCache.set(V4, I4 = new InternMap(map3(V4, (v4, i6) => [v4, i6])));
  return I4;
}
function facetIndexOf(V4, v4) {
  return facetIndex(V4).get(v4);
}
function facetFind(facets, x6, y5) {
  x6 = keyof2(x6);
  y5 = keyof2(y5);
  return facets.find((f4) => Object.is(keyof2(f4.x), x6) && Object.is(keyof2(f4.y), y5));
}
function facetEmpty(facets, x6, y5) {
  return facetFind(facets, x6, y5)?.empty;
}
function facetAnchorTop(facets, { y: Y3 }, { y: y5 }) {
  return Y3 ? facetIndexOf(Y3, y5) === 0 : true;
}
function facetAnchorBottom(facets, { y: Y3 }, { y: y5 }) {
  return Y3 ? facetIndexOf(Y3, y5) === Y3.length - 1 : true;
}
function facetAnchorLeft(facets, { x: X3 }, { x: x6 }) {
  return X3 ? facetIndexOf(X3, x6) === 0 : true;
}
function facetAnchorRight(facets, { x: X3 }, { x: x6 }) {
  return X3 ? facetIndexOf(X3, x6) === X3.length - 1 : true;
}
function facetAnchorTopEmpty(facets, { y: Y3 }, { x: x6, y: y5, empty: empty3 }) {
  if (empty3)
    return false;
  if (!Y3)
    return;
  const i6 = facetIndexOf(Y3, y5);
  if (i6 > 0)
    return facetEmpty(facets, x6, Y3[i6 - 1]);
}
function facetAnchorBottomEmpty(facets, { y: Y3 }, { x: x6, y: y5, empty: empty3 }) {
  if (empty3)
    return false;
  if (!Y3)
    return;
  const i6 = facetIndexOf(Y3, y5);
  if (i6 < Y3.length - 1)
    return facetEmpty(facets, x6, Y3[i6 + 1]);
}
function facetAnchorLeftEmpty(facets, { x: X3 }, { x: x6, y: y5, empty: empty3 }) {
  if (empty3)
    return false;
  if (!X3)
    return;
  const i6 = facetIndexOf(X3, x6);
  if (i6 > 0)
    return facetEmpty(facets, X3[i6 - 1], y5);
}
function facetAnchorRightEmpty(facets, { x: X3 }, { x: x6, y: y5, empty: empty3 }) {
  if (empty3)
    return false;
  if (!X3)
    return;
  const i6 = facetIndexOf(X3, x6);
  if (i6 < X3.length - 1)
    return facetEmpty(facets, X3[i6 + 1], y5);
}
function facetAnchorEmpty(facets, channels, { empty: empty3 }) {
  return empty3;
}
function and(a7, b5) {
  return function() {
    return a7.apply(null, arguments) && b5.apply(null, arguments);
  };
}
function facetFilter(facets, { channels: { fx, fy }, groups: groups2 }) {
  return fx && fy ? facets.map(({ x: x6, y: y5 }) => groups2.get(x6)?.get(y5) ?? []) : fx ? facets.map(({ x: x6 }) => groups2.get(x6) ?? []) : facets.map(({ y: y5 }) => groups2.get(y5) ?? []);
}

// node_modules/@observablehq/plot/src/mark.js
var Mark = class {
  constructor(data, channels = {}, options = {}, defaults8) {
    const {
      facet = "auto",
      facetAnchor,
      fx,
      fy,
      sort: sort2,
      dx = 0,
      dy = 0,
      margin = 0,
      marginTop = margin,
      marginRight = margin,
      marginBottom = margin,
      marginLeft = margin,
      clip,
      channels: extraChannels,
      tip: tip2,
      render: render3
    } = options;
    this.data = data;
    this.sort = isDomainSort(sort2) ? sort2 : null;
    this.initializer = initializer(options).initializer;
    this.transform = this.initializer ? options.transform : basic(options).transform;
    if (facet === null || facet === false) {
      this.facet = null;
    } else {
      this.facet = keyword(facet === true ? "include" : facet, "facet", ["auto", "include", "exclude", "super"]);
      this.fx = data === singleton && typeof fx === "string" ? [fx] : fx;
      this.fy = data === singleton && typeof fy === "string" ? [fy] : fy;
    }
    this.facetAnchor = maybeFacetAnchor(facetAnchor);
    channels = maybeNamed(channels);
    if (extraChannels !== void 0)
      channels = { ...maybeChannels(extraChannels), ...channels };
    if (defaults8 !== void 0)
      channels = { ...styles(this, options, defaults8), ...channels };
    this.channels = Object.fromEntries(
      Object.entries(channels).map(([name, channel]) => {
        if (isOptions(channel.value)) {
          const { value, scale: scale2 = channel.scale } = channel.value;
          channel = { ...channel, scale: scale2, value };
        }
        if (data === singleton && typeof channel.value === "string") {
          const { value } = channel;
          channel = { ...channel, value: [value] };
        }
        return [name, channel];
      }).filter(([name, { value, optional }]) => {
        if (value != null)
          return true;
        if (optional)
          return false;
        throw new Error(`missing channel value: ${name}`);
      })
    );
    this.dx = +dx;
    this.dy = +dy;
    this.marginTop = +marginTop;
    this.marginRight = +marginRight;
    this.marginBottom = +marginBottom;
    this.marginLeft = +marginLeft;
    this.clip = maybeClip(clip);
    this.tip = maybeTip(tip2);
    if (this.facet === "super") {
      if (fx || fy)
        throw new Error(`super-faceting cannot use fx or fy`);
      for (const name in this.channels) {
        const { scale: scale2 } = channels[name];
        if (scale2 !== "x" && scale2 !== "y")
          continue;
        throw new Error(`super-faceting cannot use x or y`);
      }
    }
    if (render3 != null) {
      this.render = composeRender(render3, this.render);
    }
  }
  initialize(facets, facetChannels, plotOptions) {
    let data = arrayify2(this.data);
    if (facets === void 0 && data != null)
      facets = [range2(data)];
    const originalFacets = facets;
    if (this.transform != null)
      ({ facets, data } = this.transform(data, facets, plotOptions)), data = arrayify2(data);
    if (facets !== void 0)
      facets.original = originalFacets;
    const channels = createChannels(this.channels, data);
    if (this.sort != null)
      channelDomain(data, facets, channels, facetChannels, this.sort);
    return { data, facets, channels };
  }
  filter(index2, channels, values2) {
    for (const name in channels) {
      const { filter: filter2 = defined } = channels[name];
      if (filter2 !== null) {
        const value = values2[name];
        index2 = index2.filter((i6) => filter2(value[i6]));
      }
    }
    return index2;
  }
  // If there is a projection, and there are paired x and y channels associated
  // with the x and y scale respectively (and not already in screen coordinates
  // as with an initializer), then apply the projection, replacing the x and y
  // values. Note that the x and y scales themselves dont exist if there is a
  // projection, but whether the channels are associated with scales still
  // determines whether the projection should apply; think of the projection as
  // a combination xy-scale.
  project(channels, values2, context) {
    for (const cx in channels) {
      if (channels[cx].scale === "x" && /^x|x$/.test(cx)) {
        const cy = cx.replace(/^x|x$/, "y");
        if (cy in channels && channels[cy].scale === "y") {
          project(cx, cy, values2, context.projection);
        }
      }
    }
  }
  scale(channels, scales, context) {
    const values2 = valueObject(channels, scales);
    if (context.projection)
      this.project(channels, values2, context);
    return values2;
  }
};
function marks(...marks2) {
  marks2.plot = Mark.prototype.plot;
  return marks2;
}
function composeRender(r1, r22) {
  if (r1 == null)
    return r22 === null ? void 0 : r22;
  if (r22 == null)
    return r1 === null ? void 0 : r1;
  if (typeof r1 !== "function")
    throw new TypeError(`invalid render transform: ${r1}`);
  if (typeof r22 !== "function")
    throw new TypeError(`invalid render transform: ${r22}`);
  return function(i6, s8, v4, d6, c9, next) {
    return r1.call(this, i6, s8, v4, d6, c9, (i7, s9, v5, d7, c10) => {
      return r22.call(this, i7, s9, v5, d7, c10, next);
    });
  };
}
function maybeChannels(channels) {
  return Object.fromEntries(
    Object.entries(maybeNamed(channels)).map(([name, channel]) => {
      channel = maybeValue(channel);
      if (channel.filter === void 0 && channel.scale == null)
        channel = { ...channel, filter: null };
      return [name, channel];
    })
  );
}
function maybeTip(tip2) {
  return tip2 === true ? "xy" : tip2 === false ? null : maybeKeyword(tip2, "tip", ["x", "y", "xy"]);
}
function withTip(options, tip2) {
  return options?.tip === true ? { ...options, tip: tip2 } : options;
}

// node_modules/@observablehq/plot/src/interactions/pointer.js
var states = /* @__PURE__ */ new WeakMap();
function pointerK(kx2, ky2, { x: x6, y: y5, px, py, maxRadius = 40, channels, render: render3, ...options } = {}) {
  maxRadius = +maxRadius;
  if (px != null)
    x6 ??= null, channels = { ...channels, px: { value: px, scale: "x" } };
  if (py != null)
    y5 ??= null, channels = { ...channels, py: { value: py, scale: "y" } };
  return {
    x: x6,
    y: y5,
    channels,
    ...options,
    // Unlike other composed transforms, the render transform must be the
    // outermost render function because it will re-render dynamically in
    // response to pointer events.
    render: composeRender(function(index2, scales, values2, dimensions, context, next) {
      context = { ...context, pointerSticky: false };
      const svg = context.ownerSVGElement;
      const { data } = context.getMarkState(this);
      let state = states.get(svg);
      if (!state)
        states.set(svg, state = { sticky: false, roots: [], renders: [] });
      let renderIndex = state.renders.push(render4) - 1;
      const { x: x7, y: y6, fx, fy } = scales;
      let tx = fx ? fx(index2.fx) - dimensions.marginLeft : 0;
      let ty = fy ? fy(index2.fy) - dimensions.marginTop : 0;
      if (x7?.bandwidth)
        tx += x7.bandwidth() / 2;
      if (y6?.bandwidth)
        ty += y6.bandwidth() / 2;
      const faceted = index2.fi != null;
      let facetState;
      if (faceted) {
        let facetStates = state.facetStates;
        if (!facetStates)
          state.facetStates = facetStates = /* @__PURE__ */ new Map();
        facetState = facetStates.get(this);
        if (!facetState)
          facetStates.set(this, facetState = /* @__PURE__ */ new Map());
      }
      const [cx, cy] = applyFrameAnchor(this, dimensions);
      const { px: PX, py: PY } = values2;
      const px2 = PX ? (i7) => PX[i7] : anchorX(values2, cx);
      const py2 = PY ? (i7) => PY[i7] : anchorY(values2, cy);
      let i6;
      let g6;
      let s8;
      let f4;
      function update(ii, ri) {
        if (faceted) {
          if (f4)
            f4 = cancelAnimationFrame(f4);
          if (ii == null)
            facetState.delete(index2.fi);
          else {
            facetState.set(index2.fi, ri);
            f4 = requestAnimationFrame(() => {
              f4 = null;
              for (const r6 of facetState.values()) {
                if (r6 < ri) {
                  ii = null;
                  break;
                }
              }
              render4(ii);
            });
            return;
          }
        }
        render4(ii);
      }
      function render4(ii) {
        if (i6 === ii && s8 === state.sticky)
          return;
        i6 = ii;
        s8 = context.pointerSticky = state.sticky;
        const I4 = i6 == null ? [] : [i6];
        if (faceted)
          I4.fx = index2.fx, I4.fy = index2.fy, I4.fi = index2.fi;
        const r6 = next(I4, scales, values2, dimensions, context);
        if (g6) {
          if (faceted) {
            const p5 = g6.parentNode;
            const ft = g6.getAttribute("transform");
            const mt = r6.getAttribute("transform");
            ft ? r6.setAttribute("transform", ft) : r6.removeAttribute("transform");
            mt ? p5.setAttribute("transform", mt) : p5.removeAttribute("transform");
            r6.removeAttribute("aria-label");
            r6.removeAttribute("aria-description");
            r6.removeAttribute("aria-hidden");
          }
          g6.replaceWith(r6);
        }
        state.roots[renderIndex] = g6 = r6;
        context.dispatchValue(i6 == null ? null : data[i6]);
        return r6;
      }
      function pointermove(event) {
        if (state.sticky || event.pointerType === "mouse" && event.buttons === 1)
          return;
        let [xp, yp] = pointer_default(event);
        xp -= tx, yp -= ty;
        let ii = null;
        let ri = maxRadius * maxRadius;
        for (const j5 of index2) {
          const dx = kx2 * (px2(j5) - xp);
          const dy = ky2 * (py2(j5) - yp);
          const rj = dx * dx + dy * dy;
          if (rj <= ri)
            ii = j5, ri = rj;
        }
        update(ii, ri);
      }
      function pointerdown(event) {
        if (event.pointerType !== "mouse")
          return;
        if (i6 == null)
          return;
        if (state.sticky && state.roots.some((r6) => r6?.contains(event.target)))
          return;
        if (state.sticky)
          state.sticky = false, state.renders.forEach((r6) => r6(null));
        else
          state.sticky = true, render4(i6);
        event.stopImmediatePropagation();
      }
      function pointerleave(event) {
        if (event.pointerType !== "mouse")
          return;
        if (!state.sticky)
          update(null);
      }
      svg.addEventListener("pointerenter", pointermove);
      svg.addEventListener("pointermove", pointermove);
      svg.addEventListener("pointerdown", pointerdown);
      svg.addEventListener("pointerleave", pointerleave);
      return render4(null);
    }, render3)
  };
}
function pointer(options) {
  return pointerK(1, 1, options);
}
function pointerX(options) {
  return pointerK(1, 0.01, options);
}
function pointerY(options) {
  return pointerK(0.01, 1, options);
}
function anchorX({ x1: X12, x2: X23, x: X3 = X12 }, cx) {
  return X12 && X23 ? (i6) => (X12[i6] + X23[i6]) / 2 : X3 ? (i6) => X3[i6] : () => cx;
}
function anchorY({ y1: Y12, y2: Y23, y: Y3 = Y12 }, cy) {
  return Y12 && Y23 ? (i6) => (Y12[i6] + Y23[i6]) / 2 : Y3 ? (i6) => Y3[i6] : () => cy;
}

// node_modules/@observablehq/plot/src/axes.js
function inferFontVariant(scale2) {
  return isOrdinalScale(scale2) && scale2.interval === void 0 ? void 0 : "tabular-nums";
}

// node_modules/@observablehq/plot/src/legends/ramp.js
function legendRamp(color3, options) {
  let {
    label = color3.label,
    tickSize = 6,
    width = 240,
    height = 44 + tickSize,
    marginTop = 18,
    marginRight = 0,
    marginBottom = 16 + tickSize,
    marginLeft = 0,
    style,
    ticks: ticks2 = (width - marginLeft - marginRight) / 64,
    tickFormat: tickFormat2,
    fontVariant = inferFontVariant(color3),
    round = true,
    opacity: opacity2,
    className
  } = options;
  const context = createContext(options);
  className = maybeClassName(className);
  opacity2 = maybeNumberChannel(opacity2)[1];
  if (tickFormat2 === null)
    tickFormat2 = () => null;
  const svg = create2("svg", context).attr("class", `${className}-ramp`).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).call(
    (svg2) => (
      // Warning: if you edit this, change defaultClassName.
      svg2.append("style").text(
        `.${className}-ramp {
  display: block;
  background: white;
  height: auto;
  height: intrinsic;
  max-width: 100%;
  overflow: visible;
}
.${className}-ramp text {
  white-space: pre;
}`
      )
    )
  ).call(applyInlineStyles, style);
  let tickAdjust = (g6) => g6.selectAll(".tick line").attr("y1", marginTop + marginBottom - height);
  let x6;
  const applyRange = round ? (x7, range5) => x7.rangeRound(range5) : (x7, range5) => x7.range(range5);
  const { type: type3, domain, range: range4, interpolate: interpolate2, scale: scale2, pivot } = color3;
  if (interpolate2) {
    const interpolator = range4 === void 0 ? interpolate2 : piecewise(interpolate2.length === 1 ? interpolatePiecewise(interpolate2) : interpolate2, range4);
    x6 = applyRange(
      scale2.copy(),
      quantize_default(
        number_default(marginLeft, width - marginRight),
        Math.min(domain.length + (pivot !== void 0), range4 === void 0 ? Infinity : range4.length)
      )
    );
    const n9 = 256;
    const canvas = context.document.createElement("canvas");
    canvas.width = n9;
    canvas.height = 1;
    const context2 = canvas.getContext("2d");
    for (let i6 = 0, j5 = n9 - 1; i6 < n9; ++i6) {
      context2.fillStyle = interpolator(i6 / j5);
      context2.fillRect(i6, 0, 1, 1);
    }
    svg.append("image").attr("opacity", opacity2).attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginLeft - marginRight).attr("height", height - marginTop - marginBottom).attr("preserveAspectRatio", "none").attr("xlink:href", canvas.toDataURL());
  } else if (type3 === "threshold") {
    const thresholds = domain;
    const thresholdFormat = tickFormat2 === void 0 ? (d6) => d6 : typeof tickFormat2 === "string" ? format(tickFormat2) : tickFormat2;
    x6 = applyRange(linear2().domain([-1, range4.length - 1]), [marginLeft, width - marginRight]);
    svg.append("g").attr("fill-opacity", opacity2).selectAll().data(range4).enter().append("rect").attr("x", (d6, i6) => x6(i6 - 1)).attr("y", marginTop).attr("width", (d6, i6) => x6(i6) - x6(i6 - 1)).attr("height", height - marginTop - marginBottom).attr("fill", (d6) => d6);
    ticks2 = map3(thresholds, (_4, i6) => i6);
    tickFormat2 = (i6) => thresholdFormat(thresholds[i6], i6);
  } else {
    x6 = applyRange(band().domain(domain), [marginLeft, width - marginRight]);
    svg.append("g").attr("fill-opacity", opacity2).selectAll().data(domain).enter().append("rect").attr("x", x6).attr("y", marginTop).attr("width", Math.max(0, x6.bandwidth() - 1)).attr("height", height - marginTop - marginBottom).attr("fill", scale2);
    tickAdjust = () => {
    };
  }
  svg.append("g").attr("transform", `translate(0,${height - marginBottom})`).call(
    axisBottom(x6).ticks(Array.isArray(ticks2) ? null : ticks2, typeof tickFormat2 === "string" ? tickFormat2 : void 0).tickFormat(typeof tickFormat2 === "function" ? tickFormat2 : void 0).tickSize(tickSize).tickValues(Array.isArray(ticks2) ? ticks2 : null)
  ).attr("font-size", null).attr("font-family", null).attr("font-variant", impliedString(fontVariant, "normal")).call(tickAdjust).call((g6) => g6.select(".domain").remove());
  if (label !== void 0) {
    svg.append("text").attr("x", marginLeft).attr("y", marginTop - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(label);
  }
  return svg.node();
}

// node_modules/@observablehq/plot/src/math.js
var radians3 = Math.PI / 180;

// node_modules/@observablehq/plot/src/marker.js
function markers(mark, { marker, markerStart = marker, markerMid = marker, markerEnd = marker } = {}) {
  mark.markerStart = maybeMarker(markerStart);
  mark.markerMid = maybeMarker(markerMid);
  mark.markerEnd = maybeMarker(markerEnd);
}
function maybeMarker(marker) {
  if (marker == null || marker === false)
    return null;
  if (marker === true)
    return markerCircleFill;
  if (typeof marker === "function")
    return marker;
  switch (`${marker}`.toLowerCase()) {
    case "none":
      return null;
    case "arrow":
      return markerArrow("auto");
    case "arrow-reverse":
      return markerArrow("auto-start-reverse");
    case "dot":
      return markerDot;
    case "circle":
    case "circle-fill":
      return markerCircleFill;
    case "circle-stroke":
      return markerCircleStroke;
  }
  throw new Error(`invalid marker: ${marker}`);
}
function markerArrow(orient) {
  return (color3, context) => create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", orient).attr("fill", "none").attr("stroke", color3).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((marker) => marker.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
}
function markerDot(color3, context) {
  return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color3).attr("stroke", "none").call((marker) => marker.append("circle").attr("r", 2.5)).node();
}
function markerCircleFill(color3, context) {
  return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color3).attr("stroke", "white").attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
}
function markerCircleStroke(color3, context) {
  return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "white").attr("stroke", color3).attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
}
var nextMarkerId = 0;
function applyMarkers(path2, mark, { stroke: S4 }, context) {
  return applyMarkersColor(path2, mark, S4 && ((i6) => S4[i6]), context);
}
function applyMarkersColor(path2, { markerStart, markerMid, markerEnd, stroke }, strokeof = () => stroke, context) {
  const iriByMarkerColor = /* @__PURE__ */ new Map();
  function applyMarker(marker) {
    return function(i6) {
      const color3 = strokeof(i6);
      let iriByColor = iriByMarkerColor.get(marker);
      if (!iriByColor)
        iriByMarkerColor.set(marker, iriByColor = /* @__PURE__ */ new Map());
      let iri = iriByColor.get(color3);
      if (!iri) {
        const node = this.parentNode.insertBefore(marker(color3, context), this);
        const id2 = `plot-marker-${++nextMarkerId}`;
        node.setAttribute("id", id2);
        iriByColor.set(color3, iri = `url(#${id2})`);
      }
      return iri;
    };
  }
  if (markerStart)
    path2.attr("marker-start", applyMarker(markerStart));
  if (markerMid)
    path2.attr("marker-mid", applyMarker(markerMid));
  if (markerEnd)
    path2.attr("marker-end", applyMarker(markerEnd));
}

// node_modules/@observablehq/plot/src/transforms/inset.js
function maybeInsetX({ inset, insetLeft, insetRight, ...options } = {}) {
  [insetLeft, insetRight] = maybeInset(inset, insetLeft, insetRight);
  return { inset, insetLeft, insetRight, ...options };
}
function maybeInsetY({ inset, insetTop, insetBottom, ...options } = {}) {
  [insetTop, insetBottom] = maybeInset(inset, insetTop, insetBottom);
  return { inset, insetTop, insetBottom, ...options };
}
function maybeInset(inset, inset1, inset2) {
  return inset === void 0 && inset1 === void 0 && inset2 === void 0 ? offset ? [1, 0] : [0.5, 0.5] : [inset1, inset2];
}

// node_modules/@observablehq/plot/src/transforms/interval.js
function maybeIntervalValue(value, { interval: interval2 }) {
  value = { ...maybeValue(value) };
  value.interval = maybeInterval(value.interval === void 0 ? interval2 : value.interval);
  return value;
}
function maybeIntervalK(k6, maybeInsetK, options, trivial) {
  const { [k6]: v4, [`${k6}1`]: v1, [`${k6}2`]: v22 } = options;
  const { value, interval: interval2 } = maybeIntervalValue(v4, options);
  if (value == null || interval2 == null && !trivial)
    return options;
  const label = labelof(v4);
  if (interval2 == null) {
    let V4;
    const kv = { transform: (data) => V4 || (V4 = valueof(data, value)), label };
    return {
      ...options,
      [k6]: void 0,
      [`${k6}1`]: v1 === void 0 ? kv : v1,
      [`${k6}2`]: v22 === void 0 ? kv : v22
    };
  }
  let D1, V1;
  function transform2(data) {
    if (V1 !== void 0 && data === D1)
      return V1;
    return V1 = map3(valueof(D1 = data, value), (v5) => interval2.floor(v5));
  }
  return maybeInsetK({
    ...options,
    [k6]: void 0,
    [`${k6}1`]: v1 === void 0 ? { transform: transform2, label } : v1,
    [`${k6}2`]: v22 === void 0 ? { transform: (data) => transform2(data).map((v5) => interval2.offset(v5)), label } : v22
  });
}
function maybeIntervalMidK(k6, maybeInsetK, options) {
  const { [k6]: v4 } = options;
  const { value, interval: interval2 } = maybeIntervalValue(v4, options);
  if (value == null || interval2 == null)
    return options;
  return maybeInsetK({
    ...options,
    [k6]: {
      label: labelof(v4),
      transform: (data) => {
        const V1 = map3(valueof(data, value), (v5) => interval2.floor(v5));
        const V22 = V1.map((v5) => interval2.offset(v5));
        return V1.map(
          isTemporal(V1) ? (v1, v22) => v1 == null || isNaN(v1 = +v1) || (v22 = V22[v22], v22 == null) || isNaN(v22 = +v22) ? void 0 : new Date((v1 + v22) / 2) : (v1, v22) => v1 == null || (v22 = V22[v22], v22 == null) ? NaN : (+v1 + +v22) / 2
        );
      }
    }
  });
}
function maybeIntervalX(options = {}) {
  return maybeIntervalK("x", maybeInsetX, options);
}
function maybeIntervalY(options = {}) {
  return maybeIntervalK("y", maybeInsetY, options);
}
function maybeIntervalMidX(options = {}) {
  return maybeIntervalMidK("x", maybeInsetX, options);
}
function maybeIntervalMidY(options = {}) {
  return maybeIntervalMidK("y", maybeInsetY, options);
}

// node_modules/@observablehq/plot/src/marks/rule.js
var defaults = {
  ariaLabel: "rule",
  fill: null,
  stroke: "currentColor"
};
var RuleX = class extends Mark {
  constructor(data, options = {}) {
    const { x: x6, y1: y12, y2: y22, inset = 0, insetTop = inset, insetBottom = inset } = options;
    super(
      data,
      {
        x: { value: x6, scale: "x", optional: true },
        y1: { value: y12, scale: "y", optional: true },
        y2: { value: y22, scale: "y", optional: true }
      },
      withTip(options, "x"),
      defaults
    );
    this.insetTop = number5(insetTop);
    this.insetBottom = number5(insetBottom);
    markers(this, options);
  }
  render(index2, scales, channels, dimensions, context) {
    const { x: x6, y: y5 } = scales;
    const { x: X3, y1: Y12, y2: Y23 } = channels;
    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;
    const { insetTop, insetBottom } = this;
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x6 }, offset, 0).call(
      (g6) => g6.selectAll().data(index2).enter().append("line").call(applyDirectStyles, this).attr("x1", X3 ? (i6) => X3[i6] : (marginLeft + width - marginRight) / 2).attr("x2", X3 ? (i6) => X3[i6] : (marginLeft + width - marginRight) / 2).attr("y1", Y12 && !isCollapsed(y5) ? (i6) => Y12[i6] + insetTop : marginTop + insetTop).attr(
        "y2",
        Y23 && !isCollapsed(y5) ? y5.bandwidth ? (i6) => Y23[i6] + y5.bandwidth() - insetBottom : (i6) => Y23[i6] - insetBottom : height - marginBottom - insetBottom
      ).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
    ).node();
  }
};
var RuleY = class extends Mark {
  constructor(data, options = {}) {
    const { x1: x12, x2: x22, y: y5, inset = 0, insetRight = inset, insetLeft = inset } = options;
    super(
      data,
      {
        y: { value: y5, scale: "y", optional: true },
        x1: { value: x12, scale: "x", optional: true },
        x2: { value: x22, scale: "x", optional: true }
      },
      withTip(options, "y"),
      defaults
    );
    this.insetRight = number5(insetRight);
    this.insetLeft = number5(insetLeft);
    markers(this, options);
  }
  render(index2, scales, channels, dimensions, context) {
    const { x: x6, y: y5 } = scales;
    const { y: Y3, x1: X12, x2: X23 } = channels;
    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;
    const { insetLeft, insetRight } = this;
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { y: Y3 && y5 }, 0, offset).call(
      (g6) => g6.selectAll().data(index2).enter().append("line").call(applyDirectStyles, this).attr("x1", X12 && !isCollapsed(x6) ? (i6) => X12[i6] + insetLeft : marginLeft + insetLeft).attr(
        "x2",
        X23 && !isCollapsed(x6) ? x6.bandwidth ? (i6) => X23[i6] + x6.bandwidth() - insetRight : (i6) => X23[i6] - insetRight : width - marginRight - insetRight
      ).attr("y1", Y3 ? (i6) => Y3[i6] : (marginTop + height - marginBottom) / 2).attr("y2", Y3 ? (i6) => Y3[i6] : (marginTop + height - marginBottom) / 2).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
    ).node();
  }
};
function ruleX(data, options) {
  let { x: x6 = identity7, y: y5, y1: y12, y2: y22, ...rest } = maybeIntervalY(options);
  [y12, y22] = maybeOptionalZero(y5, y12, y22);
  return new RuleX(data, { ...rest, x: x6, y1: y12, y2: y22 });
}
function ruleY(data, options) {
  let { y: y5 = identity7, x: x6, x1: x12, x2: x22, ...rest } = maybeIntervalX(options);
  [x12, x22] = maybeOptionalZero(x6, x12, x22);
  return new RuleY(data, { ...rest, y: y5, x1: x12, x2: x22 });
}
function maybeOptionalZero(x6, x12, x22) {
  if (x6 == null) {
    if (x12 === void 0) {
      if (x22 !== void 0)
        return [0, x22];
    } else {
      if (x22 === void 0)
        return [0, x12];
    }
  } else if (x12 === void 0) {
    return x22 === void 0 ? [0, x6] : [x6, x22];
  } else if (x22 === void 0) {
    return [x6, x12];
  }
  return [x12, x22];
}

// node_modules/@observablehq/plot/src/template.js
function template(strings, ...parts) {
  let n9 = parts.length;
  for (let j5 = 0, copy3 = true; j5 < n9; ++j5) {
    if (typeof parts[j5] !== "function") {
      if (copy3) {
        strings = strings.slice();
        copy3 = false;
      }
      strings.splice(j5, 2, strings[j5] + parts[j5] + strings[j5 + 1]);
      parts.splice(j5, 1);
      --j5, --n9;
    }
  }
  return (i6) => {
    let s8 = strings[0];
    for (let j5 = 0; j5 < n9; ++j5) {
      s8 += parts[j5](i6) + strings[j5 + 1];
    }
    return s8;
  };
}

// node_modules/@observablehq/plot/src/marks/text.js
var defaults2 = {
  ariaLabel: "text",
  strokeLinejoin: "round",
  strokeWidth: 3,
  paintOrder: "stroke"
};
var softHyphen = "\xAD";
var Text = class extends Mark {
  constructor(data, options = {}) {
    const {
      x: x6,
      y: y5,
      text: text2 = isIterable(data) && isTextual(data) ? identity7 : indexOf,
      frameAnchor,
      textAnchor = /right$/i.test(frameAnchor) ? "end" : /left$/i.test(frameAnchor) ? "start" : "middle",
      lineAnchor = /^top/i.test(frameAnchor) ? "top" : /^bottom/i.test(frameAnchor) ? "bottom" : "middle",
      lineHeight = 1,
      lineWidth = Infinity,
      textOverflow,
      monospace,
      fontFamily = monospace ? "ui-monospace, monospace" : void 0,
      fontSize,
      fontStyle,
      fontVariant,
      fontWeight,
      rotate
    } = options;
    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
    const [vfontSize, cfontSize] = maybeFontSizeChannel(fontSize);
    super(
      data,
      {
        x: { value: x6, scale: "x", optional: true },
        y: { value: y5, scale: "y", optional: true },
        fontSize: { value: vfontSize, optional: true },
        rotate: { value: numberChannel(vrotate), optional: true },
        text: { value: text2, filter: nonempty, optional: true }
      },
      options,
      defaults2
    );
    this.rotate = crotate;
    this.textAnchor = impliedString(textAnchor, "middle");
    this.lineAnchor = keyword(lineAnchor, "lineAnchor", ["top", "middle", "bottom"]);
    this.lineHeight = +lineHeight;
    this.lineWidth = +lineWidth;
    this.textOverflow = maybeTextOverflow(textOverflow);
    this.monospace = !!monospace;
    this.fontFamily = string(fontFamily);
    this.fontSize = cfontSize;
    this.fontStyle = string(fontStyle);
    this.fontVariant = string(fontVariant);
    this.fontWeight = string(fontWeight);
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    if (!(this.lineWidth >= 0))
      throw new Error(`invalid lineWidth: ${lineWidth}`);
    this.splitLines = splitter(this);
    this.clipLine = clipper(this);
  }
  render(index2, scales, channels, dimensions, context) {
    const { x: x6, y: y5 } = scales;
    const { x: X3, y: Y3, rotate: R3, text: T5, title: TL, fontSize: FS } = channels;
    const { rotate } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this, T5, dimensions).call(applyTransform, this, { x: X3 && x6, y: Y3 && y5 }).call(
      (g6) => g6.selectAll().data(index2).enter().append("text").call(applyDirectStyles, this).call(applyMultilineText, this, T5, TL).attr(
        "transform",
        template`translate(${X3 ? (i6) => X3[i6] : cx},${Y3 ? (i6) => Y3[i6] : cy})${R3 ? (i6) => ` rotate(${R3[i6]})` : rotate ? ` rotate(${rotate})` : ``}`
      ).call(applyAttr, "font-size", FS && ((i6) => FS[i6])).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function maybeTextOverflow(textOverflow) {
  return textOverflow == null ? null : keyword(textOverflow, "textOverflow", [
    "clip",
    // shorthand for clip-end
    "ellipsis",
    //  ellipsis-end
    "clip-start",
    "clip-end",
    "ellipsis-start",
    "ellipsis-middle",
    "ellipsis-end"
  ]).replace(/^(clip|ellipsis)$/, "$1-end");
}
function applyMultilineText(selection2, mark, T5, TL) {
  if (!T5)
    return;
  const { lineAnchor, lineHeight, textOverflow, splitLines, clipLine } = mark;
  selection2.each(function(i6) {
    const lines = splitLines(formatDefault(T5[i6]) ?? "").map(clipLine);
    const n9 = lines.length;
    const y5 = lineAnchor === "top" ? 0.71 : lineAnchor === "bottom" ? 1 - n9 : (164 - n9 * 100) / 200;
    if (n9 > 1) {
      let m5 = 0;
      for (let i7 = 0; i7 < n9; ++i7) {
        ++m5;
        if (!lines[i7])
          continue;
        const tspan = this.ownerDocument.createElementNS(namespaces_default.svg, "tspan");
        tspan.setAttribute("x", 0);
        if (i7 === m5 - 1)
          tspan.setAttribute("y", `${(y5 + i7) * lineHeight}em`);
        else
          tspan.setAttribute("dy", `${m5 * lineHeight}em`);
        tspan.textContent = lines[i7];
        this.appendChild(tspan);
        m5 = 0;
      }
    } else {
      if (y5)
        this.setAttribute("y", `${y5 * lineHeight}em`);
      this.textContent = lines[0];
    }
    if (textOverflow && !TL && lines[0] !== T5[i6]) {
      const title = this.ownerDocument.createElementNS(namespaces_default.svg, "title");
      title.textContent = T5[i6];
      this.appendChild(title);
    }
  });
}
function text(data, { x: x6, y: y5, ...options } = {}) {
  if (options.frameAnchor === void 0)
    [x6, y5] = maybeTuple(x6, y5);
  return new Text(data, { ...options, x: x6, y: y5 });
}
function textX(data, { x: x6 = identity7, ...options } = {}) {
  return new Text(data, maybeIntervalMidY({ ...options, x: x6 }));
}
function textY(data, { y: y5 = identity7, ...options } = {}) {
  return new Text(data, maybeIntervalMidX({ ...options, y: y5 }));
}
function applyIndirectTextStyles(selection2, mark, T5) {
  applyAttr(selection2, "text-anchor", mark.textAnchor);
  applyAttr(selection2, "font-family", mark.fontFamily);
  applyAttr(selection2, "font-size", mark.fontSize);
  applyAttr(selection2, "font-style", mark.fontStyle);
  applyAttr(selection2, "font-variant", mark.fontVariant === void 0 ? inferFontVariant2(T5) : mark.fontVariant);
  applyAttr(selection2, "font-weight", mark.fontWeight);
}
function inferFontVariant2(T5) {
  return T5 && (isNumeric(T5) || isTemporal(T5)) ? "tabular-nums" : void 0;
}
var fontSizes2 = /* @__PURE__ */ new Set([
  // global keywords
  "inherit",
  "initial",
  "revert",
  "unset",
  // absolute keywords
  "xx-small",
  "x-small",
  "small",
  "medium",
  "large",
  "x-large",
  "xx-large",
  "xxx-large",
  // relative keywords
  "larger",
  "smaller"
]);
function maybeFontSizeChannel(fontSize) {
  if (fontSize == null || typeof fontSize === "number")
    return [void 0, fontSize];
  if (typeof fontSize !== "string")
    return [fontSize, void 0];
  fontSize = fontSize.trim().toLowerCase();
  return fontSizes2.has(fontSize) || /^[+-]?\d*\.?\d+(e[+-]?\d+)?(\w*|%)$/.test(fontSize) ? [void 0, fontSize] : [fontSize, void 0];
}
function lineWrap(input, maxWidth, widthof) {
  const lines = [];
  let lineStart, lineEnd = 0;
  for (const [wordStart, wordEnd, required] of lineBreaks(input)) {
    if (lineStart === void 0)
      lineStart = wordStart;
    if (lineEnd > lineStart && widthof(input, lineStart, wordEnd) > maxWidth) {
      lines.push(input.slice(lineStart, lineEnd) + (input[lineEnd - 1] === softHyphen ? "-" : ""));
      lineStart = wordStart;
    }
    if (required) {
      lines.push(input.slice(lineStart, wordEnd));
      lineStart = void 0;
      continue;
    }
    lineEnd = wordEnd;
  }
  return lines;
}
function* lineBreaks(input) {
  let i6 = 0, j5 = 0;
  const n9 = input.length;
  while (j5 < n9) {
    let k6 = 1;
    switch (input[j5]) {
      case softHyphen:
      case "-":
        ++j5;
        yield [i6, j5, false];
        i6 = j5;
        break;
      case " ":
        yield [i6, j5, false];
        while (input[++j5] === " ")
          ;
        i6 = j5;
        break;
      case "\r":
        if (input[j5 + 1] === "\n")
          ++k6;
      case "\n":
        yield [i6, j5, true];
        j5 += k6;
        i6 = j5;
        break;
      default:
        ++j5;
        break;
    }
  }
  yield [i6, j5, true];
}
var defaultWidthMap = {
  a: 56,
  b: 63,
  c: 57,
  d: 63,
  e: 58,
  f: 37,
  g: 62,
  h: 60,
  i: 26,
  j: 26,
  k: 55,
  l: 26,
  m: 88,
  n: 60,
  o: 60,
  p: 62,
  q: 62,
  r: 39,
  s: 54,
  t: 38,
  u: 60,
  v: 55,
  w: 79,
  x: 54,
  y: 55,
  z: 55,
  A: 69,
  B: 67,
  C: 73,
  D: 74,
  E: 61,
  F: 58,
  G: 76,
  H: 75,
  I: 28,
  J: 55,
  K: 67,
  L: 58,
  M: 89,
  N: 75,
  O: 78,
  P: 65,
  Q: 78,
  R: 67,
  S: 65,
  T: 65,
  U: 75,
  V: 69,
  W: 98,
  X: 69,
  Y: 67,
  Z: 67,
  0: 64,
  1: 48,
  2: 62,
  3: 64,
  4: 66,
  5: 63,
  6: 65,
  7: 58,
  8: 65,
  9: 65,
  " ": 29,
  "!": 32,
  '"': 49,
  "'": 31,
  "(": 39,
  ")": 39,
  ",": 31,
  "-": 48,
  ".": 31,
  "/": 32,
  ":": 31,
  ";": 31,
  "?": 52,
  "\u2018": 31,
  "\u2019": 31,
  "\u201C": 47,
  "\u201D": 47,
  "\u2026": 82
};
function defaultWidth(text2, start2 = 0, end = text2.length) {
  let sum2 = 0;
  for (let i6 = start2; i6 < end; i6 = readCharacter(text2, i6)) {
    sum2 += defaultWidthMap[text2[i6]] ?? (isPictographic(text2, i6) ? 120 : defaultWidthMap.e);
  }
  return sum2;
}
function monospaceWidth(text2, start2 = 0, end = text2.length) {
  let sum2 = 0;
  for (let i6 = start2; i6 < end; i6 = readCharacter(text2, i6)) {
    sum2 += isPictographic(text2, i6) ? 200 : 100;
  }
  return sum2;
}
function splitter({ monospace, lineWidth, textOverflow }) {
  if (textOverflow != null || lineWidth == Infinity)
    return (text2) => text2.split(/\r\n?|\n/g);
  const widthof = monospace ? monospaceWidth : defaultWidth;
  const maxWidth = lineWidth * 100;
  return (text2) => lineWrap(text2, maxWidth, widthof);
}
function clipper({ monospace, lineWidth, textOverflow }) {
  if (textOverflow == null || lineWidth == Infinity)
    return (text2) => text2;
  const widthof = monospace ? monospaceWidth : defaultWidth;
  const maxWidth = lineWidth * 100;
  switch (textOverflow) {
    case "clip-start":
      return (text2) => clipStart(text2, maxWidth, widthof, "");
    case "clip-end":
      return (text2) => clipEnd(text2, maxWidth, widthof, "");
    case "ellipsis-start":
      return (text2) => clipStart(text2, maxWidth, widthof, ellipsis);
    case "ellipsis-middle":
      return (text2) => clipMiddle(text2, maxWidth, widthof, ellipsis);
    case "ellipsis-end":
      return (text2) => clipEnd(text2, maxWidth, widthof, ellipsis);
  }
}
var ellipsis = "\u2026";
function cut(text2, width, widthof, inset) {
  const I4 = [];
  let w5 = 0;
  for (let i6 = 0, j5 = 0, n9 = text2.length; i6 < n9; i6 = j5) {
    j5 = readCharacter(text2, i6);
    const l7 = widthof(text2, i6, j5);
    if (w5 + l7 > width) {
      w5 += inset;
      while (w5 > width && i6 > 0)
        j5 = i6, i6 = I4.pop(), w5 -= widthof(text2, i6, j5);
      return [i6, width - w5];
    }
    w5 += l7;
    I4.push(i6);
  }
  return [-1, 0];
}
function clipEnd(text2, width, widthof, ellipsis2) {
  text2 = text2.trim();
  const e9 = widthof(ellipsis2);
  const [i6] = cut(text2, width, widthof, e9);
  return i6 < 0 ? text2 : text2.slice(0, i6).trimEnd() + ellipsis2;
}
function clipMiddle(text2, width, widthof, ellipsis2) {
  text2 = text2.trim();
  const w5 = widthof(text2);
  if (w5 <= width)
    return text2;
  const e9 = widthof(ellipsis2) / 2;
  const [i6, ei] = cut(text2, width / 2, widthof, e9);
  const [j5] = cut(text2, w5 - width / 2 - ei + e9, widthof, -e9);
  return j5 < 0 ? ellipsis2 : text2.slice(0, i6).trimEnd() + ellipsis2 + text2.slice(readCharacter(text2, j5)).trimStart();
}
function clipStart(text2, width, widthof, ellipsis2) {
  text2 = text2.trim();
  const w5 = widthof(text2);
  if (w5 <= width)
    return text2;
  const e9 = widthof(ellipsis2);
  const [j5] = cut(text2, w5 - width + e9, widthof, -e9);
  return j5 < 0 ? ellipsis2 : ellipsis2 + text2.slice(readCharacter(text2, j5)).trimStart();
}
var reCombiner = /[\p{Combining_Mark}\p{Emoji_Modifier}]+/uy;
var rePictographic = /\p{Extended_Pictographic}/uy;
function readCharacter(text2, i6) {
  i6 += isSurrogatePair(text2, i6) ? 2 : 1;
  if (isCombiner(text2, i6))
    i6 = reCombiner.lastIndex;
  if (isZeroWidthJoiner(text2, i6))
    return readCharacter(text2, i6 + 1);
  return i6;
}
function isAscii(text2, i6) {
  return text2.charCodeAt(i6) < 128;
}
function isSurrogatePair(text2, i6) {
  const hi = text2.charCodeAt(i6);
  if (hi >= 55296 && hi < 56320) {
    const lo = text2.charCodeAt(i6 + 1);
    return lo >= 56320 && lo < 57344;
  }
  return false;
}
function isZeroWidthJoiner(text2, i6) {
  return text2.charCodeAt(i6) === 8205;
}
function isCombiner(text2, i6) {
  return isAscii(text2, i6) ? false : (reCombiner.lastIndex = i6, reCombiner.test(text2));
}
function isPictographic(text2, i6) {
  return isAscii(text2, i6) ? false : (rePictographic.lastIndex = i6, rePictographic.test(text2));
}

// node_modules/@observablehq/plot/src/marks/vector.js
var defaults3 = {
  ariaLabel: "vector",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinejoin: "round",
  strokeLinecap: "round"
};
var defaultRadius = 3.5;
var wingRatio = defaultRadius * 5;
var shapeArrow = {
  draw(context, l7, r6) {
    const wing = l7 * r6 / wingRatio;
    context.moveTo(0, 0);
    context.lineTo(0, -l7);
    context.moveTo(-wing, wing - l7);
    context.lineTo(0, -l7);
    context.lineTo(wing, wing - l7);
  }
};
var shapeSpike = {
  draw(context, l7, r6) {
    context.moveTo(-r6, 0);
    context.lineTo(0, -l7);
    context.lineTo(r6, 0);
  }
};
var shapes = /* @__PURE__ */ new Map([
  ["arrow", shapeArrow],
  ["spike", shapeSpike]
]);
function isShapeObject(value) {
  return value && typeof value.draw === "function";
}
function maybeShape(shape) {
  if (isShapeObject(shape))
    return shape;
  const value = shapes.get(`${shape}`.toLowerCase());
  if (value)
    return value;
  throw new Error(`invalid shape: ${shape}`);
}
var Vector = class extends Mark {
  constructor(data, options = {}) {
    const { x: x6, y: y5, r: r6 = defaultRadius, length: length3, rotate, shape = shapeArrow, anchor = "middle", frameAnchor } = options;
    const [vl, cl] = maybeNumberChannel(length3, 12);
    const [vr, cr] = maybeNumberChannel(rotate, 0);
    super(
      data,
      {
        x: { value: x6, scale: "x", optional: true },
        y: { value: y5, scale: "y", optional: true },
        length: { value: vl, scale: "length", optional: true },
        rotate: { value: vr, optional: true }
      },
      options,
      defaults3
    );
    this.r = +r6;
    this.length = cl;
    this.rotate = cr;
    this.shape = maybeShape(shape);
    this.anchor = keyword(anchor, "anchor", ["start", "middle", "end"]);
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
  }
  render(index2, scales, channels, dimensions, context) {
    const { x: x6, y: y5 } = scales;
    const { x: X3, y: Y3, length: L4, rotate: A6 } = channels;
    const { length: length3, rotate, anchor, shape, r: r6 } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x6, y: Y3 && y5 }).call(
      (g6) => g6.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).attr(
        "transform",
        template`translate(${X3 ? (i6) => X3[i6] : cx},${Y3 ? (i6) => Y3[i6] : cy})${A6 ? (i6) => ` rotate(${A6[i6]})` : rotate ? ` rotate(${rotate})` : ``}${anchor === "start" ? `` : anchor === "end" ? L4 ? (i6) => ` translate(0,${L4[i6]})` : ` translate(0,${length3})` : L4 ? (i6) => ` translate(0,${L4[i6] / 2})` : ` translate(0,${length3 / 2})`}`
      ).attr(
        "d",
        L4 ? (i6) => {
          const p5 = pathRound();
          shape.draw(p5, L4[i6], r6);
          return p5;
        } : (() => {
          const p5 = pathRound();
          shape.draw(p5, length3, r6);
          return p5;
        })()
      ).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function vectorX(data, options = {}) {
  const { x: x6 = identity7, ...rest } = options;
  return new Vector(data, { ...rest, x: x6 });
}
function vectorY(data, options = {}) {
  const { y: y5 = identity7, ...rest } = options;
  return new Vector(data, { ...rest, y: y5 });
}

// node_modules/@observablehq/plot/src/marks/axis.js
function maybeData(data, options) {
  if (arguments.length < 2 && !isIterable(data))
    options = data, data = null;
  if (options === void 0)
    options = {};
  return [data, options];
}
function maybeAnchor2({ anchor } = {}, anchors) {
  return anchor === void 0 ? anchors[0] : keyword(anchor, "anchor", anchors);
}
function anchorY2(options) {
  return maybeAnchor2(options, ["left", "right"]);
}
function anchorFy(options) {
  return maybeAnchor2(options, ["right", "left"]);
}
function anchorX2(options) {
  return maybeAnchor2(options, ["bottom", "top"]);
}
function anchorFx(options) {
  return maybeAnchor2(options, ["top", "bottom"]);
}
function axisY() {
  const [data, options] = maybeData(...arguments);
  return axisKy("y", anchorY2(options), data, options);
}
function axisFy() {
  const [data, options] = maybeData(...arguments);
  return axisKy("fy", anchorFy(options), data, options);
}
function axisX() {
  const [data, options] = maybeData(...arguments);
  return axisKx("x", anchorX2(options), data, options);
}
function axisFx() {
  const [data, options] = maybeData(...arguments);
  return axisKx("fx", anchorFx(options), data, options);
}
function axisKy(k6, anchor, data, {
  color: color3 = "currentColor",
  opacity: opacity2 = 1,
  stroke = color3,
  strokeOpacity = opacity2,
  strokeWidth = 1,
  fill = color3,
  fillOpacity = opacity2,
  textAnchor,
  textStroke,
  textStrokeOpacity,
  textStrokeWidth,
  tickSize = k6 === "y" ? 6 : 0,
  tickPadding,
  tickRotate,
  x: x6,
  margin,
  marginTop = margin === void 0 ? 20 : margin,
  marginRight = margin === void 0 ? anchor === "right" ? 40 : 0 : margin,
  marginBottom = margin === void 0 ? 20 : margin,
  marginLeft = margin === void 0 ? anchor === "left" ? 40 : 0 : margin,
  label,
  labelAnchor,
  labelArrow,
  labelOffset,
  ...options
}) {
  tickSize = number5(tickSize);
  tickPadding = number5(tickPadding);
  tickRotate = number5(tickRotate);
  if (labelAnchor !== void 0)
    labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "top", "bottom"]);
  labelArrow = maybeLabelArrow(labelArrow);
  return marks(
    tickSize && !isNoneish(stroke) ? axisTickKy(k6, anchor, data, {
      stroke,
      strokeOpacity,
      strokeWidth,
      tickSize,
      tickPadding,
      tickRotate,
      x: x6,
      ...options
    }) : null,
    !isNoneish(fill) ? axisTextKy(k6, anchor, data, {
      fill,
      fillOpacity,
      stroke: textStroke,
      strokeOpacity: textStrokeOpacity,
      strokeWidth: textStrokeWidth,
      textAnchor,
      tickSize,
      tickPadding,
      tickRotate,
      x: x6,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      ...options
    }) : null,
    !isNoneish(fill) && label !== null ? text(
      [],
      labelOptions({ fill, fillOpacity, ...options }, function(data2, facets, channels, scales, dimensions) {
        const scale2 = scales[k6];
        const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k6 === "y" && dimensions.inset || dimensions;
        const cla = labelAnchor ?? (scale2.bandwidth ? "center" : "top");
        const clo = labelOffset ?? (anchor === "right" ? marginRight2 : marginLeft2) - 3;
        if (cla === "center") {
          this.textAnchor = void 0;
          this.lineAnchor = anchor === "right" ? "bottom" : "top";
          this.frameAnchor = anchor;
          this.rotate = -90;
        } else {
          this.textAnchor = anchor === "right" ? "end" : "start";
          this.lineAnchor = cla;
          this.frameAnchor = `${cla}-${anchor}`;
          this.rotate = 0;
        }
        this.dy = cla === "top" ? 3 - marginTop2 : cla === "bottom" ? marginBottom2 - 3 : 0;
        this.dx = anchor === "right" ? clo : -clo;
        this.ariaLabel = `${k6}-axis label`;
        return {
          facets: [[0]],
          channels: { text: { value: [formatAxisLabel(k6, scale2, { anchor, label, labelAnchor: cla, labelArrow })] } }
        };
      })
    ) : null
  );
}
function axisKx(k6, anchor, data, {
  color: color3 = "currentColor",
  opacity: opacity2 = 1,
  stroke = color3,
  strokeOpacity = opacity2,
  strokeWidth = 1,
  fill = color3,
  fillOpacity = opacity2,
  textAnchor,
  textStroke,
  textStrokeOpacity,
  textStrokeWidth,
  tickSize = k6 === "x" ? 6 : 0,
  tickPadding,
  tickRotate,
  y: y5,
  margin,
  marginTop = margin === void 0 ? anchor === "top" ? 30 : 0 : margin,
  marginRight = margin === void 0 ? 20 : margin,
  marginBottom = margin === void 0 ? anchor === "bottom" ? 30 : 0 : margin,
  marginLeft = margin === void 0 ? 20 : margin,
  label,
  labelAnchor,
  labelArrow,
  labelOffset,
  ...options
}) {
  tickSize = number5(tickSize);
  tickPadding = number5(tickPadding);
  tickRotate = number5(tickRotate);
  if (labelAnchor !== void 0)
    labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "left", "right"]);
  labelArrow = maybeLabelArrow(labelArrow);
  return marks(
    tickSize && !isNoneish(stroke) ? axisTickKx(k6, anchor, data, {
      stroke,
      strokeOpacity,
      strokeWidth,
      tickSize,
      tickPadding,
      tickRotate,
      y: y5,
      ...options
    }) : null,
    !isNoneish(fill) ? axisTextKx(k6, anchor, data, {
      fill,
      fillOpacity,
      stroke: textStroke,
      strokeOpacity: textStrokeOpacity,
      strokeWidth: textStrokeWidth,
      textAnchor,
      tickSize,
      tickPadding,
      tickRotate,
      y: y5,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      ...options
    }) : null,
    !isNoneish(fill) && label !== null ? text(
      [],
      labelOptions({ fill, fillOpacity, ...options }, function(data2, facets, channels, scales, dimensions) {
        const scale2 = scales[k6];
        const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k6 === "x" && dimensions.inset || dimensions;
        const cla = labelAnchor ?? (scale2.bandwidth ? "center" : "right");
        const clo = labelOffset ?? (anchor === "top" ? marginTop2 : marginBottom2) - 3;
        if (cla === "center") {
          this.frameAnchor = anchor;
          this.textAnchor = void 0;
        } else {
          this.frameAnchor = `${anchor}-${cla}`;
          this.textAnchor = cla === "right" ? "end" : "start";
        }
        this.lineAnchor = anchor;
        this.dy = anchor === "top" ? -clo : clo;
        this.dx = cla === "right" ? marginRight2 - 3 : cla === "left" ? 3 - marginLeft2 : 0;
        this.ariaLabel = `${k6}-axis label`;
        return {
          facets: [[0]],
          channels: { text: { value: [formatAxisLabel(k6, scale2, { anchor, label, labelAnchor: cla, labelArrow })] } }
        };
      })
    ) : null
  );
}
function axisTickKy(k6, anchor, data, {
  strokeWidth = 1,
  strokeLinecap = null,
  strokeLinejoin = null,
  facetAnchor = anchor + (k6 === "y" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  inset = 0,
  insetLeft = inset,
  insetRight = inset,
  dx = 0,
  y: y5 = k6 === "y" ? void 0 : null,
  ...options
}) {
  return axisMark(vectorY, k6, `${k6}-axis tick`, data, {
    strokeWidth,
    strokeLinecap,
    strokeLinejoin,
    facetAnchor,
    frameAnchor,
    y: y5,
    ...options,
    dx: anchor === "left" ? +dx - offset + +insetLeft : +dx + offset - insetRight,
    anchor: "start",
    length: tickSize,
    shape: anchor === "left" ? shapeTickLeft : shapeTickRight
  });
}
function axisTickKx(k6, anchor, data, {
  strokeWidth = 1,
  strokeLinecap = null,
  strokeLinejoin = null,
  facetAnchor = anchor + (k6 === "x" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  inset = 0,
  insetTop = inset,
  insetBottom = inset,
  dy = 0,
  x: x6 = k6 === "x" ? void 0 : null,
  ...options
}) {
  return axisMark(vectorX, k6, `${k6}-axis tick`, data, {
    strokeWidth,
    strokeLinejoin,
    strokeLinecap,
    facetAnchor,
    frameAnchor,
    x: x6,
    ...options,
    dy: anchor === "bottom" ? +dy - offset - insetBottom : +dy + offset + +insetTop,
    anchor: "start",
    length: tickSize,
    shape: anchor === "bottom" ? shapeTickBottom : shapeTickTop
  });
}
function axisTextKy(k6, anchor, data, {
  facetAnchor = anchor + (k6 === "y" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  tickRotate = 0,
  tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) > 60 ? 4 * Math.cos(tickRotate * radians3) : 0),
  tickFormat: tickFormat2,
  text: text2 = typeof tickFormat2 === "function" ? tickFormat2 : void 0,
  textAnchor = Math.abs(tickRotate) > 60 ? "middle" : anchor === "left" ? "end" : "start",
  lineAnchor = tickRotate > 60 ? "top" : tickRotate < -60 ? "bottom" : "middle",
  fontVariant,
  inset = 0,
  insetLeft = inset,
  insetRight = inset,
  dx = 0,
  y: y5 = k6 === "y" ? void 0 : null,
  ...options
}) {
  return axisMark(
    textY,
    k6,
    `${k6}-axis tick label`,
    data,
    {
      facetAnchor,
      frameAnchor,
      text: text2 === void 0 ? null : text2,
      textAnchor,
      lineAnchor,
      fontVariant,
      rotate: tickRotate,
      y: y5,
      ...options,
      dx: anchor === "left" ? +dx - tickSize - tickPadding + +insetLeft : +dx + +tickSize + +tickPadding - insetRight
    },
    function(scale2, data2, ticks2, channels) {
      if (fontVariant === void 0)
        this.fontVariant = inferFontVariant3(scale2);
      if (text2 === void 0)
        channels.text = inferTextChannel(scale2, data2, ticks2, tickFormat2, anchor);
    }
  );
}
function axisTextKx(k6, anchor, data, {
  facetAnchor = anchor + (k6 === "x" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  tickRotate = 0,
  tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) >= 10 ? 4 * Math.cos(tickRotate * radians3) : 0),
  tickFormat: tickFormat2,
  text: text2 = typeof tickFormat2 === "function" ? tickFormat2 : void 0,
  textAnchor = Math.abs(tickRotate) >= 10 ? tickRotate < 0 ^ anchor === "bottom" ? "start" : "end" : "middle",
  lineAnchor = Math.abs(tickRotate) >= 10 ? "middle" : anchor === "bottom" ? "top" : "bottom",
  fontVariant,
  inset = 0,
  insetTop = inset,
  insetBottom = inset,
  dy = 0,
  x: x6 = k6 === "x" ? void 0 : null,
  ...options
}) {
  return axisMark(
    textX,
    k6,
    `${k6}-axis tick label`,
    data,
    {
      facetAnchor,
      frameAnchor,
      text: text2 === void 0 ? null : text2,
      textAnchor,
      lineAnchor,
      fontVariant,
      rotate: tickRotate,
      x: x6,
      ...options,
      dy: anchor === "bottom" ? +dy + +tickSize + +tickPadding - insetBottom : +dy - tickSize - tickPadding + +insetTop
    },
    function(scale2, data2, ticks2, channels) {
      if (fontVariant === void 0)
        this.fontVariant = inferFontVariant3(scale2);
      if (text2 === void 0)
        channels.text = inferTextChannel(scale2, data2, ticks2, tickFormat2, anchor);
    }
  );
}
function gridY() {
  const [data, options] = maybeData(...arguments);
  return gridKy("y", anchorY2(options), data, options);
}
function gridFy() {
  const [data, options] = maybeData(...arguments);
  return gridKy("fy", anchorFy(options), data, options);
}
function gridX() {
  const [data, options] = maybeData(...arguments);
  return gridKx("x", anchorX2(options), data, options);
}
function gridFx() {
  const [data, options] = maybeData(...arguments);
  return gridKx("fx", anchorFx(options), data, options);
}
function gridKy(k6, anchor, data, {
  y: y5 = k6 === "y" ? void 0 : null,
  x: x6 = null,
  x1: x12 = anchor === "left" ? x6 : null,
  x2: x22 = anchor === "right" ? x6 : null,
  ...options
}) {
  return axisMark(ruleY, k6, `${k6}-grid`, data, { y: y5, x1: x12, x2: x22, ...gridDefaults(options) });
}
function gridKx(k6, anchor, data, {
  x: x6 = k6 === "x" ? void 0 : null,
  y: y5 = null,
  y1: y12 = anchor === "top" ? y5 : null,
  y2: y22 = anchor === "bottom" ? y5 : null,
  ...options
}) {
  return axisMark(ruleX, k6, `${k6}-grid`, data, { x: x6, y1: y12, y2: y22, ...gridDefaults(options) });
}
function gridDefaults({
  color: color3 = "currentColor",
  opacity: opacity2 = 0.1,
  stroke = color3,
  strokeOpacity = opacity2,
  strokeWidth = 1,
  ...options
}) {
  return { stroke, strokeOpacity, strokeWidth, ...options };
}
function labelOptions({ fill, fillOpacity, fontFamily, fontSize, fontStyle, fontWeight, monospace, pointerEvents, shapeRendering }, initializer2) {
  [, fill] = maybeColorChannel(fill);
  [, fillOpacity] = maybeNumberChannel(fillOpacity);
  return {
    facet: "super",
    x: null,
    y: null,
    fill,
    fillOpacity,
    fontFamily,
    fontSize,
    fontStyle,
    fontWeight,
    monospace,
    pointerEvents,
    shapeRendering,
    initializer: initializer2
  };
}
function axisMark(mark, k6, ariaLabel, data, options, initialize) {
  let channels;
  function axisInitializer(data2, facets, _channels, scales, dimensions, context) {
    const initializeFacets = data2 == null && (k6 === "fx" || k6 === "fy");
    const { [k6]: scale2 } = scales;
    if (!scale2)
      throw new Error(`missing scale: ${k6}`);
    let { ticks: ticks2, tickSpacing, interval: interval2 } = options;
    if (isTemporalScale(scale2) && typeof ticks2 === "string")
      interval2 = ticks2, ticks2 = void 0;
    if (data2 == null) {
      if (isIterable(ticks2)) {
        data2 = arrayify2(ticks2);
      } else if (scale2.ticks) {
        if (ticks2 !== void 0) {
          data2 = scale2.ticks(ticks2);
        } else {
          interval2 = maybeRangeInterval(interval2 === void 0 ? scale2.interval : interval2, scale2.type);
          if (interval2 !== void 0) {
            const [min4, max4] = extent(scale2.domain());
            data2 = interval2.range(min4, interval2.offset(interval2.floor(max4)));
          } else {
            const [min4, max4] = extent(scale2.range());
            ticks2 = (max4 - min4) / (tickSpacing === void 0 ? k6 === "x" ? 80 : 35 : tickSpacing);
            data2 = scale2.ticks(ticks2);
          }
        }
      } else {
        data2 = scale2.domain();
      }
      if (k6 === "y" || k6 === "x") {
        facets = [range2(data2)];
      } else {
        channels[k6] = { scale: k6, value: identity7 };
      }
    }
    initialize?.call(this, scale2, data2, ticks2, channels);
    const initializedChannels = Object.fromEntries(
      Object.entries(channels).map(([name, channel]) => {
        return [name, { ...channel, value: valueof(data2, channel.value) }];
      })
    );
    if (initializeFacets)
      facets = context.filterFacets(data2, initializedChannels);
    return { data: data2, facets, channels: initializedChannels };
  }
  const basicInitializer = initializer(options).initializer;
  const m5 = mark(data, initializer({ ...options, initializer: axisInitializer }, basicInitializer));
  if (data == null) {
    channels = m5.channels;
    m5.channels = {};
  } else {
    channels = {};
  }
  m5.ariaLabel = ariaLabel;
  return m5;
}
function inferTextChannel(scale2, data, ticks2, tickFormat2, anchor) {
  return { value: inferTickFormat(scale2, data, ticks2, tickFormat2, anchor) };
}
function inferTickFormat(scale2, data, ticks2, tickFormat2, anchor) {
  return tickFormat2 === void 0 && isTemporalScale(scale2) ? formatTimeTicks(scale2, data, ticks2, anchor) : scale2.tickFormat ? scale2.tickFormat(isIterable(ticks2) ? null : ticks2, tickFormat2) : tickFormat2 === void 0 ? isUtcYear(scale2.interval) ? utcFormat("%Y") : isTimeYear(scale2.interval) ? timeFormat("%Y") : formatDefault : typeof tickFormat2 === "string" ? (isTemporal(scale2.domain()) ? utcFormat : format)(tickFormat2) : constant2(tickFormat2);
}
var shapeTickBottom = {
  draw(context, l7) {
    context.moveTo(0, 0);
    context.lineTo(0, l7);
  }
};
var shapeTickTop = {
  draw(context, l7) {
    context.moveTo(0, 0);
    context.lineTo(0, -l7);
  }
};
var shapeTickLeft = {
  draw(context, l7) {
    context.moveTo(0, 0);
    context.lineTo(-l7, 0);
  }
};
var shapeTickRight = {
  draw(context, l7) {
    context.moveTo(0, 0);
    context.lineTo(l7, 0);
  }
};
function inferFontVariant3(scale2) {
  return scale2.bandwidth && !scale2.interval ? void 0 : "tabular-nums";
}
function inferScaleOrder(scale2) {
  return Math.sign(orderof(scale2.domain())) * Math.sign(orderof(scale2.range()));
}
function formatAxisLabel(k6, scale2, { anchor, label = scale2.label, labelAnchor, labelArrow } = {}) {
  if (label == null || label.inferred && isTemporalish(scale2) && /^(date|time|year)$/i.test(label))
    return;
  label = String(label);
  if (labelArrow === "auto")
    labelArrow = (!scale2.bandwidth || scale2.interval) && !/[]/.test(label);
  if (!labelArrow)
    return label;
  if (labelArrow === true) {
    const order = inferScaleOrder(scale2);
    if (order)
      labelArrow = /x$/.test(k6) || labelAnchor === "center" ? /x$/.test(k6) === order < 0 ? "left" : "right" : order < 0 ? "up" : "down";
  }
  switch (labelArrow) {
    case "left":
      return `\u2190 ${label}`;
    case "right":
      return `${label} \u2192`;
    case "up":
      return anchor === "right" ? `${label} \u2191` : `\u2191 ${label}`;
    case "down":
      return anchor === "right" ? `${label} \u2193` : `\u2193 ${label}`;
  }
  return label;
}
function maybeLabelArrow(labelArrow = "auto") {
  return isNoneish(labelArrow) ? false : typeof labelArrow === "boolean" ? labelArrow : keyword(labelArrow, "labelArrow", ["auto", "up", "right", "down", "left"]);
}
function isTemporalish(scale2) {
  return isTemporalScale(scale2) || scale2.interval != null;
}

// node_modules/@observablehq/plot/src/legends/swatches.js
function maybeScale(scale2, key) {
  if (key == null)
    return key;
  const s8 = scale2(key);
  if (!s8)
    throw new Error(`scale not found: ${key}`);
  return s8;
}
function legendSwatches(color3, { opacity: opacity2, ...options } = {}) {
  if (!isOrdinalScale(color3) && !isThresholdScale(color3))
    throw new Error(`swatches legend requires ordinal or threshold color scale (not ${color3.type})`);
  return legendItems(
    color3,
    options,
    (selection2, scale2, width, height) => selection2.append("svg").attr("width", width).attr("height", height).attr("fill", scale2.scale).attr("fill-opacity", maybeNumberChannel(opacity2)[1]).append("rect").attr("width", "100%").attr("height", "100%")
  );
}
function legendSymbols(symbol2, {
  fill = symbol2.hint?.fill !== void 0 ? symbol2.hint.fill : "none",
  fillOpacity = 1,
  stroke = symbol2.hint?.stroke !== void 0 ? symbol2.hint.stroke : isNoneish(fill) ? "currentColor" : "none",
  strokeOpacity = 1,
  strokeWidth = 1.5,
  r: r6 = 4.5,
  ...options
} = {}, scale2) {
  const [vf, cf] = maybeColorChannel(fill);
  const [vs, cs] = maybeColorChannel(stroke);
  const sf = maybeScale(scale2, vf);
  const ss = maybeScale(scale2, vs);
  const size = r6 * r6 * Math.PI;
  fillOpacity = maybeNumberChannel(fillOpacity)[1];
  strokeOpacity = maybeNumberChannel(strokeOpacity)[1];
  strokeWidth = maybeNumberChannel(strokeWidth)[1];
  return legendItems(
    symbol2,
    options,
    (selection2, scale3, width, height) => selection2.append("svg").attr("viewBox", "-8 -8 16 16").attr("width", width).attr("height", height).attr("fill", vf === "color" ? (d6) => sf.scale(d6) : cf).attr("fill-opacity", fillOpacity).attr("stroke", vs === "color" ? (d6) => ss.scale(d6) : cs).attr("stroke-opacity", strokeOpacity).attr("stroke-width", strokeWidth).append("path").attr("d", (d6) => {
      const p5 = pathRound();
      symbol2.scale(d6).draw(p5, size);
      return p5;
    })
  );
}
function legendItems(scale2, options = {}, swatch) {
  let {
    columns,
    tickFormat: tickFormat2,
    fontVariant = inferFontVariant(scale2),
    // TODO label,
    swatchSize = 15,
    swatchWidth = swatchSize,
    swatchHeight = swatchSize,
    marginLeft = 0,
    className,
    style,
    width
  } = options;
  const context = createContext(options);
  className = maybeClassName(className);
  if (typeof tickFormat2 !== "function")
    tickFormat2 = inferTickFormat(scale2.scale, scale2.domain, void 0, tickFormat2);
  const swatches = create2("div", context).attr(
    "class",
    `${className}-swatches ${className}-swatches-${columns != null ? "columns" : "wrap"}`
  );
  let extraStyle;
  if (columns != null) {
    extraStyle = `.${className}-swatches-columns .${className}-swatch {
  display: flex;
  align-items: center;
  break-inside: avoid;
  padding-bottom: 1px;
}
.${className}-swatches-columns .${className}-swatch::before {
  flex-shrink: 0;
}
.${className}-swatches-columns .${className}-swatch-label {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}`;
    swatches.style("columns", columns).selectAll().data(scale2.domain).enter().append("div").attr("class", `${className}-swatch`).call(swatch, scale2, swatchWidth, swatchHeight).call(
      (item) => item.append("div").attr("class", `${className}-swatch-label`).attr("title", tickFormat2).text(tickFormat2)
    );
  } else {
    extraStyle = `.${className}-swatches-wrap {
  display: flex;
  align-items: center;
  min-height: 33px;
  flex-wrap: wrap;
}
.${className}-swatches-wrap .${className}-swatch {
  display: inline-flex;
  align-items: center;
  margin-right: 1em;
}`;
    swatches.selectAll().data(scale2.domain).enter().append("span").attr("class", `${className}-swatch`).call(swatch, scale2, swatchWidth, swatchHeight).append(function() {
      return this.ownerDocument.createTextNode(tickFormat2.apply(this, arguments));
    });
  }
  return swatches.call(
    (div) => div.insert("style", "*").text(
      `.${className}-swatches {
  font-family: system-ui, sans-serif;
  font-size: 10px;
  margin-bottom: 0.5em;
}
.${className}-swatch > svg {
  margin-right: 0.5em;
  overflow: visible;
}
${extraStyle}`
    )
  ).style("margin-left", marginLeft ? `${+marginLeft}px` : null).style("width", width === void 0 ? null : `${+width}px`).style("font-variant", impliedString(fontVariant, "normal")).call(applyInlineStyles, style).node();
}

// node_modules/@observablehq/plot/src/legends.js
var legendRegistry = /* @__PURE__ */ new Map([
  ["symbol", legendSymbols],
  ["color", legendColor],
  ["opacity", legendOpacity]
]);
function exposeLegends(scales, context, defaults8 = {}) {
  return (key, options) => {
    if (!legendRegistry.has(key))
      throw new Error(`unknown legend type: ${key}`);
    if (!(key in scales))
      return;
    return legendRegistry.get(key)(scales[key], legendOptions(context, defaults8[key], options), (key2) => scales[key2]);
  };
}
function legendOptions({ className, ...context }, { label, ticks: ticks2, tickFormat: tickFormat2 } = {}, options) {
  return inherit2(options, { className, ...context }, { label, ticks: ticks2, tickFormat: tickFormat2 });
}
function legendColor(color3, { legend = true, ...options }) {
  if (legend === true)
    legend = color3.type === "ordinal" ? "swatches" : "ramp";
  if (color3.domain === void 0)
    return;
  switch (`${legend}`.toLowerCase()) {
    case "swatches":
      return legendSwatches(color3, options);
    case "ramp":
      return legendRamp(color3, options);
    default:
      throw new Error(`unknown legend type: ${legend}`);
  }
}
function legendOpacity({ type: type3, interpolate: interpolate2, ...scale2 }, { legend = true, color: color3 = rgb(0, 0, 0), ...options }) {
  if (!interpolate2)
    throw new Error(`${type3} opacity scales are not supported`);
  if (legend === true)
    legend = "ramp";
  if (`${legend}`.toLowerCase() !== "ramp")
    throw new Error(`${legend} opacity legends are not supported`);
  return legendColor({ type: type3, ...scale2, interpolate: interpolateOpacity(color3) }, { legend, ...options });
}
function interpolateOpacity(color3) {
  const { r: r6, g: g6, b: b5 } = rgb(color3) || rgb(0, 0, 0);
  return (t6) => `rgba(${r6},${g6},${b5},${t6})`;
}
function createLegends(scales, context, options) {
  const legends = [];
  for (const [key, value] of legendRegistry) {
    const o8 = options[key];
    if (o8?.legend && key in scales) {
      const legend = value(scales[key], legendOptions(context, scales[key], o8), (key2) => scales[key2]);
      if (legend != null)
        legends.push(legend);
    }
  }
  return legends;
}

// node_modules/@observablehq/plot/src/marks/frame.js
var defaults4 = {
  ariaLabel: "frame",
  fill: "none",
  stroke: "currentColor"
};
var lineDefaults = {
  ariaLabel: "frame",
  fill: null,
  stroke: "currentColor",
  strokeLinecap: "square"
};
var Frame = class extends Mark {
  constructor(options = {}) {
    const {
      anchor = null,
      inset = 0,
      insetTop = inset,
      insetRight = inset,
      insetBottom = inset,
      insetLeft = inset,
      rx,
      ry
    } = options;
    super(singleton, void 0, options, anchor == null ? defaults4 : lineDefaults);
    this.anchor = maybeKeyword(anchor, "anchor", ["top", "right", "bottom", "left"]);
    this.insetTop = number5(insetTop);
    this.insetRight = number5(insetRight);
    this.insetBottom = number5(insetBottom);
    this.insetLeft = number5(insetLeft);
    this.rx = number5(rx);
    this.ry = number5(ry);
  }
  render(index2, scales, channels, dimensions, context) {
    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;
    const { anchor, insetTop, insetRight, insetBottom, insetLeft, rx, ry } = this;
    const x12 = marginLeft + insetLeft;
    const x22 = width - marginRight - insetRight;
    const y12 = marginTop + insetTop;
    const y22 = height - marginBottom - insetBottom;
    return create2(anchor ? "svg:line" : "svg:rect", context).datum(0).call(applyIndirectStyles, this, dimensions, context).call(applyDirectStyles, this).call(applyChannelStyles, this, channels).call(applyTransform, this, {}).call(
      anchor === "left" ? (line) => line.attr("x1", x12).attr("x2", x12).attr("y1", y12).attr("y2", y22) : anchor === "right" ? (line) => line.attr("x1", x22).attr("x2", x22).attr("y1", y12).attr("y2", y22) : anchor === "top" ? (line) => line.attr("x1", x12).attr("x2", x22).attr("y1", y12).attr("y2", y12) : anchor === "bottom" ? (line) => line.attr("x1", x12).attr("x2", x22).attr("y1", y22).attr("y2", y22) : (rect) => rect.attr("x", x12).attr("y", y12).attr("width", x22 - x12).attr("height", y22 - y12).attr("rx", rx).attr("ry", ry)
    ).node();
  }
};
function frame2(options) {
  return new Frame(options);
}

// node_modules/@observablehq/plot/src/marks/tip.js
var defaults5 = {
  ariaLabel: "tip",
  fill: "white",
  stroke: "currentColor"
};
var ignoreChannels = /* @__PURE__ */ new Set(["geometry", "href", "src", "ariaLabel"]);
var Tip = class extends Mark {
  constructor(data, options = {}) {
    if (options.tip)
      options = { ...options, tip: false };
    if (options.title === void 0 && isIterable(data) && isTextual(data))
      options = { ...options, title: identity7 };
    const {
      x: x6,
      y: y5,
      x1: x12,
      x2: x22,
      y1: y12,
      y2: y22,
      anchor,
      monospace,
      fontFamily = monospace ? "ui-monospace, monospace" : void 0,
      fontSize,
      fontStyle,
      fontVariant,
      fontWeight,
      lineHeight = 1,
      lineWidth = 20,
      frameAnchor,
      textAnchor = "start",
      textOverflow,
      textPadding = 8,
      title,
      pointerSize = 12,
      pathFilter = "drop-shadow(0 3px 4px rgba(0,0,0,0.2))"
    } = options;
    super(
      data,
      {
        x: { value: x12 != null && x22 != null ? null : x6, scale: "x", optional: true },
        // ignore midpoint
        y: { value: y12 != null && y22 != null ? null : y5, scale: "y", optional: true },
        // ignore midpoint
        x1: { value: x12, scale: "x", optional: x22 == null },
        y1: { value: y12, scale: "y", optional: y22 == null },
        x2: { value: x22, scale: "x", optional: x12 == null },
        y2: { value: y22, scale: "y", optional: y12 == null },
        title: { value: title, optional: true }
        // filter: defined
      },
      options,
      defaults5
    );
    this.anchor = maybeAnchor(anchor, "anchor");
    this.previousAnchor = this.anchor ?? "top-left";
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    this.textAnchor = impliedString(textAnchor, "middle");
    this.textPadding = +textPadding;
    this.pointerSize = +pointerSize;
    this.pathFilter = string(pathFilter);
    this.lineHeight = +lineHeight;
    this.lineWidth = +lineWidth;
    this.textOverflow = maybeTextOverflow(textOverflow);
    this.monospace = !!monospace;
    this.fontFamily = string(fontFamily);
    this.fontSize = number5(fontSize);
    this.fontStyle = string(fontStyle);
    this.fontVariant = string(fontVariant);
    this.fontWeight = string(fontWeight);
    for (const key in defaults5)
      if (key in this.channels)
        this[key] = defaults5[key];
    this.splitLines = splitter(this);
    this.clipLine = clipper(this);
  }
  render(index2, scales, values2, dimensions, context) {
    const mark = this;
    const { x: x6, y: y5, fx, fy } = scales;
    const { ownerSVGElement: svg, document: document2 } = context;
    const { anchor, monospace, lineHeight, lineWidth } = this;
    const { textPadding: r6, pointerSize: m5, pathFilter } = this;
    const { marginTop, marginLeft } = dimensions;
    const sources = getSources(values2);
    const { x1: X12, y1: Y12, x2: X23, y2: Y23, x: X3 = X12 ?? X23, y: Y3 = Y12 ?? Y23 } = values2;
    const ox = fx ? fx(index2.fx) - marginLeft : 0;
    const oy = fy ? fy(index2.fy) - marginTop : 0;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const px = anchorX(values2, cx);
    const py = anchorY(values2, cy);
    const widthof = monospace ? monospaceWidth : defaultWidth;
    const ee = widthof(ellipsis);
    const formatFx = fx && inferTickFormat(fx);
    const formatFy = fy && inferTickFormat(fy);
    function* format3(sources2, i6) {
      if ("title" in sources2) {
        const text2 = sources2.title.value[i6];
        for (const line of mark.splitLines(formatDefault(text2))) {
          yield { name: "", value: mark.clipLine(line) };
        }
        return;
      }
      for (const key in sources2) {
        if (key === "x1" && "x2" in sources2)
          continue;
        if (key === "y1" && "y2" in sources2)
          continue;
        const channel = sources2[key];
        const value = channel.value[i6];
        if (!defined(value) && channel.scale == null)
          continue;
        if (key === "x2" && "x1" in sources2) {
          yield { name: formatLabel(scales, channel, "x"), value: formatPair(sources2.x1, channel, i6) };
        } else if (key === "y2" && "y1" in sources2) {
          yield { name: formatLabel(scales, channel, "y"), value: formatPair(sources2.y1, channel, i6) };
        } else {
          const scale2 = channel.scale;
          const line = { name: formatLabel(scales, channel, key), value: formatDefault(value) };
          if (scale2 === "color" || scale2 === "opacity")
            line[scale2] = values2[key][i6];
          yield line;
        }
      }
      if (index2.fi != null && fx)
        yield { name: String(fx.label ?? "fx"), value: formatFx(index2.fx) };
      if (index2.fi != null && fy)
        yield { name: String(fy.label ?? "fy"), value: formatFy(index2.fy) };
    }
    const g6 = create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this).call(applyTransform, this, { x: X3 && x6, y: Y3 && y5 }).call(
      (g7) => g7.selectAll().data(index2).enter().append("g").attr("transform", (i6) => `translate(${Math.round(px(i6))},${Math.round(py(i6))})`).call(applyDirectStyles, this).call((g8) => g8.append("path").attr("filter", pathFilter)).call(
        (g8) => g8.append("text").each(function(i6) {
          const that = select_default2(this);
          this.setAttribute("fill", "currentColor");
          this.setAttribute("fill-opacity", 1);
          this.setAttribute("stroke", "none");
          const names2 = /* @__PURE__ */ new Set();
          for (const line of format3(sources, i6)) {
            const name = line.name;
            if (name && names2.has(name))
              continue;
            else
              names2.add(name);
            renderLine(that, line);
          }
        })
      )
    );
    function renderLine(selection2, { name, value, color: color3, opacity: opacity2 }) {
      const swatch = color3 != null || opacity2 != null;
      let title;
      let w5 = lineWidth * 100;
      const [j5] = cut(name, w5, widthof, ee);
      if (j5 >= 0) {
        name = name.slice(0, j5).trimEnd() + ellipsis;
        title = value.trim();
        value = "";
      } else {
        if (name || !value && !swatch)
          value = " " + value;
        const [k6] = cut(value, w5 - widthof(name), widthof, ee);
        if (k6 >= 0) {
          value = value.slice(0, k6).trimEnd() + ellipsis;
          title = value.trim();
        }
      }
      const line = selection2.append("tspan").attr("x", 0).attr("dy", `${lineHeight}em`).text("\u200B");
      if (name)
        line.append("tspan").attr("font-weight", "bold").text(name);
      if (value)
        line.append(() => document2.createTextNode(value));
      if (swatch)
        line.append("tspan").text(" \u25A0").attr("fill", color3).attr("fill-opacity", opacity2).style("user-select", "none");
      if (title)
        line.append("title").text(title);
    }
    function postrender() {
      const { width, height } = dimensions.facet ?? dimensions;
      g6.selectChildren().each(function(i6) {
        let { x: tx, width: w5, height: h5 } = this.getBBox();
        w5 = Math.round(w5), h5 = Math.round(h5);
        let a7 = anchor;
        if (a7 === void 0) {
          a7 = mark.previousAnchor;
          const x7 = px(i6) + ox;
          const y6 = py(i6) + oy;
          const fitLeft = x7 + w5 + r6 * 2 < width;
          const fitRight = x7 - w5 - r6 * 2 > 0;
          const fitTop = y6 + h5 + m5 + r6 * 2 + 7 < height;
          const fitBottom = y6 - h5 - m5 - r6 * 2 > 0;
          const ax = (/-left$/.test(a7) ? fitLeft || !fitRight : fitLeft && !fitRight) ? "left" : "right";
          const ay = (/^top-/.test(a7) ? fitTop || !fitBottom : fitTop && !fitBottom) ? "top" : "bottom";
          a7 = mark.previousAnchor = `${ay}-${ax}`;
        }
        const path2 = this.firstChild;
        const text2 = this.lastChild;
        path2.setAttribute("d", getPath2(a7, m5, r6, w5, h5));
        if (tx)
          for (const t6 of text2.childNodes)
            t6.setAttribute("x", -tx);
        text2.setAttribute("y", `${+getLineOffset(a7, text2.childNodes.length, lineHeight).toFixed(6)}em`);
        text2.setAttribute("transform", `translate(${getTextTranslate(a7, m5, r6, w5, h5)})`);
      });
    }
    if (svg.isConnected)
      Promise.resolve().then(postrender);
    else if (typeof requestAnimationFrame !== "undefined")
      requestAnimationFrame(postrender);
    return g6.node();
  }
};
function tip(data, { x: x6, y: y5, ...options } = {}) {
  if (options.frameAnchor === void 0)
    [x6, y5] = maybeTuple(x6, y5);
  return new Tip(data, { ...options, x: x6, y: y5 });
}
function getLineOffset(anchor, length3, lineHeight) {
  return /^top(?:-|$)/.test(anchor) ? 0.94 - lineHeight : /^bottom(?:-|$)/ ? -0.29 - length3 * lineHeight : length3 / 2 * lineHeight;
}
function getTextTranslate(anchor, m5, r6, width, height) {
  switch (anchor) {
    case "middle":
      return [-width / 2, height / 2];
    case "top-left":
      return [r6, m5 + r6];
    case "top":
      return [-width / 2, m5 / 2 + r6];
    case "top-right":
      return [-width - r6, m5 + r6];
    case "right":
      return [-m5 / 2 - width - r6, height / 2];
    case "bottom-left":
      return [r6, -m5 - r6];
    case "bottom":
      return [-width / 2, -m5 / 2 - r6];
    case "bottom-right":
      return [-width - r6, -m5 - r6];
    case "left":
      return [r6 + m5 / 2, height / 2];
  }
}
function getPath2(anchor, m5, r6, width, height) {
  const w5 = width + r6 * 2;
  const h5 = height + r6 * 2;
  switch (anchor) {
    case "middle":
      return `M${-w5 / 2},${-h5 / 2}h${w5}v${h5}h${-w5}z`;
    case "top-left":
      return `M0,0l${m5},${m5}h${w5 - m5}v${h5}h${-w5}z`;
    case "top":
      return `M0,0l${m5 / 2},${m5 / 2}h${(w5 - m5) / 2}v${h5}h${-w5}v${-h5}h${(w5 - m5) / 2}z`;
    case "top-right":
      return `M0,0l${-m5},${m5}h${m5 - w5}v${h5}h${w5}z`;
    case "right":
      return `M0,0l${-m5 / 2},${-m5 / 2}v${m5 / 2 - h5 / 2}h${-w5}v${h5}h${w5}v${m5 / 2 - h5 / 2}z`;
    case "bottom-left":
      return `M0,0l${m5},${-m5}h${w5 - m5}v${-h5}h${-w5}z`;
    case "bottom":
      return `M0,0l${m5 / 2},${-m5 / 2}h${(w5 - m5) / 2}v${-h5}h${-w5}v${h5}h${(w5 - m5) / 2}z`;
    case "bottom-right":
      return `M0,0l${-m5},${-m5}h${m5 - w5}v${-h5}h${w5}z`;
    case "left":
      return `M0,0l${m5 / 2},${-m5 / 2}v${m5 / 2 - h5 / 2}h${w5}v${h5}h${-w5}v${m5 / 2 - h5 / 2}z`;
  }
}
function getSources({ channels }) {
  const sources = {};
  for (const key in channels) {
    if (ignoreChannels.has(key))
      continue;
    const source = getSource(channels, key);
    if (source)
      sources[key] = source;
  }
  return sources;
}
function formatPair(c12, c23, i6) {
  return c23.hint?.length ? `${formatDefault(c23.value[i6] - c12.value[i6])}` : `${formatDefault(c12.value[i6])}\u2013${formatDefault(c23.value[i6])}`;
}
function formatLabel(scales, c9, defaultLabel) {
  return String(scales[c9.scale]?.label ?? c9?.label ?? defaultLabel);
}

// node_modules/@observablehq/plot/src/plot.js
function plot(options = {}) {
  const { facet, style, caption, ariaLabel, ariaDescription } = options;
  const className = maybeClassName(options.className);
  const marks2 = options.marks === void 0 ? [] : flatMarks(options.marks);
  marks2.push(...inferTips(marks2));
  const topFacetState = maybeTopFacet(facet, options);
  const facetStateByMark = /* @__PURE__ */ new Map();
  for (const mark of marks2) {
    const facetState = maybeMarkFacet(mark, topFacetState, options);
    if (facetState)
      facetStateByMark.set(mark, facetState);
  }
  const channelsByScale = /* @__PURE__ */ new Map();
  if (topFacetState)
    addScaleChannels(channelsByScale, [topFacetState], options);
  addScaleChannels(channelsByScale, facetStateByMark, options);
  const axes = flatMarks(inferAxes(marks2, channelsByScale, options));
  for (const mark of axes) {
    const facetState = maybeMarkFacet(mark, topFacetState, options);
    if (facetState)
      facetStateByMark.set(mark, facetState);
  }
  marks2.unshift(...axes);
  let facets = createFacets(channelsByScale, options);
  if (facets !== void 0) {
    const topFacetsIndex = topFacetState ? facetFilter(facets, topFacetState) : void 0;
    for (const mark of marks2) {
      if (mark.facet === null || mark.facet === "super")
        continue;
      const facetState = facetStateByMark.get(mark);
      if (facetState === void 0)
        continue;
      facetState.facetsIndex = mark.fx != null || mark.fy != null ? facetFilter(facets, facetState) : topFacetsIndex;
    }
    const nonEmpty = /* @__PURE__ */ new Set();
    for (const { facetsIndex } of facetStateByMark.values()) {
      facetsIndex?.forEach((index2, i6) => {
        if (index2?.length > 0) {
          nonEmpty.add(i6);
        }
      });
    }
    facets.forEach(
      0 < nonEmpty.size && nonEmpty.size < facets.length ? (f4, i6) => f4.empty = !nonEmpty.has(i6) : (f4) => f4.empty = false
    );
    for (const mark of marks2) {
      if (mark.facet === "exclude") {
        const facetState = facetStateByMark.get(mark);
        if (facetState !== void 0)
          facetState.facetsIndex = facetExclude(facetState.facetsIndex);
      }
    }
  }
  for (const key of registry.keys()) {
    if (isScaleOptions(options[key]) && key !== "fx" && key !== "fy") {
      channelsByScale.set(key, []);
    }
  }
  const stateByMark = /* @__PURE__ */ new Map();
  for (const mark of marks2) {
    if (stateByMark.has(mark))
      throw new Error("duplicate mark; each mark must be unique");
    const { facetsIndex, channels: facetChannels } = facetStateByMark.get(mark) ?? {};
    const { data, facets: facets2, channels } = mark.initialize(facetsIndex, facetChannels, options);
    applyScaleTransforms(channels, options);
    stateByMark.set(mark, { data, facets: facets2, channels });
  }
  const scaleDescriptors = createScales(addScaleChannels(channelsByScale, stateByMark, options), options);
  const scales = createScaleFunctions(scaleDescriptors);
  const dimensions = createDimensions(scaleDescriptors, marks2, options);
  autoScaleRange(scaleDescriptors, dimensions);
  const { fx, fy } = scales;
  const subdimensions = fx || fy ? innerDimensions(scaleDescriptors, dimensions) : dimensions;
  const superdimensions = fx || fy ? actualDimensions(scales, dimensions) : dimensions;
  const context = createContext(options);
  const document2 = context.document;
  const svg = creator_default("svg").call(document2.documentElement);
  let figure = svg;
  context.ownerSVGElement = svg;
  context.className = className;
  context.projection = createProjection(options, subdimensions);
  context.filterFacets = (data, channels) => {
    return facetFilter(facets, { channels, groups: facetGroups(data, channels) });
  };
  context.getMarkState = (mark) => {
    const state = stateByMark.get(mark);
    const facetState = facetStateByMark.get(mark);
    return { ...state, channels: { ...state.channels, ...facetState?.channels } };
  };
  context.dispatchValue = (value) => {
    if (figure.value === value)
      return;
    figure.value = value;
    figure.dispatchEvent(new Event("input", { bubbles: true }));
  };
  const newByScale = /* @__PURE__ */ new Set();
  for (const [mark, state] of stateByMark) {
    if (mark.initializer != null) {
      const dimensions2 = mark.facet === "super" ? superdimensions : subdimensions;
      const update = mark.initializer(state.data, state.facets, state.channels, scales, dimensions2, context);
      if (update.data !== void 0) {
        state.data = update.data;
      }
      if (update.facets !== void 0) {
        state.facets = update.facets;
      }
      if (update.channels !== void 0) {
        const { fx: fx2, fy: fy2, ...channels } = update.channels;
        inferChannelScales(channels);
        Object.assign(state.channels, channels);
        for (const channel of Object.values(channels)) {
          const { scale: scale2 } = channel;
          if (scale2 != null && registry.get(scale2) !== position) {
            applyScaleTransform(channel, options);
            newByScale.add(scale2);
          }
        }
        if (fx2 != null || fy2 != null)
          facetStateByMark.set(mark, true);
      }
    }
  }
  if (newByScale.size) {
    const newChannelsByScale = /* @__PURE__ */ new Map();
    addScaleChannels(newChannelsByScale, stateByMark, options, (key) => newByScale.has(key));
    addScaleChannels(channelsByScale, stateByMark, options, (key) => newByScale.has(key));
    const newScaleDescriptors = inheritScaleLabels(createScales(newChannelsByScale, options), scaleDescriptors);
    const newScales = createScaleFunctions(newScaleDescriptors);
    Object.assign(scaleDescriptors, newScaleDescriptors);
    Object.assign(scales, newScales);
  }
  let facetDomains, facetTranslate;
  if (facets !== void 0) {
    facetDomains = { x: fx?.domain(), y: fy?.domain() };
    facets = recreateFacets(facets, facetDomains);
    facetTranslate = facetTranslator(fx, fy, dimensions);
  }
  for (const [mark, state] of stateByMark) {
    state.values = mark.scale(state.channels, scales, context);
  }
  const { width, height } = dimensions;
  select_default2(svg).attr("class", className).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).attr("aria-label", ariaLabel).attr("aria-description", ariaDescription).call(
    (svg2) => (
      // Warning: if you edit this, change defaultClassName.
      svg2.append("style").text(
        `.${className} {
  display: block;
  background: white;
  height: auto;
  height: intrinsic;
  max-width: 100%;
}
.${className} text,
.${className} tspan {
  white-space: pre;
}`
      )
    )
  ).call(applyInlineStyles, style);
  for (const mark of marks2) {
    const { channels, values: values2, facets: indexes2 } = stateByMark.get(mark);
    if (facets === void 0 || mark.facet === "super") {
      let index2 = null;
      if (indexes2) {
        index2 = indexes2[0];
        index2 = mark.filter(index2, channels, values2);
        if (index2.length === 0)
          continue;
      }
      const node = mark.render(index2, scales, values2, superdimensions, context);
      if (node == null)
        continue;
      svg.appendChild(node);
    } else {
      let g6;
      for (const f4 of facets) {
        if (!(mark.facetAnchor?.(facets, facetDomains, f4) ?? !f4.empty))
          continue;
        let index2 = null;
        if (indexes2) {
          const faceted = facetStateByMark.has(mark);
          index2 = indexes2[faceted ? f4.i : 0];
          index2 = mark.filter(index2, channels, values2);
          if (index2.length === 0)
            continue;
          if (!faceted && index2 === indexes2[0])
            index2 = subarray(index2);
          index2.fx = f4.x, index2.fy = f4.y, index2.fi = f4.i;
        }
        const node = mark.render(index2, scales, values2, subdimensions, context);
        if (node == null)
          continue;
        (g6 ??= select_default2(svg).append("g")).append(() => node).datum(f4);
        for (const name of ["aria-label", "aria-description", "aria-hidden", "transform"]) {
          if (node.hasAttribute(name)) {
            g6.attr(name, node.getAttribute(name));
            node.removeAttribute(name);
          }
        }
      }
      g6?.selectChildren().attr("transform", facetTranslate);
    }
  }
  const legends = createLegends(scaleDescriptors, context, options);
  if (caption != null || legends.length > 0) {
    figure = document2.createElement("figure");
    figure.style.maxWidth = "initial";
    for (const legend of legends)
      figure.appendChild(legend);
    figure.appendChild(svg);
    if (caption != null) {
      const figcaption = document2.createElement("figcaption");
      figcaption.appendChild(caption?.ownerDocument ? caption : document2.createTextNode(caption));
      figure.appendChild(figcaption);
    }
  }
  figure.scale = exposeScales(scaleDescriptors);
  figure.legend = exposeLegends(scaleDescriptors, context, options);
  const w5 = consumeWarnings();
  if (w5 > 0) {
    select_default2(svg).append("text").attr("x", width).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("\u26A0\uFE0F").append("title").text(`${w5.toLocaleString("en-US")} warning${w5 === 1 ? "" : "s"}. Please check the console.`);
  }
  return figure;
}
function plotThis({ marks: marks2 = [], ...options } = {}) {
  return plot({ ...options, marks: [...marks2, this] });
}
Mark.prototype.plot = plotThis;
function flatMarks(marks2) {
  return marks2.flat(Infinity).filter((mark) => mark != null).map(markify);
}
function markify(mark) {
  return typeof mark.render === "function" ? mark : new Render(mark);
}
var Render = class extends Mark {
  constructor(render3) {
    if (typeof render3 !== "function")
      throw new TypeError("invalid mark; missing render function");
    super();
    this.render = render3;
  }
  render() {
  }
};
function applyScaleTransforms(channels, options) {
  for (const name in channels)
    applyScaleTransform(channels[name], options);
  return channels;
}
function applyScaleTransform(channel, options) {
  const { scale: scale2, transform: t6 = true } = channel;
  if (scale2 == null || !t6)
    return;
  const {
    type: type3,
    percent,
    interval: interval2,
    transform: transform2 = percent ? (x6) => x6 * 100 : maybeIntervalTransform(interval2, type3)
  } = options[scale2] ?? {};
  if (transform2 == null)
    return;
  channel.value = map3(channel.value, transform2);
  channel.transform = false;
}
function inferChannelScales(channels) {
  for (const name in channels) {
    inferChannelScale(name, channels[name]);
  }
}
function addScaleChannels(channelsByScale, stateByMark, options, filter2 = yes) {
  for (const { channels } of stateByMark.values()) {
    for (const name in channels) {
      const channel = channels[name];
      const { scale: scale2 } = channel;
      if (scale2 != null && filter2(scale2)) {
        if (scale2 === "projection") {
          if (!hasProjection(options)) {
            const gx = options.x?.domain === void 0;
            const gy = options.y?.domain === void 0;
            if (gx || gy) {
              const [x6, y5] = getGeometryChannels(channel);
              if (gx)
                addScaleChannel(channelsByScale, "x", x6);
              if (gy)
                addScaleChannel(channelsByScale, "y", y5);
            }
          }
        } else {
          addScaleChannel(channelsByScale, scale2, channel);
        }
      }
    }
  }
  return channelsByScale;
}
function addScaleChannel(channelsByScale, scale2, channel) {
  const scaleChannels = channelsByScale.get(scale2);
  if (scaleChannels !== void 0)
    scaleChannels.push(channel);
  else
    channelsByScale.set(scale2, [channel]);
}
function maybeTopFacet(facet, options) {
  if (facet == null)
    return;
  const { x: x6, y: y5 } = facet;
  if (x6 == null && y5 == null)
    return;
  const data = arrayify2(facet.data);
  if (data == null)
    throw new Error("missing facet data");
  const channels = {};
  if (x6 != null)
    channels.fx = createChannel(data, { value: x6, scale: "fx" });
  if (y5 != null)
    channels.fy = createChannel(data, { value: y5, scale: "fy" });
  applyScaleTransforms(channels, options);
  const groups2 = facetGroups(data, channels);
  return { channels, groups: groups2, data: facet.data };
}
function maybeMarkFacet(mark, topFacetState, options) {
  if (mark.facet === null || mark.facet === "super")
    return;
  const { fx, fy } = mark;
  if (fx != null || fy != null) {
    const data2 = arrayify2(mark.data ?? fx ?? fy);
    if (data2 === void 0)
      throw new Error(`missing facet data in ${mark.ariaLabel}`);
    if (data2 === null)
      return;
    const channels2 = {};
    if (fx != null)
      channels2.fx = createChannel(data2, { value: fx, scale: "fx" });
    if (fy != null)
      channels2.fy = createChannel(data2, { value: fy, scale: "fy" });
    applyScaleTransforms(channels2, options);
    return { channels: channels2, groups: facetGroups(data2, channels2) };
  }
  if (topFacetState === void 0)
    return;
  const { channels, groups: groups2, data } = topFacetState;
  if (mark.facet !== "auto" || mark.data === data)
    return { channels, groups: groups2 };
  if (data.length > 0 && (groups2.size > 1 || groups2.size === 1 && channels.fx && channels.fy && [...groups2][0][1].size > 1) && arrayify2(mark.data)?.length === data.length) {
    warn(
      `Warning: the ${mark.ariaLabel} mark appears to use faceted data, but isn\u2019t faceted. The mark data has the same length as the facet data and the mark facet option is "auto", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`
    );
  }
}
function derive(mark, options = {}) {
  return initializer({ ...options, x: null, y: null }, (data, facets, channels, scales, dimensions, context) => {
    return context.getMarkState(mark);
  });
}
function inferTips(marks2) {
  const tips = [];
  for (const mark of marks2) {
    const t6 = mark.tip;
    if (t6) {
      const p5 = t6 === "x" ? pointerX : t6 === "y" ? pointerY : pointer;
      const options = p5(derive(mark));
      options.title = null;
      tips.push(tip(mark.data, options));
    }
  }
  return tips;
}
function inferAxes(marks2, channelsByScale, options) {
  let {
    projection: projection3,
    x: x6 = {},
    y: y5 = {},
    fx = {},
    fy = {},
    axis: axis2,
    grid,
    facet = {},
    facet: { axis: facetAxis = axis2, grid: facetGrid } = facet,
    x: { axis: xAxis = axis2, grid: xGrid = xAxis === null ? null : grid } = x6,
    y: { axis: yAxis = axis2, grid: yGrid = yAxis === null ? null : grid } = y5,
    fx: { axis: fxAxis = facetAxis, grid: fxGrid = fxAxis === null ? null : facetGrid } = fx,
    fy: { axis: fyAxis = facetAxis, grid: fyGrid = fyAxis === null ? null : facetGrid } = fy
  } = options;
  if (projection3 || !isScaleOptions(x6) && !hasPositionChannel("x", marks2))
    xAxis = xGrid = null;
  if (projection3 || !isScaleOptions(y5) && !hasPositionChannel("y", marks2))
    yAxis = yGrid = null;
  if (!channelsByScale.has("fx"))
    fxAxis = fxGrid = null;
  if (!channelsByScale.has("fy"))
    fyAxis = fyGrid = null;
  if (xAxis === void 0)
    xAxis = !hasAxis(marks2, "x");
  if (yAxis === void 0)
    yAxis = !hasAxis(marks2, "y");
  if (fxAxis === void 0)
    fxAxis = !hasAxis(marks2, "fx");
  if (fyAxis === void 0)
    fyAxis = !hasAxis(marks2, "fy");
  if (xAxis === true)
    xAxis = "bottom";
  if (yAxis === true)
    yAxis = "left";
  if (fxAxis === true)
    fxAxis = xAxis === "top" || xAxis === null ? "bottom" : "top";
  if (fyAxis === true)
    fyAxis = yAxis === "right" || yAxis === null ? "left" : "right";
  const axes = [];
  maybeGrid(axes, fyGrid, gridFy, fy);
  maybeAxis(axes, fyAxis, axisFy, "right", "left", facet, fy);
  maybeGrid(axes, fxGrid, gridFx, fx);
  maybeAxis(axes, fxAxis, axisFx, "top", "bottom", facet, fx);
  maybeGrid(axes, yGrid, gridY, y5);
  maybeAxis(axes, yAxis, axisY, "left", "right", options, y5);
  maybeGrid(axes, xGrid, gridX, x6);
  maybeAxis(axes, xAxis, axisX, "bottom", "top", options, x6);
  return axes;
}
function maybeAxis(axes, axis2, axisType, primary, secondary, defaults8, options) {
  if (!axis2)
    return;
  const both = isBoth(axis2);
  options = axisOptions(both ? primary : axis2, defaults8, options);
  const { line } = options;
  if ((axisType === axisY || axisType === axisX) && line && !isNone(line))
    axes.push(frame2(lineOptions(options)));
  axes.push(axisType(options));
  if (both)
    axes.push(axisType({ ...options, anchor: secondary, label: null }));
}
function maybeGrid(axes, grid, gridType, options) {
  if (!grid || isNone(grid))
    return;
  axes.push(gridType(gridOptions(grid, options)));
}
function isBoth(value) {
  return /^\s*both\s*$/i.test(value);
}
function axisOptions(anchor, defaults8, {
  line = defaults8.line,
  ticks: ticks2,
  tickSize,
  tickSpacing,
  tickPadding,
  tickFormat: tickFormat2,
  tickRotate,
  fontVariant,
  ariaLabel,
  ariaDescription,
  label = defaults8.label,
  labelAnchor,
  labelArrow = defaults8.labelArrow,
  labelOffset
}) {
  return {
    anchor,
    line,
    ticks: ticks2,
    tickSize,
    tickSpacing,
    tickPadding,
    tickFormat: tickFormat2,
    tickRotate,
    fontVariant,
    ariaLabel,
    ariaDescription,
    label,
    labelAnchor,
    labelArrow,
    labelOffset
  };
}
function lineOptions(options) {
  const { anchor, line } = options;
  return { anchor, facetAnchor: anchor + "-empty", stroke: line === true ? void 0 : line };
}
function gridOptions(grid, {
  stroke = isColor(grid) ? grid : void 0,
  ticks: ticks2 = isGridTicks(grid) ? grid : void 0,
  tickSpacing,
  ariaLabel,
  ariaDescription
}) {
  return {
    stroke,
    ticks: ticks2,
    tickSpacing,
    ariaLabel,
    ariaDescription
  };
}
function isGridTicks(grid) {
  switch (typeof grid) {
    case "number":
      return true;
    case "string":
      return !isColor(grid);
  }
  return isIterable(grid) || typeof grid?.range === "function";
}
function hasAxis(marks2, k6) {
  const prefix = `${k6}-axis `;
  return marks2.some((m5) => m5.ariaLabel?.startsWith(prefix));
}
function hasPositionChannel(k6, marks2) {
  for (const mark of marks2) {
    for (const key in mark.channels) {
      const { scale: scale2 } = mark.channels[key];
      if (scale2 === k6 || scale2 === "projection") {
        return true;
      }
    }
  }
  return false;
}
function inheritScaleLabels(newScales, scales) {
  for (const key in newScales) {
    const newScale = newScales[key];
    const scale2 = scales[key];
    if (newScale.label === void 0 && scale2) {
      newScale.label = scale2.label;
    }
  }
  return newScales;
}
function actualDimensions({ fx, fy }, dimensions) {
  const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);
  const fxr = fx && outerRange(fx);
  const fyr = fy && outerRange(fy);
  return {
    marginTop: fy ? fyr[0] : marginTop,
    marginRight: fx ? width - fxr[1] : marginRight,
    marginBottom: fy ? height - fyr[1] : marginBottom,
    marginLeft: fx ? fxr[0] : marginLeft,
    // Some marks, namely the x- and y-axis labels, want to know what the
    // desired (rather than actual) margins are for positioning.
    inset: {
      marginTop: dimensions.marginTop,
      marginRight: dimensions.marginRight,
      marginBottom: dimensions.marginBottom,
      marginLeft: dimensions.marginLeft
    },
    width,
    height
  };
}
function outerRange(scale2) {
  const domain = scale2.domain();
  let x12 = scale2(domain[0]);
  let x22 = scale2(domain[domain.length - 1]);
  if (x22 < x12)
    [x12, x22] = [x22, x12];
  return [x12, x22 + scale2.bandwidth()];
}

// node_modules/@observablehq/plot/src/curve.js
var curves = /* @__PURE__ */ new Map([
  ["basis", basis_default2],
  ["basis-closed", basisClosed_default2],
  ["basis-open", basisOpen_default],
  ["bundle", bundle_default],
  ["bump-x", bumpX],
  ["bump-y", bumpY],
  ["cardinal", cardinal_default],
  ["cardinal-closed", cardinalClosed_default],
  ["cardinal-open", cardinalOpen_default],
  ["catmull-rom", catmullRom_default],
  ["catmull-rom-closed", catmullRomClosed_default],
  ["catmull-rom-open", catmullRomOpen_default],
  ["linear", linear_default],
  ["linear-closed", linearClosed_default],
  ["monotone-x", monotoneX],
  ["monotone-y", monotoneY],
  ["natural", natural_default],
  ["step", step_default],
  ["step-after", stepAfter],
  ["step-before", stepBefore]
]);
function maybeCurve(curve = linear_default, tension) {
  if (typeof curve === "function")
    return curve;
  const c9 = curves.get(`${curve}`.toLowerCase());
  if (!c9)
    throw new Error(`unknown curve: ${curve}`);
  if (tension !== void 0) {
    if ("beta" in c9) {
      return c9.beta(tension);
    } else if ("tension" in c9) {
      return c9.tension(tension);
    } else if ("alpha" in c9) {
      return c9.alpha(tension);
    }
  }
  return c9;
}

// node_modules/@observablehq/plot/src/transforms/bin.js
function binX(outputs = { y: "count" }, options = {}) {
  [outputs, options] = mergeOptions(outputs, options);
  const { x: x6, y: y5 } = options;
  return binn(maybeBinValue(x6, options, identity7), null, null, y5, outputs, maybeInsetX(options));
}
function maybeDenseInterval(bin, k6, options = {}) {
  return options?.interval == null ? options : bin({ [k6]: options?.reduce === void 0 ? reduceFirst : options.reduce, filter: null }, options);
}
function maybeDenseIntervalX(options = {}) {
  return maybeDenseInterval(binX, "y", withTip(options, "x"));
}
function binn(bx, by, gx, gy, {
  data: reduceData = reduceIdentity,
  // TODO avoid materializing when unused?
  filter: filter2 = reduceCount,
  // return only non-empty bins by default
  sort: sort2,
  reverse: reverse2,
  ...outputs
  // output channel definitions
} = {}, inputs = {}) {
  bx = maybeBin(bx);
  by = maybeBin(by);
  outputs = maybeBinOutputs(outputs, inputs);
  reduceData = maybeBinReduce(reduceData, identity7);
  sort2 = sort2 == null ? void 0 : maybeBinOutput("sort", sort2, inputs);
  filter2 = filter2 == null ? void 0 : maybeBinEvaluator("filter", filter2, inputs);
  if (gx != null && hasOutput(outputs, "x", "x1", "x2"))
    gx = null;
  if (gy != null && hasOutput(outputs, "y", "y1", "y2"))
    gy = null;
  const [BX1, setBX1] = maybeColumn(bx);
  const [BX2, setBX2] = maybeColumn(bx);
  const [BY1, setBY1] = maybeColumn(by);
  const [BY2, setBY2] = maybeColumn(by);
  const [k6, gk] = gx != null ? [gx, "x"] : gy != null ? [gy, "y"] : [];
  const [GK, setGK] = maybeColumn(k6);
  const {
    x: x6,
    y: y5,
    z: z5,
    fill,
    stroke,
    x1: x12,
    x2: x22,
    // consumed if x is an output
    y1: y12,
    y2: y22,
    // consumed if y is an output
    domain,
    cumulative,
    thresholds,
    interval: interval2,
    ...options
  } = inputs;
  const [GZ, setGZ] = maybeColumn(z5);
  const [vfill] = maybeColorChannel(fill);
  const [vstroke] = maybeColorChannel(stroke);
  const [GF, setGF] = maybeColumn(vfill);
  const [GS, setGS] = maybeColumn(vstroke);
  return {
    ..."z" in inputs && { z: GZ || z5 },
    ..."fill" in inputs && { fill: GF || fill },
    ..."stroke" in inputs && { stroke: GS || stroke },
    ...basic(options, (data, facets, plotOptions) => {
      const K3 = maybeApplyInterval(valueof(data, k6), plotOptions?.[gk]);
      const Z3 = valueof(data, z5);
      const F4 = valueof(data, vfill);
      const S4 = valueof(data, vstroke);
      const G3 = maybeSubgroup(outputs, { z: Z3, fill: F4, stroke: S4 });
      const groupFacets = [];
      const groupData = [];
      const GK2 = K3 && setGK([]);
      const GZ2 = Z3 && setGZ([]);
      const GF2 = F4 && setGF([]);
      const GS2 = S4 && setGS([]);
      const BX12 = bx && setBX1([]);
      const BX22 = bx && setBX2([]);
      const BY12 = by && setBY1([]);
      const BY22 = by && setBY2([]);
      const bin = bing(bx?.(data), by?.(data));
      let i6 = 0;
      for (const o8 of outputs)
        o8.initialize(data);
      if (sort2)
        sort2.initialize(data);
      if (filter2)
        filter2.initialize(data);
      for (const facet of facets) {
        const groupFacet = [];
        for (const o8 of outputs)
          o8.scope("facet", facet);
        if (sort2)
          sort2.scope("facet", facet);
        if (filter2)
          filter2.scope("facet", facet);
        for (const [f4, I4] of maybeGroup(facet, G3)) {
          for (const [k7, g6] of maybeGroup(I4, K3)) {
            for (const [b5, extent3] of bin(g6)) {
              if (filter2 && !filter2.reduce(b5, extent3))
                continue;
              groupFacet.push(i6++);
              groupData.push(reduceData.reduceIndex(b5, data, extent3));
              if (K3)
                GK2.push(k7);
              if (Z3)
                GZ2.push(G3 === Z3 ? f4 : Z3[b5[0]]);
              if (F4)
                GF2.push(G3 === F4 ? f4 : F4[b5[0]]);
              if (S4)
                GS2.push(G3 === S4 ? f4 : S4[b5[0]]);
              if (BX12)
                BX12.push(extent3.x1), BX22.push(extent3.x2);
              if (BY12)
                BY12.push(extent3.y1), BY22.push(extent3.y2);
              for (const o8 of outputs)
                o8.reduce(b5, extent3);
              if (sort2)
                sort2.reduce(b5);
            }
          }
        }
        groupFacets.push(groupFacet);
      }
      maybeSort(groupFacets, sort2, reverse2);
      return { data: groupData, facets: groupFacets };
    }),
    ...!hasOutput(outputs, "x") && (BX1 ? { x1: BX1, x2: BX2, x: mid(BX1, BX2) } : { x: x6, x1: x12, x2: x22 }),
    ...!hasOutput(outputs, "y") && (BY1 ? { y1: BY1, y2: BY2, y: mid(BY1, BY2) } : { y: y5, y1: y12, y2: y22 }),
    ...GK && { [gk]: GK },
    ...Object.fromEntries(outputs.map(({ name, output }) => [name, output]))
  };
}
function mergeOptions({ cumulative, domain, thresholds, interval: interval2, ...outputs }, options) {
  return [outputs, { cumulative, domain, thresholds, interval: interval2, ...options }];
}
function maybeBinValue(value, { cumulative, domain, thresholds, interval: interval2 }, defaultValue) {
  value = { ...maybeValue(value) };
  if (value.domain === void 0)
    value.domain = domain;
  if (value.cumulative === void 0)
    value.cumulative = cumulative;
  if (value.thresholds === void 0)
    value.thresholds = thresholds;
  if (value.interval === void 0)
    value.interval = interval2;
  if (value.value === void 0)
    value.value = defaultValue;
  value.thresholds = maybeThresholds(value.thresholds, value.interval);
  return value;
}
function maybeBin(options) {
  if (options == null)
    return;
  const { value, cumulative, domain = extent, thresholds } = options;
  const bin = (data) => {
    let V4 = valueof(data, value);
    let T5;
    if (isTemporal(V4) || isTimeThresholds(thresholds)) {
      V4 = map3(V4, coerceDate, Float64Array);
      let [min4, max4] = typeof domain === "function" ? domain(V4) : domain;
      let t6 = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V4, min4, max4) : thresholds;
      if (typeof t6 === "number")
        t6 = utcTickInterval(min4, max4, t6);
      if (isInterval(t6)) {
        if (domain === extent) {
          min4 = t6.floor(min4);
          max4 = t6.offset(t6.floor(max4));
        }
        t6 = t6.range(min4, t6.offset(max4));
      }
      T5 = t6;
    } else {
      V4 = coerceNumbers(V4);
      let [min4, max4] = typeof domain === "function" ? domain(V4) : domain;
      let t6 = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V4, min4, max4) : thresholds;
      if (typeof t6 === "number") {
        if (domain === extent) {
          let step = tickIncrement(min4, max4, t6);
          if (isFinite(step)) {
            if (step > 0) {
              let r0 = Math.round(min4 / step);
              let r1 = Math.round(max4 / step);
              if (!(r0 * step <= min4))
                --r0;
              if (!(r1 * step > max4))
                ++r1;
              let n9 = r1 - r0 + 1;
              t6 = new Float64Array(n9);
              for (let i6 = 0; i6 < n9; ++i6)
                t6[i6] = (r0 + i6) * step;
            } else if (step < 0) {
              step = -step;
              let r0 = Math.round(min4 * step);
              let r1 = Math.round(max4 * step);
              if (!(r0 / step <= min4))
                --r0;
              if (!(r1 / step > max4))
                ++r1;
              let n9 = r1 - r0 + 1;
              t6 = new Float64Array(n9);
              for (let i6 = 0; i6 < n9; ++i6)
                t6[i6] = (r0 + i6) / step;
            } else {
              t6 = [min4];
            }
          } else {
            t6 = [min4];
          }
        } else {
          t6 = ticks(min4, max4, t6);
        }
      } else if (isInterval(t6)) {
        if (domain === extent) {
          min4 = t6.floor(min4);
          max4 = t6.offset(t6.floor(max4));
        }
        t6 = t6.range(min4, t6.offset(max4));
      }
      T5 = t6;
    }
    const E5 = [];
    if (T5.length === 1)
      E5.push([T5[0], T5[0]]);
    else
      for (let i6 = 1; i6 < T5.length; ++i6)
        E5.push([T5[i6 - 1], T5[i6]]);
    E5.bin = (cumulative < 0 ? bin1cn : cumulative > 0 ? bin1cp : bin1)(E5, T5, V4);
    return E5;
  };
  bin.label = labelof(value);
  return bin;
}
function maybeThresholds(thresholds, interval2, defaultThresholds = thresholdAuto) {
  if (thresholds === void 0) {
    return interval2 === void 0 ? defaultThresholds : maybeRangeInterval(interval2);
  }
  if (typeof thresholds === "string") {
    switch (thresholds.toLowerCase()) {
      case "freedman-diaconis":
        return thresholdFreedmanDiaconis;
      case "scott":
        return thresholdScott;
      case "sturges":
        return thresholdSturges;
      case "auto":
        return thresholdAuto;
    }
    return maybeUtcInterval(thresholds);
  }
  return thresholds;
}
function maybeBinOutputs(outputs, inputs) {
  return maybeOutputs(outputs, inputs, maybeBinOutput);
}
function maybeBinOutput(name, reduce, inputs) {
  return maybeOutput(name, reduce, inputs, maybeBinEvaluator);
}
function maybeBinEvaluator(name, reduce, inputs) {
  return maybeEvaluator(name, reduce, inputs, maybeBinReduce);
}
function maybeBinReduce(reduce, value) {
  return maybeReduce(reduce, value, maybeBinReduceFallback);
}
function maybeBinReduceFallback(reduce) {
  switch (`${reduce}`.toLowerCase()) {
    case "x":
      return reduceX;
    case "x1":
      return reduceX1;
    case "x2":
      return reduceX2;
    case "y":
      return reduceY;
    case "y1":
      return reduceY1;
    case "y2":
      return reduceY2;
  }
  throw new Error(`invalid bin reduce: ${reduce}`);
}
function thresholdAuto(values2, min4, max4) {
  return Math.min(200, thresholdScott(values2, min4, max4));
}
function isTimeThresholds(t6) {
  return isTimeInterval(t6) || isIterable(t6) && isTemporal(t6);
}
function isTimeInterval(t6) {
  return isInterval(t6) && typeof t6 === "function" && t6() instanceof Date;
}
function isInterval(t6) {
  return typeof t6?.range === "function";
}
function bing(EX, EY) {
  return EX && EY ? function* (I4) {
    const X3 = EX.bin(I4);
    for (const [ix, [x12, x22]] of EX.entries()) {
      const Y3 = EY.bin(X3[ix]);
      for (const [iy, [y12, y22]] of EY.entries()) {
        yield [Y3[iy], { x1: x12, y1: y12, x2: x22, y2: y22 }];
      }
    }
  } : EX ? function* (I4) {
    const X3 = EX.bin(I4);
    for (const [i6, [x12, x22]] of EX.entries()) {
      yield [X3[i6], { x1: x12, x2: x22 }];
    }
  } : function* (I4) {
    const Y3 = EY.bin(I4);
    for (const [i6, [y12, y22]] of EY.entries()) {
      yield [Y3[i6], { y1: y12, y2: y22 }];
    }
  };
}
function bin1(E5, T5, V4) {
  T5 = coerceNumbers(T5);
  return (I4) => {
    const B6 = E5.map(() => []);
    for (const i6 of I4)
      B6[bisect_default(T5, V4[i6]) - 1]?.push(i6);
    return B6;
  };
}
function bin1cp(E5, T5, V4) {
  const bin = bin1(E5, T5, V4);
  return (I4) => {
    const B6 = bin(I4);
    for (let i6 = 1, n9 = B6.length; i6 < n9; ++i6) {
      const C5 = B6[i6 - 1];
      const b5 = B6[i6];
      for (const j5 of C5)
        b5.push(j5);
    }
    return B6;
  };
}
function bin1cn(E5, T5, V4) {
  const bin = bin1(E5, T5, V4);
  return (I4) => {
    const B6 = bin(I4);
    for (let i6 = B6.length - 2; i6 >= 0; --i6) {
      const C5 = B6[i6 + 1];
      const b5 = B6[i6];
      for (const j5 of C5)
        b5.push(j5);
    }
    return B6;
  };
}
function mid1(x12, x22) {
  const m5 = (+x12 + +x22) / 2;
  return x12 instanceof Date ? new Date(m5) : m5;
}
var reduceX = {
  reduceIndex(I4, X3, { x1: x12, x2: x22 }) {
    return mid1(x12, x22);
  }
};
var reduceY = {
  reduceIndex(I4, X3, { y1: y12, y2: y22 }) {
    return mid1(y12, y22);
  }
};
var reduceX1 = {
  reduceIndex(I4, X3, { x1: x12 }) {
    return x12;
  }
};
var reduceX2 = {
  reduceIndex(I4, X3, { x2: x22 }) {
    return x22;
  }
};
var reduceY1 = {
  reduceIndex(I4, X3, { y1: y12 }) {
    return y12;
  }
};
var reduceY2 = {
  reduceIndex(I4, X3, { y2: y22 }) {
    return y22;
  }
};

// node_modules/@observablehq/plot/src/transforms/identity.js
function maybeIdentityY(options = {}) {
  return hasY(options) ? options : { ...options, y: identity7 };
}

// node_modules/@observablehq/plot/src/transforms/stack.js
function stackY(stackOptions = {}, options = {}) {
  if (arguments.length === 1)
    [stackOptions, options] = mergeOptions2(stackOptions);
  const { x1: x12, x: x6 = x12, y: y5, ...rest } = options;
  const [transform2, X3, y12, y22] = stack(x6, y5, "x", "y", stackOptions, rest);
  return { ...transform2, x1: x12, x: X3, y1: y12, y2: y22, y: mid(y12, y22) };
}
function maybeStackY({ y: y5, y1: y12, y2: y22, ...options } = {}) {
  options = withTip(options, "x");
  if (y12 === void 0 && y22 === void 0)
    return stackY({ y: y5, ...options });
  [y12, y22] = maybeZero(y5, y12, y22);
  return { ...options, y1: y12, y2: y22 };
}
function mergeOptions2(options) {
  const { offset: offset2, order, reverse: reverse2, ...rest } = options;
  return [{ offset: offset2, order, reverse: reverse2 }, rest];
}
var lengthy = { length: true };
function stack(x6, y5 = one2, kx2, ky2, { offset: offset2, order, reverse: reverse2 }, options) {
  const z5 = maybeZ(options);
  const [X3, setX] = maybeColumn(x6);
  const [Y12, setY1] = column(y5);
  const [Y23, setY2] = column(y5);
  Y12.hint = Y23.hint = lengthy;
  offset2 = maybeOffset(offset2);
  order = maybeOrder2(order, offset2, ky2);
  return [
    basic(options, (data, facets, plotOptions) => {
      const X4 = x6 == null ? void 0 : setX(maybeApplyInterval(valueof(data, x6), plotOptions?.[kx2]));
      const Y3 = valueof(data, y5, Float64Array);
      const Z3 = valueof(data, z5);
      const compare = order && order(data, X4, Y3, Z3);
      const n9 = data.length;
      const Y13 = setY1(new Float64Array(n9));
      const Y24 = setY2(new Float64Array(n9));
      const facetstacks = [];
      for (const facet of facets) {
        const stacks = X4 ? Array.from(group(facet, (i6) => X4[i6]).values()) : [facet];
        if (compare)
          for (const stack2 of stacks)
            stack2.sort(compare);
        for (const stack2 of stacks) {
          let yn2 = 0;
          let yp = 0;
          if (reverse2)
            stack2.reverse();
          for (const i6 of stack2) {
            const y6 = Y3[i6];
            if (y6 < 0)
              yn2 = Y24[i6] = (Y13[i6] = yn2) + y6;
            else if (y6 > 0)
              yp = Y24[i6] = (Y13[i6] = yp) + y6;
            else
              Y24[i6] = Y13[i6] = yp;
          }
        }
        facetstacks.push(stacks);
      }
      if (offset2)
        offset2(facetstacks, Y13, Y24, Z3);
      return { data, facets };
    }),
    X3,
    Y12,
    Y23
  ];
}
function maybeOffset(offset2) {
  if (offset2 == null)
    return;
  if (typeof offset2 === "function")
    return offset2;
  switch (`${offset2}`.toLowerCase()) {
    case "expand":
    case "normalize":
      return offsetExpand;
    case "center":
    case "silhouette":
      return offsetCenter;
    case "wiggle":
      return offsetWiggle;
  }
  throw new Error(`unknown offset: ${offset2}`);
}
function extent2(stack2, Y23) {
  let min4 = 0, max4 = 0;
  for (const i6 of stack2) {
    const y5 = Y23[i6];
    if (y5 < min4)
      min4 = y5;
    if (y5 > max4)
      max4 = y5;
  }
  return [min4, max4];
}
function offsetExpand(facetstacks, Y12, Y23) {
  for (const stacks of facetstacks) {
    for (const stack2 of stacks) {
      const [yn2, yp] = extent2(stack2, Y23);
      for (const i6 of stack2) {
        const m5 = 1 / (yp - yn2 || 1);
        Y12[i6] = m5 * (Y12[i6] - yn2);
        Y23[i6] = m5 * (Y23[i6] - yn2);
      }
    }
  }
}
function offsetCenter(facetstacks, Y12, Y23) {
  for (const stacks of facetstacks) {
    for (const stack2 of stacks) {
      const [yn2, yp] = extent2(stack2, Y23);
      for (const i6 of stack2) {
        const m5 = (yp + yn2) / 2;
        Y12[i6] -= m5;
        Y23[i6] -= m5;
      }
    }
    offsetZero(stacks, Y12, Y23);
  }
  offsetCenterFacets(facetstacks, Y12, Y23);
}
function offsetWiggle(facetstacks, Y12, Y23, Z3) {
  for (const stacks of facetstacks) {
    const prev = new InternMap();
    let y5 = 0;
    for (const stack2 of stacks) {
      let j5 = -1;
      const Fi = stack2.map((i6) => Math.abs(Y23[i6] - Y12[i6]));
      const Df = stack2.map((i6) => {
        j5 = Z3 ? Z3[i6] : ++j5;
        const value = Y23[i6] - Y12[i6];
        const diff = prev.has(j5) ? value - prev.get(j5) : 0;
        prev.set(j5, value);
        return diff;
      });
      const Cf1 = [0, ...cumsum(Df)];
      for (const i6 of stack2) {
        Y12[i6] += y5;
        Y23[i6] += y5;
      }
      const s1 = sum(Fi);
      if (s1)
        y5 -= sum(Fi, (d6, i6) => (Df[i6] / 2 + Cf1[i6]) * d6) / s1;
    }
    offsetZero(stacks, Y12, Y23);
  }
  offsetCenterFacets(facetstacks, Y12, Y23);
}
function offsetZero(stacks, Y12, Y23) {
  const m5 = min(stacks, (stack2) => min(stack2, (i6) => Y12[i6]));
  for (const stack2 of stacks) {
    for (const i6 of stack2) {
      Y12[i6] -= m5;
      Y23[i6] -= m5;
    }
  }
}
function offsetCenterFacets(facetstacks, Y12, Y23) {
  const n9 = facetstacks.length;
  if (n9 === 1)
    return;
  const facets = facetstacks.map((stacks) => stacks.flat());
  const m5 = facets.map((I4) => (min(I4, (i6) => Y12[i6]) + max(I4, (i6) => Y23[i6])) / 2);
  const m0 = min(m5);
  for (let j5 = 0; j5 < n9; j5++) {
    const p5 = m0 - m5[j5];
    for (const i6 of facets[j5]) {
      Y12[i6] += p5;
      Y23[i6] += p5;
    }
  }
}
function maybeOrder2(order, offset2, ky2) {
  if (order === void 0 && offset2 === offsetWiggle)
    return orderInsideOut(ascendingDefined2);
  if (order == null)
    return;
  if (typeof order === "string") {
    const negate = order.startsWith("-");
    const compare = negate ? descendingDefined : ascendingDefined2;
    switch ((negate ? order.slice(1) : order).toLowerCase()) {
      case "value":
      case ky2:
        return orderY(compare);
      case "z":
        return orderZ(compare);
      case "sum":
        return orderSum(compare);
      case "appearance":
        return orderAppearance(compare);
      case "inside-out":
        return orderInsideOut(compare);
    }
    return orderAccessor(field(order));
  }
  if (typeof order === "function")
    return (order.length === 1 ? orderAccessor : orderComparator)(order);
  if (Array.isArray(order))
    return orderGiven(order);
  throw new Error(`invalid order: ${order}`);
}
function orderY(compare) {
  return (data, X3, Y3) => (i6, j5) => compare(Y3[i6], Y3[j5]);
}
function orderZ(compare) {
  return (data, X3, Y3, Z3) => (i6, j5) => compare(Z3[i6], Z3[j5]);
}
function orderSum(compare) {
  return orderZDomain(
    compare,
    (data, X3, Y3, Z3) => groupSort(
      range2(data),
      (I4) => sum(I4, (i6) => Y3[i6]),
      (i6) => Z3[i6]
    )
  );
}
function orderAppearance(compare) {
  return orderZDomain(
    compare,
    (data, X3, Y3, Z3) => groupSort(
      range2(data),
      (I4) => X3[greatest(I4, (i6) => Y3[i6])],
      (i6) => Z3[i6]
    )
  );
}
function orderInsideOut(compare) {
  return orderZDomain(compare, (data, X3, Y3, Z3) => {
    const I4 = range2(data);
    const K3 = groupSort(
      I4,
      (I5) => X3[greatest(I5, (i6) => Y3[i6])],
      (i6) => Z3[i6]
    );
    const sums = rollup(
      I4,
      (I5) => sum(I5, (i6) => Y3[i6]),
      (i6) => Z3[i6]
    );
    const Kp = [], Kn = [];
    let s8 = 0;
    for (const k6 of K3) {
      if (s8 < 0) {
        s8 += sums.get(k6);
        Kp.push(k6);
      } else {
        s8 -= sums.get(k6);
        Kn.push(k6);
      }
    }
    return Kn.reverse().concat(Kp);
  });
}
function orderAccessor(f4) {
  return (data) => {
    const O3 = valueof(data, f4);
    return (i6, j5) => ascendingDefined2(O3[i6], O3[j5]);
  };
}
function orderComparator(f4) {
  return (data) => (i6, j5) => f4(data[i6], data[j5]);
}
function orderGiven(domain) {
  return orderZDomain(ascendingDefined2, () => domain);
}
function orderZDomain(compare, domain) {
  return (data, X3, Y3, Z3) => {
    if (!Z3)
      throw new Error("missing channel: z");
    const map4 = new InternMap(domain(data, X3, Y3, Z3).map((d6, i6) => [d6, i6]));
    return (i6, j5) => compare(map4.get(Z3[i6]), map4.get(Z3[j5]));
  };
}

// node_modules/@observablehq/plot/src/marks/area.js
var defaults6 = {
  ariaLabel: "area",
  strokeWidth: 1,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
var Area = class extends Mark {
  constructor(data, options = {}) {
    const { x1: x12, y1: y12, x2: x22, y2: y22, z: z5, curve, tension } = options;
    super(
      data,
      {
        x1: { value: x12, scale: "x" },
        y1: { value: y12, scale: "y" },
        x2: { value: x22, scale: "x", optional: true },
        y2: { value: y22, scale: "y", optional: true },
        z: { value: maybeZ(options), optional: true }
      },
      options,
      defaults6
    );
    this.z = z5;
    this.curve = maybeCurve(curve, tension);
  }
  filter(index2) {
    return index2;
  }
  render(index2, scales, channels, dimensions, context) {
    const { x1: X12, y1: Y12, x2: X23 = X12, y2: Y23 = Y12 } = channels;
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales, 0, 0).call(
      (g6) => g6.selectAll().data(groupIndex(index2, [X12, Y12, X23, Y23], this, channels)).enter().append("path").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).attr(
        "d",
        area_default2().curve(this.curve).defined((i6) => i6 >= 0).x0((i6) => X12[i6]).y0((i6) => Y12[i6]).x1((i6) => X23[i6]).y1((i6) => Y23[i6])
      )
    ).node();
  }
};
function areaY(data, options) {
  const { x: x6 = indexOf, ...rest } = maybeDenseIntervalX(options);
  return new Area(data, maybeStackY(maybeIdentityY({ ...rest, x1: x6, x2: void 0 })));
}

// src/utils/getElementsFromSlotChangeEvent.ts
function getElementsFromSlotChangeEvent(e9) {
  const slot = e9.target;
  if (!slot)
    return [];
  return slot.assignedNodes({ flatten: true }).filter((node) => {
    return node instanceof HTMLElement && !/^\s*$/.test(node.innerHTML);
  });
}

// src/observable_plot.ts
var ObservablePlot = class extends s4 {
  constructor() {
    super(...arguments);
    this.heightPx = null;
    this.widthPx = null;
    this.data = null;
  }
  watchDataSlot(e9) {
    const dataElements = getElementsFromSlotChangeEvent(e9);
    const dataScript = dataElements.find((el) => el.tagName === "SCRIPT");
    if (!dataScript) {
      console.warn("No data script found");
      return;
    }
    const data = JSON.parse(dataScript.textContent || "");
    this.data = data;
  }
  connectedCallback() {
    super.connectedCallback();
  }
  setPlotHeight(e9) {
    console.log("Resize occured", e9);
  }
  updated() {
    const plotDiv = this.shadowRoot?.querySelector("#plot");
    if (plotDiv) {
      this.heightPx = plotDiv.offsetHeight;
      this.widthPx = plotDiv.offsetWidth;
    }
  }
  render() {
    console.log("Rendering observable-plot");
    return x`
      <div class="slots">
        <slot name="data" @slotchange=${this.watchDataSlot}></slot>
        <slot name="spec"></slot>
      </div>
      <div id="plot" @show=${this.setPlotHeight}>
        ${this.data && this.heightPx && this.widthPx && plot({
      y: {
        grid: true,
        label: "\u2191 Annual revenue (billions, adj.)",
        transform: (d6) => d6 / 1e3
        // convert millions to billions
      },
      height: this.heightPx,
      width: this.widthPx,
      color: { legend: true },
      marks: [
        areaY(
          this.data,
          stackY(
            { order: null, reverse: false },
            { x: "year", y: "revenue", z: "format", fill: "group" }
          )
        ),
        ruleY([0])
      ]
    })}
      </div>
    `;
  }
};
ObservablePlot.styles = [
  i`
      * {
        box-sizing: border-box;
      }

      .slots {
        display: none;
      }

      :host {
        display: block;
        height: 100%;
        padding: var(--size-m);
        padding-block-start: calc(2 * var(--size-m));
      }

      #plot {
        height: 100%;
      }

      figure {
        margin: 0;
        position: relative;
      }

      figure > :first-child {
        position: absolute;
        bottom: 100%;
        left: 0;
      }
    `
];
__decorateClass([
  n6({ type: Number })
], ObservablePlot.prototype, "heightPx", 2);
__decorateClass([
  n6({ type: Number })
], ObservablePlot.prototype, "widthPx", 2);
__decorateClass([
  t5()
], ObservablePlot.prototype, "data", 2);
ObservablePlot = __decorateClass([
  e6("observable-plot")
], ObservablePlot);

// src/output_plot.ts
var OutputPlot = class extends s4 {
  connectedCallback() {
    super.connectedCallback();
    if (this.height) {
      this.style.setProperty("--plot-h", `${this.height}px`);
    }
  }
  render() {
    return x`<div class="plot"></div>`;
  }
};
OutputPlot.styles = i`
    * {
      box-sizing: border-box;
      min-width: 0;
    }

    :host {
      display: block;
      height: var(--plot-h, 400px);
      flex: 1 1 auto;
    }

    :host([height]) {
      flex: 0 0 var(--plot-h, 400px);
    }

    .plot {
      background-image: var(--gradient-17);
      height: 100%;
    }
  `;
__decorateClass([
  n6({ reflect: true })
], OutputPlot.prototype, "height", 2);
OutputPlot = __decorateClass([
  e6("output-plot")
], OutputPlot);

// src/posit-logo.ts
var PositLogo = class extends s4 {
  constructor() {
    super(...arguments);
    this.withName = false;
    this.width = 40;
    this.height = 40;
  }
  render() {
    const nameText = this.withName ? x`<path
          class="masked-path"
          d="M87.818 9.225c7.25 0 12.361 4.903 12.361 11.713S95.069 32.61 87.818 32.61c-7.252 0-12.275-4.903-12.275-11.672 0-6.768 5.023-11.713 12.275-11.713Zm0 17.528c3.451 0 5.81-2.17 5.81-5.815 0-3.644-2.62-5.856-5.81-5.856-3.19 0-5.723 2.125-5.723 5.856 0 3.299 2.316 5.815 5.723 5.815ZM128.042 0c2.053 0 3.538 1.46 3.538 3.389 0 2.026-1.485 3.484-3.538 3.484-2.227 0-3.583-1.458-3.583-3.484S125.944 0 128.042 0Zm-3.19 9.65h6.335v22.563h-6.335V9.65ZM134.045 9.65h4.325V4.4h6.334v5.25h6.845v5.857h-6.845v7.332c0 2.733.611 3.775 2.316 3.775 1.485 0 2.665-.52 3.887-1.475l3.227 3.973c-1.574 1.65-4.625 3.359-7.725 3.359-4.761 0-8.037-2.561-8.037-7.767v-9.199h-4.325V9.648l-.002.003ZM155.519 11.998h-.504v-1.942h-.644v-.417h1.791v.417h-.643v1.942ZM157.466 11.998l-.572-1.85h-.014c.021.377.031.629.031.754v1.096h-.45V9.639h.686l.562 1.803h.009l.595-1.803h.686v2.359h-.468V10.88c0-.053 0-.114.002-.181 0-.07.01-.251.021-.55h-.014l-.611 1.848h-.463ZM121.573 12.41c-1.553-1.48-4.773-3.392-9.346-3.392-6.512 0-10.343 2.675-10.343 7.062 0 6.808 10.917 6.973 13.495 8.476.466.258.742.618.576 1.142-.485 1.51-6.603 2.247-11.116-2.087l-3.681 4.36c1.639 2.155 5.255 4.686 11.121 4.686 5.449 0 10.16-2.193 10.16-7.192 0-4.482-4.203-6.285-7.94-7.34-1.064-.291-2.092-.531-2.981-.768-1.473-.375-3.447-.796-3.131-1.889.574-1.986 7.142-.742 9.439 1.347l3.754-4.403-.007-.003ZM50.88 9.704h6.344v1.175c1.18-1.087 3.326-1.652 5.077-1.652 6.913 0 11.203 4.738 11.203 11.432S69.04 32.654 62.125 32.654c-2.187 0-4.2-.346-4.9-1.13V41H50.88V9.704Zm6.344 7.955v7.215c.7 1.042 2.232 1.912 4.026 1.912 3.545 0 5.688-2.217 5.688-5.65 0-3.998-2.012-6.04-5.34-6.04-2.1 0-3.542 1.041-4.374 2.563Z"
          fill="#404041"
        ></path>` : null;
    return x`
      <svg width="1em" height="1em" viewBox="0 0 41 41" fill="none">
        <path
          d="m10.043 24.362 1.855.83 8.577-3.625-1.909-.808-8.523 3.603Z"
          fill="#447099"
        ></path>
        <path
          d="m12.034 16.384-1.874.821 8.404 3.555 1.909-.808-8.44-3.568Z"
          fill="#447099"
        ></path>
        <path
          d="m32.67 16.41-1.873-.824-8.474-3.719-1.85-.812L0 2.074v10.836l8.278 3.5 1.873-.822-8.657-3.66V4.353l17.13 7.515 1.849.814 8.44 3.703 1.873.821 5.973 2.622v1.944l-5.882 2.58-1.873.823-8.662 3.8-1.836.808-17.012 7.464v-7.655l8.53-3.607-1.854-.828L0 28.61v10.916L20.337 30.6l1.836-.805 8.716-3.826 1.873-.821 5.491-2.41v-3.88l-5.582-2.45Z"
          fill="#447099"
        ></path>
        <path
          d="m22.38 20.76 8.404-3.555-1.874-.82-8.44 3.567-1.907.807 1.908.808L29 25.174l1.874-.823-8.496-3.591ZM39.45 29.591v7.94l-17.278-7.737-1.836.807 20.611 9.227V28.61l-8.186-3.461-1.874.821 8.564 3.622ZM40.948 2.073l-20.475 8.983 1.85.811 17.129-7.515v7.576l-8.655 3.658 1.873.824 8.278-3.5V2.072Z"
          fill="#ED642F"
        ></path>
        <path
          d="m10.04 24.362-5.852-2.59v-1.945l5.97-2.622 1.874-.82 8.44-3.706-1.85-.812-8.473 3.72-1.875.823-5.583 2.449v3.88l5.478 2.416 1.854.83 8.482 3.797 1.835-.807-8.446-3.782-1.854-.83Z"
          fill="#ED642F"
        ></path>
        <path
          d="m10.043 24.362 1.855.83 8.577-3.625-1.909-.808-8.523 3.603Z"
          fill="#447099"
        ></path>
        <path
          d="m12.034 16.384-1.874.821 8.404 3.555 1.909-.808-8.44-3.568Z"
          fill="#447099"
        ></path>
        <path
          d="m32.67 16.41-1.873-.824-8.474-3.719-1.85-.812L0 2.074v10.836l8.278 3.5 1.873-.822-8.657-3.66V4.353l17.13 7.515 1.849.814 8.44 3.703 1.873.821 5.973 2.622v1.944l-5.882 2.58-1.873.823-8.662 3.8-1.836.808-17.012 7.464v-7.655l8.53-3.607-1.854-.828L0 28.61v10.916L20.337 30.6l1.836-.805 8.716-3.826 1.873-.821 5.491-2.41v-3.88l-5.582-2.45Z"
          fill="#447099"
        ></path>
        <path
          d="m22.38 20.76 8.404-3.555-1.874-.82-8.44 3.567-1.907.807 1.908.808L29 25.174l1.874-.823-8.496-3.591ZM39.45 29.591v7.94l-17.278-7.737-1.836.807 20.611 9.227V28.61l-8.186-3.461-1.874.821 8.564 3.622ZM40.948 2.073l-20.475 8.983 1.85.811 17.129-7.515v7.576l-8.655 3.658 1.873.824 8.278-3.5V2.072Z"
          fill="#ED642F"
        ></path>
        <path
          d="m10.04 24.362-5.852-2.59v-1.945l5.97-2.622 1.874-.82 8.44-3.706-1.85-.812-8.473 3.72-1.875.823-5.583 2.449v3.88l5.478 2.416 1.854.83 8.482 3.797 1.835-.807-8.446-3.782-1.854-.83Z"
          fill="#ED642F"
        ></path>
        ${nameText}
      </svg>
    `;
  }
};
PositLogo.styles = i`
    svg {
      translate: 0 3.5px;
    }
  `;
__decorateClass([
  n6({ type: Boolean })
], PositLogo.prototype, "withName", 2);
__decorateClass([
  n6({ type: Number })
], PositLogo.prototype, "width", 2);
__decorateClass([
  n6({ type: Number })
], PositLogo.prototype, "height", 2);
PositLogo = __decorateClass([
  e6("posit-logo")
], PositLogo);

// src/styles/op-classes.ts
var surface1 = i`
  background-color: var(--surface-1);
  color: var(--text-2);
`;
var themePrimitives = {
  brand: i`
    color: var(--brand);
    background-color: var(--brand);
  `,
  surface_1: i`
    background-color: var(--surface-1);
    color: var(--text-1);
  `,
  surface_2: i`
    background-color: var(--surface-2);
    color: var(--text-1);
  `,
  surface_3: i`
    background-color: var(--surface-3);
    color: var(--text-1);
  `,
  surface_4: i`
    background-color: var(--surface-4);
    color: var(--text-1);
  `,
  fancy_shadow: i`
    border: 1px solid hsl(var(--brand-hue) 10% 50% / 15%);
    box-shadow: 0 1rem 0.5rem -0.5rem;
    box-shadow: 0 2.8px 2.2px
        hsl(var(--shadow-color) / calc(var(--shadow-strength) + 3%)),
      0 6.7px 5.3px hsl(var(--shadow-color) / calc(var(--shadow-strength) + 1%)),
      0 12.5px 10px hsl(var(--shadow-color) / calc(var(--shadow-strength) + 2%)),
      0 22.3px 17.9px
        hsl(var(--shadow-color) / calc(var(--shadow-strength) + 2%)),
      0 41.8px 33.4px
        hsl(var(--shadow-color) / calc(var(--shadow-strength) + 3%)),
      0 100px 80px hsl(var(--shadow-color) / var(--shadow-strength));
  `,
  /**
   * A series of definitions that will reset text in a component to use standards without having to manually assign everything.
   */
  text_reset: i`
    :where(h1, h2, h3, h4, h5, h6) {
      line-height: var(--line-height-headings);
      font-weight: var(--font-weight-headings);
    }

    :where(h1) {
      font-size: var(--font-size-h1);
    }

    :where(h2) {
      font-size: var(--font-size-h2);
    }

    :where(h3) {
      font-size: var(--font-size-h3);
    }

    :where(h4) {
      font-size: var(--font-size-h4);
    }

    :where(h5) {
      font-size: var(--font-size-h5);
    }

    :where(p, ul, ol, dl, h6) {
      font-size: var(--font-size-m);
    }

    :where(a, u, ins, abbr) {
      text-underline-offset: 1px;

      @supports (-moz-appearance: none) {
        text-underline-offset: 2px;
      }
    }
  `
};

// src/shiny-avatar.ts
var ShinyAvatar = class extends s4 {
  constructor() {
    super(...arguments);
    this.size = 40;
    this.src = "";
    this.alt = "Avatar photo";
    this.variant = "circle";
    this.name = "";
    this.inline = true;
  }
  render() {
    return x`<span class="name">${this.name}</span>
      <img
        class="${this.variant}"
        style="width:${this.size}px;"
        src="${this.src}"
        alt="${this.alt}"
      />`;
  }
};
// Styles are scoped to this element: they won't conflict with styles
// on the main page or in other components. Styling API can be exposed
// via CSS custom properties.
ShinyAvatar.styles = i`
    :host {
      display: flex;
      align-items: center;
      gap: var(--size-s);
    }

    :host([inline]) {
      display: inline-flex;
    }

    img {
      aspect-ratio: 1;

      ${themePrimitives.fancy_shadow}
    }

    img.circle {
      border-radius: var(--radius-round);
    }

    img.blob {
      border-radius: var(--radius-blob-2);
    }

    .name {
      font-size: var(--font-size-m);
    }

    .name:empty {
      display: none;
    }

    * {
      box-sizing: border-box;
      min-width: 0;
    }
  `;
__decorateClass([
  n6()
], ShinyAvatar.prototype, "size", 2);
__decorateClass([
  n6()
], ShinyAvatar.prototype, "src", 2);
__decorateClass([
  n6()
], ShinyAvatar.prototype, "alt", 2);
__decorateClass([
  n6()
], ShinyAvatar.prototype, "variant", 2);
__decorateClass([
  n6()
], ShinyAvatar.prototype, "name", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], ShinyAvatar.prototype, "inline", 2);
ShinyAvatar = __decorateClass([
  e6("shiny-avatar")
], ShinyAvatar);

// src/shiny-card.ts
var ShinyCard = class extends s4 {
  constructor() {
    super(...arguments);
    this.centercontent = false;
    this.nofill = false;
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.height) {
      const height = typeof this.height === "number" ? `${this.height}px` : this.height;
      this.style.setProperty("--card-h", height);
    }
  }
  render() {
    return x`
      <div class="header">
        <slot name="header"></slot>
      </div>
      <div class="sidebar">
        <slot name="sidebar"></slot>
      </div>
      <div class="body">
        <slot></slot>
      </div>
      <div class="footer">
        <slot name="footer"></slot>
      </div>
    `;
  }
};
ShinyCard.styles = i`
    * {
      box-sizing: border-box;
    }

    :host {
      --card-padding: var(--item-padding, var(--size-m));

      ${themePrimitives.surface_1}

      /* We use inline-size here because the more broad "size" value will force
      this element to declare its height explicitely. We only really care about
      width for container queries so that's fine. This is a funny gotcha though
      that isn't obvious */
      container-type: inline-size;
      border: var(--border-standard);
      border-radius: var(--card-radius, var(--radius-m));
      box-shadow: var(--card-shadow, var(--shadow-m));
      background-color: var(--card-bg, var(--surface-1));
      overflow: hidden;
      flex: 1 1 auto;
      display: grid;
      grid-template:
        "header header" auto
        "sidebar body" 1fr
        "footer footer" auto /
        auto 1fr;
      isolation: isolate;
    }

    :host([height]) {
      height: var(--card-h);
      flex: 0 0 var(--card-h);
    }

    :host([height="content"]) {
      height: fit-content;
      flex-basis: content;
    }

    .header {
      grid-area: header;
      z-index: 3;
      position: relative;
    }

    .footer {
      grid-area: footer;
      z-index: 2;
      position: relative;
    }

    .sidebar {
      grid-area: sidebar;
      position: relative;
      z-index: 1;
    }

    .body {
      /* For some reason this prevents scrollbars from appearing when they arent
      needed on wide contents... I wish there was a more satisfying solution */
      display: flex;
      grid-area: body;
      flex-direction: column;
      padding: var(--card-padding);
      gap: var(--spacing, var(--size-s));
      overflow: auto;
      z-index: 0;
    }

    :host([nofill]) .body {
      display: block;
    }

    /* Make block-layout slotted children stretch without neccesary needing to
    specify it themselves. This will leave text alone etc. It's unclear if this
    list should be expanded or not or if this is too strong of a selector but it
    seems reasonable. */
    ::slotted(:is(div, section)) {
      flex: 1;
    }

    /* Need to set all children as block display to keep behavior similar to flex */
    :host([nofill]) .body > ::slotted(*) {
      display: block;
      border-radius: var(--child-radius);
    }

    :host([centercontent]) .body {
      display: grid;
      place-content: center;
      overflow: auto;
    }
  `;
__decorateClass([
  n6()
], ShinyCard.prototype, "height", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], ShinyCard.prototype, "centercontent", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], ShinyCard.prototype, "nofill", 2);
ShinyCard = __decorateClass([
  e6("shiny-card")
], ShinyCard);
var ShinyCardSlot = class extends s4 {
  static {
    this.styles = i`
    * {
      box-sizing: border-box;
    }

    :host {
      --card-padding: var(--item-padding, var(--size-m));

      display: block;
      padding-inline: var(--card-padding);
      padding-block: var(--card-padding);
    }

    :host([slot="header"]) {
      border-bottom: var(--border-standard);
    }

    :host([slot="footer"]) {
      border-top: var(--border-standard);
    }

    ::slotted(*) {
      margin: 0;
    }
  `;
  }
  render() {
    return x`<slot></slot>`;
  }
};
var ShinyCardHeader = class extends ShinyCardSlot {
  constructor() {
    super();
    setElAttr(this, "slot", "header");
  }
};
ShinyCardHeader = __decorateClass([
  e6("shiny-card-header")
], ShinyCardHeader);
var ShinyCardFooter = class extends ShinyCardSlot {
  constructor() {
    super();
    setElAttr(this, "slot", "footer");
  }
};
ShinyCardFooter = __decorateClass([
  e6("shiny-card-footer")
], ShinyCardFooter);

// src/tab.ts
var Tab = class extends s4 {
  constructor() {
    super(...arguments);
    this.name = "tab";
    this.icon = "";
  }
  render() {
    return x` <slot></slot> `;
  }
};
/**
 * Styles are scoped to this element: they won't conflict with styles
 * on the main page or in other components. Styling API can be exposed
 * via CSS custom properties.
 */
Tab.styles = i`
    :host {
      display: block;
      position: relative;
      height: 100%;
      min-height: 0;
      width: 100%;
      min-width: 0;
      padding: var(--tab-padding);
    }
  `;
__decorateClass([
  n6({ type: String })
], Tab.prototype, "name", 2);
__decorateClass([
  n6({ type: String })
], Tab.prototype, "icon", 2);
Tab = __decorateClass([
  e6("shiny-tab")
], Tab);
var TabLabel = class extends s4 {
  render() {
    return x`<slot></slot>`;
  }
};
TabLabel.styles = [
  i`
      :host {
        display: flex;
        align-items: center;
        gap: var(--size-xxs);
      }
    `
];
TabLabel = __decorateClass([
  e6("tab-label")
], TabLabel);

// src/shiny-dashboard.ts
var ShinyDashboard = class extends s4 {
  constructor() {
    super(...arguments);
    this.dynamicHeight = false;
    this.selectedTabIndex = 0;
    this.tabsOnSide = false;
    this.tabs = [];
    this.hasHeaderContents = false;
    this.onChangeCallback = (x6) => {
    };
  }
  // Watch for additions the header slot. If they exist we make sure they're
  // legit and show the header.
  watchHeaderSlot(e9) {
    this.hasHeaderContents = getElementsFromSlotChangeEvent(e9).length > 0;
  }
  watchMainSlot(e9) {
    this.tabs = extractTabsFromElements(getElementsFromSlotChangeEvent(e9));
    console.log("Tab search results", this.tabs);
    this.selectTab();
  }
  selectTab(tabIndex = this.selectedTabIndex) {
    this.selectedTabIndex = tabIndex;
    selectTabByIndex(this.tabs, tabIndex);
    this.onChangeCallback(true);
  }
  // Callback used in the select input for mobile mode tab selection
  handleTabSelect(event) {
    const selectedTabName = event.target.value.replaceAll("_", " ");
    const selectedTabIndex = this.tabs.findIndex(
      (tab) => tab.name === selectedTabName
    );
    this.selectTab(selectedTabIndex);
  }
  currentTabName() {
    return this.tabs[this.selectedTabIndex].name;
  }
  getValue() {
    return this.currentTabName();
  }
  showHeader() {
    if (this.hasHeaderContents)
      return true;
    if (this.tabs.length > 0 && !this.tabsOnSide)
      return true;
    return false;
  }
  render() {
    const tabs = this.tabs.map((tab, i6) => {
      const isSelected = i6 === this.selectedTabIndex;
      return x`<div
        class="tab ${isSelected ? "selected-tab" : ""}"
        @click=${() => this.selectTab(i6)}
        title=${isSelected ? `Current: ${tab.name}` : `Switch to: ${tab.name}`}
      >
        ${tab.label}
      </div>`;
    });
    const tabContainer = x`<div
      class="nav ${this.tabsOnSide ? "sidebar-nav" : ""}"
    >
      <div class="nav-slot before-nav">
        <slot name="before_navigation"></slot>
      </div>
      <div class="tabs">${tabs}</div>
      <div class="mobile-tabs">
        <sl-select
          @sl-change=${this.handleTabSelect}
          value=${this.tabs[this.selectedTabIndex]?.value ?? ""}
        >
          ${this.tabs.map(
      (tab) => x`<sl-option value="${tab.value}">${tab.name}</sl-option>`
    )}
        </sl-select>
      </div>
      <div class="nav-slot after-nav">
        <slot name="after_navigation"></slot>
      </div>
    </div>`;
    const haveTabs = this.tabs.length > 0;
    return x`
      <div class="tabset">
        ${this.tabsOnSide && haveTabs ? tabContainer : ""}
        <div class="header ${this.showHeader() ? "" : "empty-header"}">
          <slot name="header" @slotchange=${this.watchHeaderSlot}></slot>
          ${this.tabsOnSide ? "" : haveTabs ? tabContainer : ""}
        </div>
        <div class="sidebar">
          <slot name="sidebar"></slot>
        </div>
        <div class="main">
          <slot @slotchange=${this.watchMainSlot}></slot>
        </div>
        <div class="footer">
          <slot name="footer"></slot>
        </div>
      </div>
    `;
  }
};
ShinyDashboard.styles = i`
    * {
      box-sizing: border-box;
    }

    :host {
      --padding: var(--size-m);
      --page-h: 100%;

      ${themePrimitives.surface_3}

      display: block;
      height: 100%;
      container-type: inline-size;
      overflow: auto;
    }

    :host([dynamicHeight]) {
      --page-h: auto;
    }

    .tabset {
      height: var(--page-h);
      width: 100%;
      display: grid;
      grid-template:
        "nav sidebar header" auto
        "nav sidebar content" 1fr
        "nav sidebar footer" auto /
        auto auto 1fr;
      isolation: isolate;
    }

    .tabset > * {
      min-width: 0;
      min-height: 0;
    }

    .sidebar {
      z-index: 3;
      padding: 0;
      grid-area: sidebar;

      ${themePrimitives.surface_1}
    }

    .main {
      z-index: 1;
      grid-area: content;
      padding: var(--padding);
    }

    .header,
    .footer {
      /* Use background image if passed */
      background-image: var(--header-bg-image);
      background-color: var(--surface-1);
      z-index: 2;
      margin: 0;
      display: flex;
      align-items: center;
      gap: var(--padding);
    }

    .header {
      grid-area: header;
    }

    .header.empty-header {
      display: none;
    }

    .header-right {
      margin-left: auto;
    }

    .nav {
      /* Some variables that control the little bars that demarkate tabs and
      also show what is selected */
      --tab-border-color: var(--text-2);

      grid-area: nav;
      display: flex;
      flex-flow: row nowrap;
      width: 100%;
      align-items: baseline;
      justify-content: space-between;
      border-block-end: 1px solid var(--border-color);
      padding: var(--size-m);
      gap: var(--size-s);
      background-color: var(--surface-1);
    }

    .tab {
      cursor: pointer;
      position: relative;
      padding-inline: var(--size-m);

      /* Use the container padding for the top of the tab */
      padding-block: var(--size-xs);
      color: var(--text-1);

      /* Add elipses to prevent overflow for tab names that are too long */
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      transition: background-color var(--transition-fast);
      border-radius: var(--radius-s);
    }

    .selected-tab {
      background-color: var(--surface-3);
    }

    .nav.sidebar-nav {
      overflow: auto;
      flex-flow: column nowrap;
      border-inline-end: 1px solid var(--border-color);
      border-block-end: unset;
    }

    :host([tabsOnSide]) .after-nav {
      margin-block-start: auto;
    }

    .sidebar-nav .tab {
      flex-shrink: 0;
    }

    .nav .mobile-tabs {
      display: none;
    }

    .nav > * {
      flex-shrink: 5;
    }

    .tabs {
      flex-shrink: 1;
      display: flex;
      align-items: end;
      row-gap: var(--size-xs);
      position: relative;
      width: auto;
      border-radius: var(--radius-s);
      background-color: var(--surface-1);
      overflow: hidden;
      gap: var(--size-xs);
    }

    .sidebar-nav .tabs {
      border-width: 1;
      min-width: unset;
      flex-flow: column nowrap;
      align-items: stretch;
      overflow: auto;
      max-width: var(--size-content-1);
    }

    .tab:last-child {
      border-inline-end: unset;
    }

    .tab:hover:not(.selected-tab) {
      background-color: var(--surface-4);
    }

    :host([tabsOnSide]) .tab {
      padding-block: var(--size-xs);
      border-inline-end: unset;
    }

    .footer {
      grid-area: footer;
    }

    .footer > ::slotted(*) {
      padding: var(--padding);
      padding-block-start: 0;
    }

    .header > ::slotted(div) {
      margin: 0;
      padding: 0;
      padding-inline: var(--padding);
    }

    /* Mobile styles */

    .mobile-tabs select {
      background-color: inherit;
      accent-color: pink;
    }

    @container (width < 500px) {
      /* Hide the tabs and show the select */
      .nav:not(.sidebar-nav) .mobile-tabs {
        display: unset;
      }

      .nav:not(.sidebar-nav) .tabs {
        display: none;
      }
    }
  `;
__decorateClass([
  n6({ type: Boolean })
], ShinyDashboard.prototype, "dynamicHeight", 2);
__decorateClass([
  n6({ type: Number })
], ShinyDashboard.prototype, "selectedTabIndex", 2);
__decorateClass([
  n6({ type: Boolean })
], ShinyDashboard.prototype, "tabsOnSide", 2);
__decorateClass([
  t5()
], ShinyDashboard.prototype, "tabs", 2);
__decorateClass([
  t5()
], ShinyDashboard.prototype, "hasHeaderContents", 2);
ShinyDashboard = __decorateClass([
  e6("shiny-dashboard")
], ShinyDashboard);
makeInputBinding("shiny-dashboard");
function extractTabsFromElements(elements) {
  const tabElements = [];
  const tabNodes = document.querySelectorAll("shiny-tab[name]");
  tabNodes.forEach((node) => {
    const tabName = node.attributes.getNamedItem("name")?.value;
    const tabIcon = node.attributes.getNamedItem("icon")?.value;
    if (!tabName) {
      return;
    }
    const tabLabel = node.querySelector("tab-label");
    tabElements.push({
      name: tabName,
      value: tabName.replaceAll(" ", "_"),
      el: node,
      label: tabLabel ?? x`
          <tab-label>
            ${tabIcon ? x`<shiny-icon name=${tabIcon}></shiny-icon>` : ""}
            ${tabName}
          </tab-label>
        `
    });
  });
  return tabElements;
}
function selectTabByIndex(tabs, index2) {
  tabs.forEach((tab, i6) => {
    const isSelected = i6 === index2;
    const currentlyHidden = tab.el.style.display === "none";
    const hidingTab = !currentlyHidden && !isSelected;
    if (hidingTab) {
      if (typeof $ !== "undefined") {
        $(tab.el).trigger("hidden");
      }
      tab.el.inert = true;
      tab.el.style.display = "none";
    }
    const showingTab = currentlyHidden && isSelected;
    if (showingTab) {
      if (typeof $ !== "undefined") {
        $(tab.el).trigger("shown");
      }
      tab.el.inert = false;
      tab.el.style.display = "block";
    }
  });
}

// src/shiny-section.ts
var Section = class extends s4 {
  constructor() {
    super(...arguments);
    this.icon = "";
  }
  render() {
    return x`<div class="icon">
        ${this.icon && x`<shiny-icon name=${this.icon}></shiny-icon>`}
        <slot name="icon"></slot>
      </div>
      <div class="content"><slot></slot></div>`;
  }
};
// Styles are scoped to this element: they won't conflict with styles
// on the main page or in other components. Styling API can be exposed
// via CSS custom properties.
Section.styles = i`
    :host {
      display: grid;
      align-items: center;
      grid-template-columns: var(--sidebar-content-columns, auto 1fr);
      gap: var(--sidebar-content-gap, var(--size-m));
      height: var(--sidebar-content-height, auto);
      padding-block: var(--padding, 100px);
    }

    * {
      box-sizing: border-box;
      min-width: 0;
    }

    [closed] :host {
      background-color: pink;
    }

    .icon {
      font-size: var(--size-l);
      text-align: center;
    }

    .content > ::slotted(h2) {
      margin: 0;
      padding-block: 0;
    }

    .content > ::slotted(*:last-child) {
      margin-bottom: 0 !important;
    }

    .content {
      overflow: var(--sidebar-content-overflow);
      display: flex;
      flex-direction: column;
      gap: var(--size-s);
    }
  `;
__decorateClass([
  n6()
], Section.prototype, "icon", 2);
Section = __decorateClass([
  e6("shiny-section")
], Section);

// src/sidebar.ts
var Sidebar = class extends s4 {
  constructor() {
    super();
    this.closed = false;
    this.openWidthPx = 320;
    this.collapseToIcons = false;
    this.inDashboard = false;
    setElAttr(this, "slot", "sidebar");
    this.addEventListener("click", (e9) => {
      if (!this.closed)
        return;
      this.toggleClosed();
    });
  }
  /**
   * Toggles the `closed` property on the sidebar which will be reflected in
   * styles.
   */
  toggleClosed() {
    this.closed = !this.closed;
  }
  /**
   * Handles the click event on the toggle button. This is a separate function
   * so that we can stop propagation of the event.
   * @param e - The click event.
   * @returns void
   */
  handleToggleBtnClick(e9) {
    e9.stopPropagation();
    this.toggleClosed();
  }
  /**
   * Recursively searches for the closest parent element that is a known container
   * for the sidebar.
   *
   * @param sidebar - The sidebar element to start the search from.
   * @returns The closest parent element that is a known container for the sidebar,
   * or `null` if no container is found.
   */
  findSidebarContainer(sidebar) {
    const parent = sidebar.parentElement;
    if (!parent) {
      return null;
    }
    if (parent instanceof ShinyDashboard) {
      this.inDashboard = true;
      return parent;
    }
    const parentIsContainer = Sidebar.allowedContainers.some(
      (p5) => parent instanceof p5
    );
    if (parentIsContainer) {
      return parent;
    }
    return this.findSidebarContainer(parent);
  }
  /**
   * Checks if the sidebar is in a small container and if so, automatically
   * collapses the sidebar to avoid it taking up too much space.
   */
  autoCollapseOnSmallScreens() {
    const container = this.findSidebarContainer(this);
    if (container && container.clientWidth < 700) {
      this.closed = true;
    }
  }
  /**
   * When the children of the sidebar change, we check if they are all
   * `<shiny-section>` elements. If they are, we collapse the sidebar to icons
   * on smaller screens.
   * @param e - The slotchange event.
   * @returns void
   */
  watchForIconSectionChildren(e9) {
    const elementsInSlot = getElementsFromSlotChangeEvent(e9);
    const hasOnlySections = elementsInSlot.every((el) => el instanceof Section);
    this.collapseToIcons = elementsInSlot.length > 0 && hasOnlySections;
  }
  connectedCallback() {
    super.connectedCallback();
    this.autoCollapseOnSmallScreens();
  }
  render() {
    return x`
      <div class="container ${this.inDashboard ? "dashboard-sidebar" : ""}">
        <div>
          <div
            class="toggle-icon"
            @click=${this.handleToggleBtnClick}
            title=${this.closed ? "Open sidebar" : "Close sidebar"}
          >
            <shiny-icon name="ri:expand-left-line"></shiny-icon>
          </div>
        </div>
        <div class="content" style="--sidebar-width: ${this.openWidthPx}px;">
          <slot @slotchange=${this.watchForIconSectionChildren}></slot>
        </div>
      </div>
    `;
  }
};
Sidebar.styles = i`
    * {
      box-sizing: border-box;
    }

    :host {
      /* How much padding is around the content and between items within the
      sidebar? This variable controls a lot of the visual appearance */
      --padding: var(--sidebar-padding, var(--size-m));

      /* Sizes related to the toggle icon */
      --toggle-size: var(--padding);
      --toggle-pad: calc(var(--padding) / 4);

      /* Internal calculated properties - change at your own risk! */
      --full-padded-w: calc(var(--toggle-size) + 2 * var(--toggle-pad));

      /* TODO: Use container query units here if available */
      --open-width: min(
        var(
          --sidebar-width,
          calc((var(--size-content-1) + var(--size-content-2)) / 2)
        ),
        calc(100vw - (3 * var(--padding)))
      );
      --closed-width: var(--full-padded-w);

      /* Animation for opening and closing */
      --transition: var(--speed-fast) var(--ease-3);

      /* All the variables that have "*-content-*" in their names are passed
      through to the <shiny-section> tag that lets it know how to control its
      content so that it can selectively hide or show the content associated
      with an icon or not. I don't like how confusing it is and think something
      like subgrid could help with this */
      --section-icon-w: var(--size-l);
      --sidebar-content-columns: var(--section-icon-w) 1fr;
      --sidebar-content-gap: var(--padding);

      height: 100%;
      display: flex;
      flex-direction: column;
      background-color: var(--sidebar-bg, var(--surface-1));
      width: var(--open-width);
      transition: width var(--transition), padding var(--transition);
    }

    :host([closed]) {
      width: var(--closed-width);
      cursor: e-resize;
      overflow: hidden;
    }

    /* Leave the sidebar wide enough to view the icons */
    :host([collapseToIcons]) {
      --closed-width: calc(var(--section-icon-w) + (2 * var(--padding)));
    }

    .content {
      height: 100%;
      overflow: auto;
      padding-inline: var(--padding);
      display: flex;
      flex-direction: column;
      background-color: inherit;
      width: var(--open-width);

      /* Move content up a bit so there's not an awkward amount of space before
      content starts */
      margin-top: calc(-2 * var(--toggle-pad));
      transition: opacity var(--transition);
    }

    /* For the normal sidebar collapse we want the opacity to go to zero when
    collapsed so the content doesn't show */
    :host([closed]:not([collapseToIcons])) .content {
      opacity: 0;
    }

    /* Styles for when the sidebar is in a very small container such as a card
    or mobile device */
    @container (max-width: 700px) {
      :host {
        width: var(--closed-width);
        z-index: 10;
      }

      .container {
        /* When on small screens we want the sidebar to slide over the main
        content rather than pushing it out of the way */
        position: absolute;
        background-color: inherit;
        width: var(--open-width);
        height: 100%;
        overflow: hidden;
        border-right: var(--border-standard);
      }

      .container.dashboard-sidebar {
        box-shadow: var(--shadow-l);
      }

      :host([closed]) .container {
        width: var(--closed-width);
      }
    }

    .content > ::slotted(shiny-section) {
      border-bottom: var(--border-normal);
    }

    .content > ::slotted(shiny-section:last-child) {
      border-bottom: none;
    }

    .toggle-icon {
      /* Resting state has a lower opacity to not make the toggle standout so
      much and distract from content */
      opacity: 0.5;
      font-size: var(--font-size-l);
      color: var(--text-3);
      cursor: pointer;
      user-select: none;

      /* Make sure we're always the same distance from the right of the sidebar
      when we're closed or open */
      margin-inline-start: auto;
      margin-inline-end: 0;
      width: var(--full-padded-w);
      height: var(--full-padded-w);
      padding: var(--toggle-pad);

      /* Make sure the icon itself is nice and centered */
      display: grid;
      place-content: center;

      /* We use a transform to flip icon to a collapse icon and also increase
      the opacity on hover, we animate these to look _cool_ */
      transition: transform var(--transition), opacity var(--transition);
    }

    /* Give feedback of action on hover */
    .toggle-icon:hover {
      opacity: 1;
    }

    /* When we're closed we invert the icon on the x-axis to make it an expand
    icon */
    :host([closed]) .toggle-icon {
      transform: scaleX(-1);
    }
  `;
/**
 * The list of elements that are allowed to be containers for the sidebar.
 * Currently, the known containers are `shiny-dashboard` and `shiny-card`. If
 * more containers are added in the future, this list will need to be updated
 * to generalize the search.
 * @static
 * @private
 * @memberof Sidebar
 * @readonly
 */
Sidebar.allowedContainers = [ShinyDashboard, ShinyCard];
__decorateClass([
  n6({ type: Boolean, reflect: true })
], Sidebar.prototype, "closed", 2);
__decorateClass([
  n6({ type: Number })
], Sidebar.prototype, "openWidthPx", 2);
__decorateClass([
  n6({ type: Boolean, reflect: true })
], Sidebar.prototype, "collapseToIcons", 2);
__decorateClass([
  t5()
], Sidebar.prototype, "inDashboard", 2);
Sidebar = __decorateClass([
  e6("shiny-sidebar")
], Sidebar);

// src/simple-number-input.ts
var SimpleNumberInput = class extends s4 {
  constructor() {
    super(...arguments);
    this.min = 0;
    this.max = 10;
    this.value = (this.min + this.max) / 2;
    this.invalid = false;
    this.onChangeCallback = (x6) => {
    };
    this.onValueChange = makeValueChangeEmitter(this, this.id);
  }
  static {
    this.properties = {
      min: { type: Number },
      max: { type: Number },
      value: { type: Number },
      invalid: { type: Boolean }
    };
  }
  static {
    this.styles = i`
    :host {
      --inline-padding: var(--number-input-padding-inline, var(--size-xs));
      --block-padding: var(--number-input-padding-block, var(--size-xs));

      font-size: var(--number-input-font-size, var(--font-size-3));
      position: relative;
      width: var(--number-input-width, fit-content);
      height: var(--number-input-height, fit-content);
    }

    .wrapper {
      display: inline-flex;
      background-color: var(
        --number-input-bg-color,
        var(--sl-input-background-color)
      );
      background-image: var(--number-input-bg-image);
      color: var(--number-input-text-color, var(--sl-input-color));
      border: none;
      border-radius: var(
        --number-input-border-radius,
        var(--sl-border-radius-pill)
      );
      outline: var(--number-input-border-width, var(--sl-input-border-width))
        solid var(--number-input-border-color, var(--sl-input-border-color));
      padding-inline: var(--inline-padding);
      padding-block: var(--block-padding);
    }

    .wrapper.invalid {
      outline-color: var(--warning);
    }

    input {
      font-size: inherit;
      border: none;
      background-color: transparent;
      color: inherit;
      outline-width: 0;
      text-align: center;
    }

    input:focus-visible {
      outline-width: 0;
    }

    /* Hide the number input's spin buttons */

    /* Chrome, Safari, Edge, Opera */
    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    /* Firefox */
    input[type="number"] {
      -moz-appearance: textfield;
    }

    .plusminus {
      font-size: inherit;
      border: var(--number-input-plusminus-border, none);
      background-color: transparent;
      color: inherit;
    }

    .plusminus:hover {
      cursor: pointer;
    }

    .plusminus.left {
      padding-inline-start: var(--inline-padding);
    }

    .plusminus.right {
      padding-inline-end: var(--inline-padding);
    }

    .validation-msg {
      position: absolute;

      /* margin-left: var(--space-x-small); */
      font-size: var(
        --number-input-warning-font-size,
        var(--sl-font-size-x-small)
      );
      top: calc(115%);
      color: var(--warning);
      transform: scaleX(0);
      transition: transform var(--sl-transition-fast) var(--ease-squish-2);
      transform-origin: left;
    }

    .wrapper.invalid .validation-msg {
      transform: scaleX(1);
    }
  `;
  }
  getInputElement() {
    return this.shadowRoot.querySelector("input");
  }
  handleMinus(e9) {
    const inputValue = this.getInputElement().valueAsNumber;
    let newValue;
    if (isNaN(inputValue)) {
      newValue = this.min;
    } else {
      newValue = clamp(inputValue - 1, this.min, this.max);
    }
    this.getInputElement().value = newValue.toString();
    this.value = newValue;
    this.invalid = false;
    this.alertOfChange();
  }
  handlePlus(e9) {
    const inputValue = this.getInputElement().valueAsNumber;
    let newValue;
    if (isNaN(inputValue)) {
      newValue = this.max;
    } else {
      newValue = clamp(inputValue + 1, this.min, this.max);
    }
    this.getInputElement().value = newValue.toString();
    this.value = newValue;
    this.invalid = false;
    this.alertOfChange();
  }
  handleChange(e9) {
    const inputValue = e9.target.valueAsNumber;
    const clampedValue = clamp(inputValue, this.min, this.max);
    if (clampedValue === inputValue) {
      this.value = clampedValue;
      this.invalid = false;
      this.alertOfChange();
    } else {
      this.invalid = true;
    }
  }
  alertOfChange() {
    this.onChangeCallback(true);
    this.onValueChange({ type: "number", value: this.value });
  }
  connectedCallback() {
    super.connectedCallback();
    setTimeout(() => {
      this.alertOfChange();
    }, 2);
  }
  render() {
    return x`
      <div class="wrapper ${this.invalid ? "invalid" : null}">
        <button
          part="minus-button"
          class="plusminus left"
          @mousedown=${this.handleMinus}
          @keydown=${(e9) => {
      if (e9.code === "Space")
        this.handleMinus(e9);
    }}
        >
          </button
        ><input
          part="input"
          value=${this.value}
          min=${this.min}
          max=${this.max}
          @input=${this.handleChange}
          type="number"
        /><button
          part="plus-button"
          class="plusminus right"
          @mousedown=${this.handlePlus}
          @keydown=${(e9) => {
      if (e9.code === "Space")
        this.handlePlus(e9);
    }}
        >
          +
        </button>
        <span class="validation-msg"
          >Make sure your number is between ${this.min} and ${this.max}</span
        >
      </div>
    `;
  }
};
customElements.define("simple-number-input", SimpleNumberInput);
makeInputBinding("simple-number-input");
function clamp(x6, min4, max4) {
  return Math.max(Math.min(x6, max4), min4);
}

// src/simple-number-output.ts
var SimpleNumberOutput = class extends s4 {
  constructor() {
    super(...arguments);
    this.value = null;
    this.watch = "";
    this.watcher = dummyDataPassingWatcher;
  }
  static {
    this.properties = {
      value: { type: Number },
      watch: { type: String }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.watcher = makeDataPassingWatcher(this.watch, (payload) => {
      if (payload.type !== "number") {
        console.error("Expected number, got", payload.value);
        return;
      }
      this.value = payload.value;
    });
  }
  static {
    this.styles = i`
    .value {
      display: block;
      font-size: var(--font-size-m);
      background-color: var(--surface-3);
    }
  `;
  }
  render() {
    return x` <div class="value">Your number is: ${this.value}</div> `;
  }
};
customElements.define("simple-number-output", SimpleNumberOutput);

// src/theme-chooser.ts
var themes = ["default", "light", "dark", "dim", "grape", "choco"];
var ThemeChooser = class extends s4 {
  constructor() {
    super();
    this.choice = themes[0];
    this.addEventListener("sl-change", this.handleChange);
  }
  handleChange(e9) {
    const radios = this.shadowRoot.querySelector("forge-input-radio-buttons");
    this.choice = radios.getValue();
    if (this.choice === "default") {
      delete document.documentElement.dataset["shinytheme"];
      return;
    }
    document.documentElement.dataset["shinytheme"] = this.choice;
  }
  render() {
    return x`
      <forge-input-radio-buttons
        choices=${JSON.stringify(themes)}
        selected="default"
        size="small"
        inline
        button
        pill
      >
      </forge-input-radio-buttons>
    `;
  }
};
ThemeChooser.styles = i`
    input {
      border-radius: var(--radius-s);
    }
  `;
__decorateClass([
  n6({ reflect: true })
], ThemeChooser.prototype, "choice", 2);
ThemeChooser = __decorateClass([
  e6("theme-chooser")
], ThemeChooser);

// node_modules/colorjs.io/dist/color.js
function multiplyMatrices(A6, B6) {
  let m5 = A6.length;
  if (!Array.isArray(A6[0])) {
    A6 = [A6];
  }
  if (!Array.isArray(B6[0])) {
    B6 = B6.map((x6) => [x6]);
  }
  let p5 = B6[0].length;
  let B_cols = B6[0].map((_4, i6) => B6.map((x6) => x6[i6]));
  let product = A6.map((row) => B_cols.map((col) => {
    let ret = 0;
    if (!Array.isArray(row)) {
      for (let c9 of col) {
        ret += row * c9;
      }
      return ret;
    }
    for (let i6 = 0; i6 < row.length; i6++) {
      ret += row[i6] * (col[i6] || 0);
    }
    return ret;
  }));
  if (m5 === 1) {
    product = product[0];
  }
  if (p5 === 1) {
    return product.map((x6) => x6[0]);
  }
  return product;
}
function isString(str) {
  return type2(str) === "string";
}
function type2(o8) {
  let str = Object.prototype.toString.call(o8);
  return (str.match(/^\[object\s+(.*?)\]$/)[1] || "").toLowerCase();
}
function toPrecision(n9, precision) {
  n9 = +n9;
  precision = +precision;
  let integerLength = (Math.floor(n9) + "").length;
  if (precision > integerLength) {
    return +n9.toFixed(precision - integerLength);
  } else {
    let p10 = 10 ** (integerLength - precision);
    return Math.round(n9 / p10) * p10;
  }
}
function parseFunction(str) {
  if (!str) {
    return;
  }
  str = str.trim();
  const isFunctionRegex = /^([a-z]+)\((.+?)\)$/i;
  const isNumberRegex = /^-?[\d.]+$/;
  let parts = str.match(isFunctionRegex);
  if (parts) {
    let args = [];
    parts[2].replace(/\/?\s*([-\w.]+(?:%|deg)?)/g, ($0, arg) => {
      if (/%$/.test(arg)) {
        arg = new Number(arg.slice(0, -1) / 100);
        arg.type = "<percentage>";
      } else if (/deg$/.test(arg)) {
        arg = new Number(+arg.slice(0, -3));
        arg.type = "<angle>";
        arg.unit = "deg";
      } else if (isNumberRegex.test(arg)) {
        arg = new Number(arg);
        arg.type = "<number>";
      }
      if ($0.startsWith("/")) {
        arg = arg instanceof Number ? arg : new Number(arg);
        arg.alpha = true;
      }
      args.push(arg);
    });
    return {
      name: parts[1].toLowerCase(),
      rawName: parts[1],
      rawArgs: parts[2],
      // An argument could be (as of css-color-4):
      // a number, percentage, degrees (hue), ident (in color())
      args
    };
  }
}
function last(arr) {
  return arr[arr.length - 1];
}
function interpolate(start2, end, p5) {
  if (isNaN(start2)) {
    return end;
  }
  if (isNaN(end)) {
    return start2;
  }
  return start2 + (end - start2) * p5;
}
function interpolateInv(start2, end, value) {
  return (value - start2) / (end - start2);
}
function mapRange(from, to2, value) {
  return interpolate(to2[0], to2[1], interpolateInv(from[0], from[1], value));
}
function parseCoordGrammar(coordGrammars) {
  return coordGrammars.map((coordGrammar2) => {
    return coordGrammar2.split("|").map((type3) => {
      type3 = type3.trim();
      let range4 = type3.match(/^(<[a-z]+>)\[(-?[.\d]+),\s*(-?[.\d]+)\]?$/);
      if (range4) {
        let ret = new String(range4[1]);
        ret.range = [+range4[2], +range4[3]];
        return ret;
      }
      return type3;
    });
  });
}
var util = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  interpolate,
  interpolateInv,
  isString,
  last,
  mapRange,
  multiplyMatrices,
  parseCoordGrammar,
  parseFunction,
  toPrecision,
  type: type2
});
var Hooks = class {
  add(name, callback, first2) {
    if (typeof arguments[0] != "string") {
      for (var name in arguments[0]) {
        this.add(name, arguments[0][name], arguments[1]);
      }
      return;
    }
    (Array.isArray(name) ? name : [name]).forEach(function(name2) {
      this[name2] = this[name2] || [];
      if (callback) {
        this[name2][first2 ? "unshift" : "push"](callback);
      }
    }, this);
  }
  run(name, env) {
    this[name] = this[name] || [];
    this[name].forEach(function(callback) {
      callback.call(env && env.context ? env.context : env, env);
    });
  }
};
var hooks = new Hooks();
var defaults7 = {
  gamut_mapping: "lch.c",
  precision: 5,
  deltaE: "76"
  // Default deltaE method
};
var WHITES = {
  // for compatibility, the four-digit chromaticity-derived ones everyone else uses
  D50: [0.3457 / 0.3585, 1, (1 - 0.3457 - 0.3585) / 0.3585],
  D65: [0.3127 / 0.329, 1, (1 - 0.3127 - 0.329) / 0.329]
};
function getWhite(name) {
  if (Array.isArray(name)) {
    return name;
  }
  return WHITES[name];
}
function adapt$1(W1, W2, XYZ, options = {}) {
  W1 = getWhite(W1);
  W2 = getWhite(W2);
  if (!W1 || !W2) {
    throw new TypeError(`Missing white point to convert ${!W1 ? "from" : ""}${!W1 && !W2 ? "/" : ""}${!W2 ? "to" : ""}`);
  }
  if (W1 === W2) {
    return XYZ;
  }
  let env = { W1, W2, XYZ, options };
  hooks.run("chromatic-adaptation-start", env);
  if (!env.M) {
    if (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) {
      env.M = [
        [1.0479298208405488, 0.022946793341019088, -0.05019222954313557],
        [0.029627815688159344, 0.990434484573249, -0.01707382502938514],
        [-0.009243058152591178, 0.015055144896577895, 0.7518742899580008]
      ];
    } else if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) {
      env.M = [
        [0.9554734527042182, -0.023098536874261423, 0.0632593086610217],
        [-0.028369706963208136, 1.0099954580058226, 0.021041398966943008],
        [0.012314001688319899, -0.020507696433477912, 1.3303659366080753]
      ];
    }
  }
  hooks.run("chromatic-adaptation-end", env);
  if (env.M) {
    return multiplyMatrices(env.M, env.XYZ);
  } else {
    throw new TypeError("Only Bradford CAT with white points D50 and D65 supported for now.");
  }
}
var \u03B5$4 = 75e-6;
var ColorSpace = class _ColorSpace {
  constructor(options) {
    this.id = options.id;
    this.name = options.name;
    this.base = options.base ? _ColorSpace.get(options.base) : null;
    this.aliases = options.aliases;
    if (this.base) {
      this.fromBase = options.fromBase;
      this.toBase = options.toBase;
    }
    let coords = options.coords ?? this.base.coords;
    for (let name in coords) {
      if (!("name" in coords[name])) {
        coords[name].name = name;
      }
    }
    this.coords = coords;
    let white2 = options.white ?? this.base.white ?? "D65";
    this.white = getWhite(white2);
    this.formats = options.formats ?? {};
    for (let name in this.formats) {
      let format3 = this.formats[name];
      format3.type ||= "function";
      format3.name ||= name;
    }
    if (options.cssId && !this.formats.functions?.color) {
      this.formats.color = { id: options.cssId };
      Object.defineProperty(this, "cssId", { value: options.cssId });
    } else if (this.formats?.color && !this.formats?.color.id) {
      this.formats.color.id = this.id;
    }
    this.referred = options.referred;
    Object.defineProperty(this, "path", {
      value: getPath3(this).reverse(),
      writable: false,
      enumerable: true,
      configurable: true
    });
    hooks.run("colorspace-init-end", this);
  }
  inGamut(coords, { epsilon: epsilon5 = \u03B5$4 } = {}) {
    if (this.isPolar) {
      coords = this.toBase(coords);
      return this.base.inGamut(coords, { epsilon: epsilon5 });
    }
    let coordMeta = Object.values(this.coords);
    return coords.every((c9, i6) => {
      let meta = coordMeta[i6];
      if (meta.type !== "angle" && meta.range) {
        if (Number.isNaN(c9)) {
          return true;
        }
        let [min4, max4] = meta.range;
        return (min4 === void 0 || c9 >= min4 - epsilon5) && (max4 === void 0 || c9 <= max4 + epsilon5);
      }
      return true;
    });
  }
  get cssId() {
    return this.formats.functions?.color?.id || this.id;
  }
  get isPolar() {
    for (let id2 in this.coords) {
      if (this.coords[id2].type === "angle") {
        return true;
      }
    }
    return false;
  }
  getFormat(format3) {
    if (typeof format3 === "object") {
      format3 = processFormat(format3, this);
      return format3;
    }
    let ret;
    if (format3 === "default") {
      ret = Object.values(this.formats)[0];
    } else {
      ret = this.formats[format3];
    }
    if (ret) {
      ret = processFormat(ret, this);
      return ret;
    }
    return null;
  }
  // We cannot rely on simple === because then ColorSpace objects cannot be proxied
  equals(space) {
    if (!space) {
      return false;
    }
    return this === space || this.id === space.id;
  }
  to(space, coords) {
    if (arguments.length === 1) {
      [space, coords] = [space.space, space.coords];
    }
    space = _ColorSpace.get(space);
    if (this.equals(space)) {
      return coords;
    }
    coords = coords.map((c9) => Number.isNaN(c9) ? 0 : c9);
    let myPath = this.path;
    let otherPath = space.path;
    let connectionSpace, connectionSpaceIndex;
    for (let i6 = 0; i6 < myPath.length; i6++) {
      if (myPath[i6].equals(otherPath[i6])) {
        connectionSpace = myPath[i6];
        connectionSpaceIndex = i6;
      } else {
        break;
      }
    }
    if (!connectionSpace) {
      throw new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);
    }
    for (let i6 = myPath.length - 1; i6 > connectionSpaceIndex; i6--) {
      coords = myPath[i6].toBase(coords);
    }
    for (let i6 = connectionSpaceIndex + 1; i6 < otherPath.length; i6++) {
      coords = otherPath[i6].fromBase(coords);
    }
    return coords;
  }
  from(space, coords) {
    if (arguments.length === 1) {
      [space, coords] = [space.space, space.coords];
    }
    space = _ColorSpace.get(space);
    return space.to(this, coords);
  }
  toString() {
    return `${this.name} (${this.id})`;
  }
  getMinCoords() {
    let ret = [];
    for (let id2 in this.coords) {
      let meta = this.coords[id2];
      let range4 = meta.range || meta.refRange;
      ret.push(range4?.min ?? 0);
    }
    return ret;
  }
  static registry = {};
  // Returns array of unique color spaces
  static get all() {
    return [...new Set(Object.values(_ColorSpace.registry))];
  }
  static register(id2, space) {
    if (arguments.length === 1) {
      space = arguments[0];
      id2 = space.id;
    }
    space = this.get(space);
    if (this.registry[id2] && this.registry[id2] !== space) {
      throw new Error(`Duplicate color space registration: '${id2}'`);
    }
    this.registry[id2] = space;
    if (arguments.length === 1 && space.aliases) {
      for (let alias of space.aliases) {
        this.register(alias, space);
      }
    }
    return space;
  }
  /**
   * Lookup ColorSpace object by name
   * @param {ColorSpace | string} name
   */
  static get(space, ...alternatives) {
    if (!space || space instanceof _ColorSpace) {
      return space;
    }
    let argType = type2(space);
    if (argType === "string") {
      let ret = _ColorSpace.registry[space.toLowerCase()];
      if (!ret) {
        throw new TypeError(`No color space found with id = "${space}"`);
      }
      return ret;
    }
    if (alternatives.length) {
      return _ColorSpace.get(...alternatives);
    }
    throw new TypeError(`${space} is not a valid color space`);
  }
  /**
   * Get metadata about a coordinate of a color space
   *
   * @static
   * @param {Array | string} ref
   * @param {ColorSpace | string} [workingSpace]
   * @return {Object}
   */
  static resolveCoord(ref, workingSpace) {
    let coordType = type2(ref);
    let space, coord;
    if (coordType === "string") {
      if (ref.includes(".")) {
        [space, coord] = ref.split(".");
      } else {
        [space, coord] = [, ref];
      }
    } else if (Array.isArray(ref)) {
      [space, coord] = ref;
    } else {
      space = ref.space;
      coord = ref.coordId;
    }
    space = _ColorSpace.get(space);
    if (!space) {
      space = workingSpace;
    }
    if (!space) {
      throw new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);
    }
    coordType = type2(coord);
    if (coordType === "number" || coordType === "string" && coord >= 0) {
      let meta = Object.entries(space.coords)[coord];
      if (meta) {
        return { space, id: meta[0], index: coord, ...meta[1] };
      }
    }
    space = _ColorSpace.get(space);
    let normalizedCoord = coord.toLowerCase();
    let i6 = 0;
    for (let id2 in space.coords) {
      let meta = space.coords[id2];
      if (id2.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) {
        return { space, id: id2, index: i6, ...meta };
      }
      i6++;
    }
    throw new TypeError(`No "${coord}" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(", ")}`);
  }
  static DEFAULT_FORMAT = {
    type: "functions",
    name: "color"
  };
};
function getPath3(space) {
  let ret = [space];
  for (let s8 = space; s8 = s8.base; ) {
    ret.push(s8);
  }
  return ret;
}
function processFormat(format3, { coords } = {}) {
  if (format3.coords && !format3.coordGrammar) {
    format3.type ||= "function";
    format3.name ||= "color";
    format3.coordGrammar = parseCoordGrammar(format3.coords);
    let coordFormats = Object.entries(coords).map(([id2, coordMeta], i6) => {
      let outputType = format3.coordGrammar[i6][0];
      let fromRange = coordMeta.range || coordMeta.refRange;
      let toRange = outputType.range, suffix = "";
      if (outputType == "<percentage>") {
        toRange = [0, 100];
        suffix = "%";
      } else if (outputType == "<angle>") {
        suffix = "deg";
      }
      return { fromRange, toRange, suffix };
    });
    format3.serializeCoords = (coords2, precision) => {
      return coords2.map((c9, i6) => {
        let { fromRange, toRange, suffix } = coordFormats[i6];
        if (fromRange && toRange) {
          c9 = mapRange(fromRange, toRange, c9);
        }
        c9 = toPrecision(c9, precision);
        if (suffix) {
          c9 += suffix;
        }
        return c9;
      });
    };
  }
  return format3;
}
var XYZ_D65 = new ColorSpace({
  id: "xyz-d65",
  name: "XYZ D65",
  coords: {
    x: { name: "X" },
    y: { name: "Y" },
    z: { name: "Z" }
  },
  white: "D65",
  formats: {
    color: {
      ids: ["xyz-d65", "xyz"]
    }
  },
  aliases: ["xyz"]
});
var RGBColorSpace = class extends ColorSpace {
  /**
   * Creates a new RGB ColorSpace.
   * If coords are not specified, they will use the default RGB coords.
   * Instead of `fromBase()` and `toBase()` functions,
   * you can specify to/from XYZ matrices and have `toBase()` and `fromBase()` automatically generated.
   * @param {*} options - Same options as {@link ColorSpace} plus:
   * @param {number[][]} options.toXYZ_M - Matrix to convert to XYZ
   * @param {number[][]} options.fromXYZ_M - Matrix to convert from XYZ
   */
  constructor(options) {
    if (!options.coords) {
      options.coords = {
        r: {
          range: [0, 1],
          name: "Red"
        },
        g: {
          range: [0, 1],
          name: "Green"
        },
        b: {
          range: [0, 1],
          name: "Blue"
        }
      };
    }
    if (!options.base) {
      options.base = XYZ_D65;
    }
    if (options.toXYZ_M && options.fromXYZ_M) {
      options.toBase ??= (rgb2) => {
        let xyz = multiplyMatrices(options.toXYZ_M, rgb2);
        if (this.white !== this.base.white) {
          xyz = adapt$1(this.white, this.base.white, xyz);
        }
        return xyz;
      };
      options.fromBase ??= (xyz) => {
        xyz = adapt$1(this.base.white, this.white, xyz);
        return multiplyMatrices(options.fromXYZ_M, xyz);
      };
    }
    options.referred ??= "display";
    super(options);
  }
};
function parse2(str, { meta } = {}) {
  let env = { "str": String(str)?.trim() };
  hooks.run("parse-start", env);
  if (env.color) {
    return env.color;
  }
  env.parsed = parseFunction(env.str);
  if (env.parsed) {
    let name = env.parsed.name;
    if (name === "color") {
      let id2 = env.parsed.args.shift();
      let alpha = env.parsed.rawArgs.indexOf("/") > 0 ? env.parsed.args.pop() : 1;
      for (let space of ColorSpace.all) {
        let colorSpec = space.getFormat("color");
        if (colorSpec) {
          if (id2 === colorSpec.id || colorSpec.ids?.includes(id2)) {
            const coords = Object.keys(space.coords).map((_4, i6) => env.parsed.args[i6] || 0);
            if (meta) {
              meta.formatId = "color";
            }
            return { spaceId: space.id, coords, alpha };
          }
        }
      }
      let didYouMean = "";
      if (id2 in ColorSpace.registry) {
        let cssId = ColorSpace.registry[id2].formats?.functions?.color?.id;
        if (cssId) {
          didYouMean = `Did you mean color(${cssId})?`;
        }
      }
      throw new TypeError(`Cannot parse color(${id2}). ` + (didYouMean || "Missing a plugin?"));
    } else {
      for (let space of ColorSpace.all) {
        let format3 = space.getFormat(name);
        if (format3 && format3.type === "function") {
          let alpha = 1;
          if (format3.lastAlpha || last(env.parsed.args).alpha) {
            alpha = env.parsed.args.pop();
          }
          let coords = env.parsed.args;
          let types;
          if (format3.coordGrammar) {
            types = Object.entries(space.coords).map(([id2, coordMeta], i6) => {
              let coordGrammar2 = format3.coordGrammar[i6];
              let providedType = coords[i6]?.type;
              let type3 = coordGrammar2.find((c9) => c9 == providedType);
              if (!type3) {
                let coordName = coordMeta.name || id2;
                throw new TypeError(`${providedType} not allowed for ${coordName} in ${name}()`);
              }
              let fromRange = type3.range;
              if (providedType === "<percentage>") {
                fromRange ||= [0, 1];
              }
              let toRange = coordMeta.range || coordMeta.refRange;
              if (fromRange && toRange) {
                coords[i6] = mapRange(fromRange, toRange, coords[i6]);
              }
              return type3;
            });
          }
          if (meta) {
            Object.assign(meta, { formatId: format3.name, types });
          }
          return {
            spaceId: space.id,
            coords,
            alpha
          };
        }
      }
    }
  } else {
    for (let space of ColorSpace.all) {
      for (let formatId in space.formats) {
        let format3 = space.formats[formatId];
        if (format3.type !== "custom") {
          continue;
        }
        if (format3.test && !format3.test(env.str)) {
          continue;
        }
        let color3 = format3.parse(env.str);
        if (color3) {
          color3.alpha ??= 1;
          if (meta) {
            meta.formatId = formatId;
          }
          return color3;
        }
      }
    }
  }
  throw new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);
}
function getColor(color3) {
  if (!color3) {
    throw new TypeError("Empty color reference");
  }
  if (isString(color3)) {
    color3 = parse2(color3);
  }
  let space = color3.space || color3.spaceId;
  if (!(space instanceof ColorSpace)) {
    color3.space = ColorSpace.get(space);
  }
  if (color3.alpha === void 0) {
    color3.alpha = 1;
  }
  return color3;
}
function getAll(color3, space) {
  space = ColorSpace.get(space);
  return space.from(color3);
}
function get6(color3, prop) {
  let { space, index: index2 } = ColorSpace.resolveCoord(prop, color3.space);
  let coords = getAll(color3, space);
  return coords[index2];
}
function setAll(color3, space, coords) {
  space = ColorSpace.get(space);
  color3.coords = space.to(color3.space, coords);
  return color3;
}
function set3(color3, prop, value) {
  color3 = getColor(color3);
  if (arguments.length === 2 && type2(arguments[1]) === "object") {
    let object = arguments[1];
    for (let p5 in object) {
      set3(color3, p5, object[p5]);
    }
  } else {
    if (typeof value === "function") {
      value = value(get6(color3, prop));
    }
    let { space, index: index2 } = ColorSpace.resolveCoord(prop, color3.space);
    let coords = getAll(color3, space);
    coords[index2] = value;
    setAll(color3, space, coords);
  }
  return color3;
}
var XYZ_D50 = new ColorSpace({
  id: "xyz-d50",
  name: "XYZ D50",
  white: "D50",
  base: XYZ_D65,
  fromBase: (coords) => adapt$1(XYZ_D65.white, "D50", coords),
  toBase: (coords) => adapt$1("D50", XYZ_D65.white, coords),
  formats: {
    color: {}
  }
});
var \u03B5$3 = 216 / 24389;
var \u03B53$1 = 24 / 116;
var \u03BA$1 = 24389 / 27;
var white$1 = WHITES.D50;
var lab3 = new ColorSpace({
  id: "lab",
  name: "Lab",
  coords: {
    l: {
      refRange: [0, 100],
      name: "L"
    },
    a: {
      refRange: [-125, 125]
    },
    b: {
      refRange: [-125, 125]
    }
  },
  // Assuming XYZ is relative to D50, convert to CIE Lab
  // from CIE standard, which now defines these as a rational fraction
  white: white$1,
  base: XYZ_D50,
  // Convert D50-adapted XYX to Lab
  //  CIE 15.3:2004 section 8.2.1.1
  fromBase(XYZ) {
    let xyz = XYZ.map((value, i6) => value / white$1[i6]);
    let f4 = xyz.map((value) => value > \u03B5$3 ? Math.cbrt(value) : (\u03BA$1 * value + 16) / 116);
    return [
      116 * f4[1] - 16,
      // L
      500 * (f4[0] - f4[1]),
      // a
      200 * (f4[1] - f4[2])
      // b
    ];
  },
  // Convert Lab to D50-adapted XYZ
  // Same result as CIE 15.3:2004 Appendix D although the derivation is different
  // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
  toBase(Lab2) {
    let f4 = [];
    f4[1] = (Lab2[0] + 16) / 116;
    f4[0] = Lab2[1] / 500 + f4[1];
    f4[2] = f4[1] - Lab2[2] / 200;
    let xyz = [
      f4[0] > \u03B53$1 ? Math.pow(f4[0], 3) : (116 * f4[0] - 16) / \u03BA$1,
      Lab2[0] > 8 ? Math.pow((Lab2[0] + 16) / 116, 3) : Lab2[0] / \u03BA$1,
      f4[2] > \u03B53$1 ? Math.pow(f4[2], 3) : (116 * f4[2] - 16) / \u03BA$1
    ];
    return xyz.map((value, i6) => value * white$1[i6]);
  },
  formats: {
    "lab": {
      coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});
function constrain(angle) {
  return (angle % 360 + 360) % 360;
}
function adjust(arc, angles) {
  if (arc === "raw") {
    return angles;
  }
  let [a1, a22] = angles.map(constrain);
  let angleDiff = a22 - a1;
  if (arc === "increasing") {
    if (angleDiff < 0) {
      a22 += 360;
    }
  } else if (arc === "decreasing") {
    if (angleDiff > 0) {
      a1 += 360;
    }
  } else if (arc === "longer") {
    if (-180 < angleDiff && angleDiff < 180) {
      if (angleDiff > 0) {
        a1 += 360;
      } else {
        a22 += 360;
      }
    }
  } else if (arc === "shorter") {
    if (angleDiff > 180) {
      a1 += 360;
    } else if (angleDiff < -180) {
      a22 += 360;
    }
  }
  return [a1, a22];
}
var lch2 = new ColorSpace({
  id: "lch",
  name: "LCH",
  coords: {
    l: {
      refRange: [0, 100],
      name: "Lightness"
    },
    c: {
      refRange: [0, 150],
      name: "Chroma"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: lab3,
  fromBase(Lab2) {
    let [L4, a7, b5] = Lab2;
    let hue2;
    const \u03B52 = 0.02;
    if (Math.abs(a7) < \u03B52 && Math.abs(b5) < \u03B52) {
      hue2 = NaN;
    } else {
      hue2 = Math.atan2(b5, a7) * 180 / Math.PI;
    }
    return [
      L4,
      // L is still L
      Math.sqrt(a7 ** 2 + b5 ** 2),
      // Chroma
      constrain(hue2)
      // Hue, in degrees [0 to 360)
    ];
  },
  toBase(LCH) {
    let [Lightness, Chroma, Hue2] = LCH;
    if (Chroma < 0) {
      Chroma = 0;
    }
    if (isNaN(Hue2)) {
      Hue2 = 0;
    }
    return [
      Lightness,
      // L is still L
      Chroma * Math.cos(Hue2 * Math.PI / 180),
      // a
      Chroma * Math.sin(Hue2 * Math.PI / 180)
      // b
    ];
  },
  formats: {
    "lch": {
      coords: ["<number> | <percentage>", "<number> | <percentage>", "<number> | <angle>"]
    }
  }
});
var Gfactor = 25 ** 7;
var \u03C0$1 = Math.PI;
var r2d = 180 / \u03C0$1;
var d2r$1 = \u03C0$1 / 180;
function deltaE2000(color3, sample, { kL = 1, kC = 1, kH = 1 } = {}) {
  let [L1, a1, b1] = lab3.from(color3);
  let C1 = lch2.from(lab3, [L1, a1, b1])[1];
  let [L22, a22, b22] = lab3.from(sample);
  let C22 = lch2.from(lab3, [L22, a22, b22])[1];
  if (C1 < 0) {
    C1 = 0;
  }
  if (C22 < 0) {
    C22 = 0;
  }
  let Cbar = (C1 + C22) / 2;
  let C7 = Cbar ** 7;
  let G3 = 0.5 * (1 - Math.sqrt(C7 / (C7 + Gfactor)));
  let adash1 = (1 + G3) * a1;
  let adash2 = (1 + G3) * a22;
  let Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);
  let Cdash2 = Math.sqrt(adash2 ** 2 + b22 ** 2);
  let h1 = adash1 === 0 && b1 === 0 ? 0 : Math.atan2(b1, adash1);
  let h22 = adash2 === 0 && b22 === 0 ? 0 : Math.atan2(b22, adash2);
  if (h1 < 0) {
    h1 += 2 * \u03C0$1;
  }
  if (h22 < 0) {
    h22 += 2 * \u03C0$1;
  }
  h1 *= r2d;
  h22 *= r2d;
  let \u0394L = L22 - L1;
  let \u0394C = Cdash2 - Cdash1;
  let hdiff = h22 - h1;
  let hsum = h1 + h22;
  let habs = Math.abs(hdiff);
  let \u0394h;
  if (Cdash1 * Cdash2 === 0) {
    \u0394h = 0;
  } else if (habs <= 180) {
    \u0394h = hdiff;
  } else if (hdiff > 180) {
    \u0394h = hdiff - 360;
  } else if (hdiff < -180) {
    \u0394h = hdiff + 360;
  } else {
    console.log("the unthinkable has happened");
  }
  let \u0394H = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(\u0394h * d2r$1 / 2);
  let Ldash = (L1 + L22) / 2;
  let Cdash = (Cdash1 + Cdash2) / 2;
  let Cdash7 = Math.pow(Cdash, 7);
  let hdash;
  if (Cdash1 * Cdash2 === 0) {
    hdash = hsum;
  } else if (habs <= 180) {
    hdash = hsum / 2;
  } else if (hsum < 360) {
    hdash = (hsum + 360) / 2;
  } else {
    hdash = (hsum - 360) / 2;
  }
  let lsq = (Ldash - 50) ** 2;
  let SL = 1 + 0.015 * lsq / Math.sqrt(20 + lsq);
  let SC = 1 + 0.045 * Cdash;
  let T5 = 1;
  T5 -= 0.17 * Math.cos((hdash - 30) * d2r$1);
  T5 += 0.24 * Math.cos(2 * hdash * d2r$1);
  T5 += 0.32 * Math.cos((3 * hdash + 6) * d2r$1);
  T5 -= 0.2 * Math.cos((4 * hdash - 63) * d2r$1);
  let SH = 1 + 0.015 * Cdash * T5;
  let \u0394\u03B8 = 30 * Math.exp(-1 * ((hdash - 275) / 25) ** 2);
  let RC = 2 * Math.sqrt(Cdash7 / (Cdash7 + Gfactor));
  let RT = -1 * Math.sin(2 * \u0394\u03B8 * d2r$1) * RC;
  let dE = (\u0394L / (kL * SL)) ** 2;
  dE += (\u0394C / (kC * SC)) ** 2;
  dE += (\u0394H / (kH * SH)) ** 2;
  dE += RT * (\u0394C / (kC * SC)) * (\u0394H / (kH * SH));
  return Math.sqrt(dE);
}
var \u03B5$2 = 75e-6;
function inGamut(color3, space = color3.space, { epsilon: epsilon5 = \u03B5$2 } = {}) {
  color3 = getColor(color3);
  space = ColorSpace.get(space);
  let coords = color3.coords;
  if (space !== color3.space) {
    coords = space.from(color3);
  }
  return space.inGamut(coords, { epsilon: epsilon5 });
}
function clone2(color3) {
  return {
    space: color3.space,
    coords: color3.coords.slice(),
    alpha: color3.alpha
  };
}
function toGamut(color3, { method = defaults7.gamut_mapping, space = color3.space } = {}) {
  if (isString(arguments[1])) {
    space = arguments[1];
  }
  space = ColorSpace.get(space);
  if (inGamut(color3, space, { epsilon: 0 })) {
    return getColor(color3);
  }
  let spaceColor = to(color3, space);
  if (method !== "clip" && !inGamut(color3, space)) {
    let clipped = toGamut(clone2(spaceColor), { method: "clip", space });
    if (deltaE2000(color3, clipped) > 2) {
      let coordMeta = ColorSpace.resolveCoord(method);
      let mapSpace = coordMeta.space;
      let coordId = coordMeta.id;
      let mappedColor = to(spaceColor, mapSpace);
      let bounds = coordMeta.range || coordMeta.refRange;
      let min4 = bounds[0];
      let \u03B52 = 0.01;
      let low = min4;
      let high = get6(mappedColor, coordId);
      while (high - low > \u03B52) {
        let clipped2 = clone2(mappedColor);
        clipped2 = toGamut(clipped2, { space, method: "clip" });
        let deltaE2 = deltaE2000(mappedColor, clipped2);
        if (deltaE2 - 2 < \u03B52) {
          low = get6(mappedColor, coordId);
        } else {
          high = get6(mappedColor, coordId);
        }
        set3(mappedColor, coordId, (low + high) / 2);
      }
      spaceColor = to(mappedColor, space);
    } else {
      spaceColor = clipped;
    }
  }
  if (method === "clip" || !inGamut(spaceColor, space, { epsilon: 0 })) {
    let bounds = Object.values(space.coords).map((c9) => c9.range || []);
    spaceColor.coords = spaceColor.coords.map((c9, i6) => {
      let [min4, max4] = bounds[i6];
      if (min4 !== void 0) {
        c9 = Math.max(min4, c9);
      }
      if (max4 !== void 0) {
        c9 = Math.min(c9, max4);
      }
      return c9;
    });
  }
  if (space !== color3.space) {
    spaceColor = to(spaceColor, color3.space);
  }
  color3.coords = spaceColor.coords;
  return color3;
}
toGamut.returns = "color";
function to(color3, space, { inGamut: inGamut2 } = {}) {
  color3 = getColor(color3);
  space = ColorSpace.get(space);
  let coords = space.from(color3);
  let ret = { space, coords, alpha: color3.alpha };
  if (inGamut2) {
    ret = toGamut(ret);
  }
  return ret;
}
to.returns = "color";
function serialize(color3, {
  precision = defaults7.precision,
  format: format3 = "default",
  inGamut: inGamut$1 = true,
  ...customOptions
} = {}) {
  let ret;
  color3 = getColor(color3);
  let formatId = format3;
  format3 = color3.space.getFormat(format3) ?? color3.space.getFormat("default") ?? ColorSpace.DEFAULT_FORMAT;
  inGamut$1 ||= format3.toGamut;
  let coords = color3.coords;
  coords = coords.map((c9) => c9 ? c9 : 0);
  if (inGamut$1 && !inGamut(color3)) {
    coords = toGamut(clone2(color3), inGamut$1 === true ? void 0 : inGamut$1).coords;
  }
  if (format3.type === "custom") {
    customOptions.precision = precision;
    if (format3.serialize) {
      ret = format3.serialize(coords, color3.alpha, customOptions);
    } else {
      throw new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);
    }
  } else {
    let name = format3.name || "color";
    if (format3.serializeCoords) {
      coords = format3.serializeCoords(coords, precision);
    } else {
      if (precision !== null) {
        coords = coords.map((c9) => toPrecision(c9, precision));
      }
    }
    let args = [...coords];
    if (name === "color") {
      let cssId = format3.id || format3.ids?.[0] || color3.space.id;
      args.unshift(cssId);
    }
    let alpha = color3.alpha;
    if (precision !== null) {
      alpha = toPrecision(alpha, precision);
    }
    let strAlpha = color3.alpha < 1 && !format3.noAlpha ? `${format3.commas ? "," : " /"} ${alpha}` : "";
    ret = `${name}(${args.join(format3.commas ? ", " : " ")}${strAlpha})`;
  }
  return ret;
}
var toXYZ_M$5 = [
  [0.6369580483012914, 0.14461690358620832, 0.1688809751641721],
  [0.2627002120112671, 0.6779980715188708, 0.05930171646986196],
  [0, 0.028072693049087428, 1.060985057710791]
];
var fromXYZ_M$5 = [
  [1.716651187971268, -0.355670783776392, -0.25336628137366],
  [-0.666684351832489, 1.616481236634939, 0.0157685458139111],
  [0.017639857445311, -0.042770613257809, 0.942103121235474]
];
var REC2020Linear = new RGBColorSpace({
  id: "rec2020-linear",
  name: "Linear REC.2020",
  white: "D65",
  toXYZ_M: toXYZ_M$5,
  fromXYZ_M: fromXYZ_M$5,
  formats: {
    color: {}
  }
});
var \u03B1 = 1.09929682680944;
var \u03B2 = 0.018053968510807;
var REC2020 = new RGBColorSpace({
  id: "rec2020",
  name: "REC.2020",
  base: REC2020Linear,
  // Non-linear transfer function from Rec. ITU-R BT.2020-2 table 4
  toBase(RGB) {
    return RGB.map(function(val) {
      if (val < \u03B2 * 4.5) {
        return val / 4.5;
      }
      return Math.pow((val + \u03B1 - 1) / \u03B1, 1 / 0.45);
    });
  },
  fromBase(RGB) {
    return RGB.map(function(val) {
      if (val >= \u03B2) {
        return \u03B1 * Math.pow(val, 0.45) - (\u03B1 - 1);
      }
      return 4.5 * val;
    });
  },
  formats: {
    color: {}
  }
});
var toXYZ_M$4 = [
  [0.4865709486482162, 0.26566769316909306, 0.1982172852343625],
  [0.2289745640697488, 0.6917385218365064, 0.079286914093745],
  [0, 0.04511338185890264, 1.043944368900976]
];
var fromXYZ_M$4 = [
  [2.493496911941425, -0.9313836179191239, -0.40271078445071684],
  [-0.8294889695615747, 1.7626640603183463, 0.023624685841943577],
  [0.03584583024378447, -0.07617238926804182, 0.9568845240076872]
];
var P3Linear = new RGBColorSpace({
  id: "p3-linear",
  name: "Linear P3",
  white: "D65",
  toXYZ_M: toXYZ_M$4,
  fromXYZ_M: fromXYZ_M$4
});
var toXYZ_M$3 = [
  [0.41239079926595934, 0.357584339383878, 0.1804807884018343],
  [0.21263900587151027, 0.715168678767756, 0.07219231536073371],
  [0.01933081871559182, 0.11919477979462598, 0.9505321522496607]
];
var fromXYZ_M$3 = [
  [3.2409699419045226, -1.537383177570094, -0.4986107602930034],
  [-0.9692436362808796, 1.8759675015077202, 0.04155505740717559],
  [0.05563007969699366, -0.20397695888897652, 1.0569715142428786]
];
var sRGBLinear = new RGBColorSpace({
  id: "srgb-linear",
  name: "Linear sRGB",
  white: "D65",
  toXYZ_M: toXYZ_M$3,
  fromXYZ_M: fromXYZ_M$3,
  formats: {
    color: {}
  }
});
var KEYWORDS = {
  "aliceblue": [240 / 255, 248 / 255, 1],
  "antiquewhite": [250 / 255, 235 / 255, 215 / 255],
  "aqua": [0, 1, 1],
  "aquamarine": [127 / 255, 1, 212 / 255],
  "azure": [240 / 255, 1, 1],
  "beige": [245 / 255, 245 / 255, 220 / 255],
  "bisque": [1, 228 / 255, 196 / 255],
  "black": [0, 0, 0],
  "blanchedalmond": [1, 235 / 255, 205 / 255],
  "blue": [0, 0, 1],
  "blueviolet": [138 / 255, 43 / 255, 226 / 255],
  "brown": [165 / 255, 42 / 255, 42 / 255],
  "burlywood": [222 / 255, 184 / 255, 135 / 255],
  "cadetblue": [95 / 255, 158 / 255, 160 / 255],
  "chartreuse": [127 / 255, 1, 0],
  "chocolate": [210 / 255, 105 / 255, 30 / 255],
  "coral": [1, 127 / 255, 80 / 255],
  "cornflowerblue": [100 / 255, 149 / 255, 237 / 255],
  "cornsilk": [1, 248 / 255, 220 / 255],
  "crimson": [220 / 255, 20 / 255, 60 / 255],
  "cyan": [0, 1, 1],
  "darkblue": [0, 0, 139 / 255],
  "darkcyan": [0, 139 / 255, 139 / 255],
  "darkgoldenrod": [184 / 255, 134 / 255, 11 / 255],
  "darkgray": [169 / 255, 169 / 255, 169 / 255],
  "darkgreen": [0, 100 / 255, 0],
  "darkgrey": [169 / 255, 169 / 255, 169 / 255],
  "darkkhaki": [189 / 255, 183 / 255, 107 / 255],
  "darkmagenta": [139 / 255, 0, 139 / 255],
  "darkolivegreen": [85 / 255, 107 / 255, 47 / 255],
  "darkorange": [1, 140 / 255, 0],
  "darkorchid": [153 / 255, 50 / 255, 204 / 255],
  "darkred": [139 / 255, 0, 0],
  "darksalmon": [233 / 255, 150 / 255, 122 / 255],
  "darkseagreen": [143 / 255, 188 / 255, 143 / 255],
  "darkslateblue": [72 / 255, 61 / 255, 139 / 255],
  "darkslategray": [47 / 255, 79 / 255, 79 / 255],
  "darkslategrey": [47 / 255, 79 / 255, 79 / 255],
  "darkturquoise": [0, 206 / 255, 209 / 255],
  "darkviolet": [148 / 255, 0, 211 / 255],
  "deeppink": [1, 20 / 255, 147 / 255],
  "deepskyblue": [0, 191 / 255, 1],
  "dimgray": [105 / 255, 105 / 255, 105 / 255],
  "dimgrey": [105 / 255, 105 / 255, 105 / 255],
  "dodgerblue": [30 / 255, 144 / 255, 1],
  "firebrick": [178 / 255, 34 / 255, 34 / 255],
  "floralwhite": [1, 250 / 255, 240 / 255],
  "forestgreen": [34 / 255, 139 / 255, 34 / 255],
  "fuchsia": [1, 0, 1],
  "gainsboro": [220 / 255, 220 / 255, 220 / 255],
  "ghostwhite": [248 / 255, 248 / 255, 1],
  "gold": [1, 215 / 255, 0],
  "goldenrod": [218 / 255, 165 / 255, 32 / 255],
  "gray": [128 / 255, 128 / 255, 128 / 255],
  "green": [0, 128 / 255, 0],
  "greenyellow": [173 / 255, 1, 47 / 255],
  "grey": [128 / 255, 128 / 255, 128 / 255],
  "honeydew": [240 / 255, 1, 240 / 255],
  "hotpink": [1, 105 / 255, 180 / 255],
  "indianred": [205 / 255, 92 / 255, 92 / 255],
  "indigo": [75 / 255, 0, 130 / 255],
  "ivory": [1, 1, 240 / 255],
  "khaki": [240 / 255, 230 / 255, 140 / 255],
  "lavender": [230 / 255, 230 / 255, 250 / 255],
  "lavenderblush": [1, 240 / 255, 245 / 255],
  "lawngreen": [124 / 255, 252 / 255, 0],
  "lemonchiffon": [1, 250 / 255, 205 / 255],
  "lightblue": [173 / 255, 216 / 255, 230 / 255],
  "lightcoral": [240 / 255, 128 / 255, 128 / 255],
  "lightcyan": [224 / 255, 1, 1],
  "lightgoldenrodyellow": [250 / 255, 250 / 255, 210 / 255],
  "lightgray": [211 / 255, 211 / 255, 211 / 255],
  "lightgreen": [144 / 255, 238 / 255, 144 / 255],
  "lightgrey": [211 / 255, 211 / 255, 211 / 255],
  "lightpink": [1, 182 / 255, 193 / 255],
  "lightsalmon": [1, 160 / 255, 122 / 255],
  "lightseagreen": [32 / 255, 178 / 255, 170 / 255],
  "lightskyblue": [135 / 255, 206 / 255, 250 / 255],
  "lightslategray": [119 / 255, 136 / 255, 153 / 255],
  "lightslategrey": [119 / 255, 136 / 255, 153 / 255],
  "lightsteelblue": [176 / 255, 196 / 255, 222 / 255],
  "lightyellow": [1, 1, 224 / 255],
  "lime": [0, 1, 0],
  "limegreen": [50 / 255, 205 / 255, 50 / 255],
  "linen": [250 / 255, 240 / 255, 230 / 255],
  "magenta": [1, 0, 1],
  "maroon": [128 / 255, 0, 0],
  "mediumaquamarine": [102 / 255, 205 / 255, 170 / 255],
  "mediumblue": [0, 0, 205 / 255],
  "mediumorchid": [186 / 255, 85 / 255, 211 / 255],
  "mediumpurple": [147 / 255, 112 / 255, 219 / 255],
  "mediumseagreen": [60 / 255, 179 / 255, 113 / 255],
  "mediumslateblue": [123 / 255, 104 / 255, 238 / 255],
  "mediumspringgreen": [0, 250 / 255, 154 / 255],
  "mediumturquoise": [72 / 255, 209 / 255, 204 / 255],
  "mediumvioletred": [199 / 255, 21 / 255, 133 / 255],
  "midnightblue": [25 / 255, 25 / 255, 112 / 255],
  "mintcream": [245 / 255, 1, 250 / 255],
  "mistyrose": [1, 228 / 255, 225 / 255],
  "moccasin": [1, 228 / 255, 181 / 255],
  "navajowhite": [1, 222 / 255, 173 / 255],
  "navy": [0, 0, 128 / 255],
  "oldlace": [253 / 255, 245 / 255, 230 / 255],
  "olive": [128 / 255, 128 / 255, 0],
  "olivedrab": [107 / 255, 142 / 255, 35 / 255],
  "orange": [1, 165 / 255, 0],
  "orangered": [1, 69 / 255, 0],
  "orchid": [218 / 255, 112 / 255, 214 / 255],
  "palegoldenrod": [238 / 255, 232 / 255, 170 / 255],
  "palegreen": [152 / 255, 251 / 255, 152 / 255],
  "paleturquoise": [175 / 255, 238 / 255, 238 / 255],
  "palevioletred": [219 / 255, 112 / 255, 147 / 255],
  "papayawhip": [1, 239 / 255, 213 / 255],
  "peachpuff": [1, 218 / 255, 185 / 255],
  "peru": [205 / 255, 133 / 255, 63 / 255],
  "pink": [1, 192 / 255, 203 / 255],
  "plum": [221 / 255, 160 / 255, 221 / 255],
  "powderblue": [176 / 255, 224 / 255, 230 / 255],
  "purple": [128 / 255, 0, 128 / 255],
  "rebeccapurple": [102 / 255, 51 / 255, 153 / 255],
  "red": [1, 0, 0],
  "rosybrown": [188 / 255, 143 / 255, 143 / 255],
  "royalblue": [65 / 255, 105 / 255, 225 / 255],
  "saddlebrown": [139 / 255, 69 / 255, 19 / 255],
  "salmon": [250 / 255, 128 / 255, 114 / 255],
  "sandybrown": [244 / 255, 164 / 255, 96 / 255],
  "seagreen": [46 / 255, 139 / 255, 87 / 255],
  "seashell": [1, 245 / 255, 238 / 255],
  "sienna": [160 / 255, 82 / 255, 45 / 255],
  "silver": [192 / 255, 192 / 255, 192 / 255],
  "skyblue": [135 / 255, 206 / 255, 235 / 255],
  "slateblue": [106 / 255, 90 / 255, 205 / 255],
  "slategray": [112 / 255, 128 / 255, 144 / 255],
  "slategrey": [112 / 255, 128 / 255, 144 / 255],
  "snow": [1, 250 / 255, 250 / 255],
  "springgreen": [0, 1, 127 / 255],
  "steelblue": [70 / 255, 130 / 255, 180 / 255],
  "tan": [210 / 255, 180 / 255, 140 / 255],
  "teal": [0, 128 / 255, 128 / 255],
  "thistle": [216 / 255, 191 / 255, 216 / 255],
  "tomato": [1, 99 / 255, 71 / 255],
  "turquoise": [64 / 255, 224 / 255, 208 / 255],
  "violet": [238 / 255, 130 / 255, 238 / 255],
  "wheat": [245 / 255, 222 / 255, 179 / 255],
  "white": [1, 1, 1],
  "whitesmoke": [245 / 255, 245 / 255, 245 / 255],
  "yellow": [1, 1, 0],
  "yellowgreen": [154 / 255, 205 / 255, 50 / 255]
};
var coordGrammar = Array(3).fill("<percentage> | <number>[0, 255]");
var coordGrammarNumber = Array(3).fill("<number>[0, 255]");
var sRGB = new RGBColorSpace({
  id: "srgb",
  name: "sRGB",
  base: sRGBLinear,
  fromBase: (rgb2) => {
    return rgb2.map((val) => {
      let sign3 = val < 0 ? -1 : 1;
      let abs3 = val * sign3;
      if (abs3 > 31308e-7) {
        return sign3 * (1.055 * abs3 ** (1 / 2.4) - 0.055);
      }
      return 12.92 * val;
    });
  },
  toBase: (rgb2) => {
    return rgb2.map((val) => {
      let sign3 = val < 0 ? -1 : 1;
      let abs3 = val * sign3;
      if (abs3 < 0.04045) {
        return val / 12.92;
      }
      return sign3 * ((abs3 + 0.055) / 1.055) ** 2.4;
    });
  },
  formats: {
    "rgb": {
      coords: coordGrammar
    },
    "rgb_number": {
      name: "rgb",
      commas: true,
      coords: coordGrammarNumber,
      noAlpha: true
    },
    "color": {
      /* use defaults */
    },
    "rgba": {
      coords: coordGrammar,
      commas: true,
      lastAlpha: true
    },
    "rgba_number": {
      name: "rgba",
      commas: true,
      coords: coordGrammarNumber
    },
    "hex": {
      type: "custom",
      toGamut: true,
      test: (str) => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),
      parse(str) {
        if (str.length <= 5) {
          str = str.replace(/[a-f0-9]/gi, "$&$&");
        }
        let rgba2 = [];
        str.replace(/[a-f0-9]{2}/gi, (component) => {
          rgba2.push(parseInt(component, 16) / 255);
        });
        return {
          spaceId: "srgb",
          coords: rgba2.slice(0, 3),
          alpha: rgba2.slice(3)[0]
        };
      },
      serialize: (coords, alpha, {
        collapse = true
        // collapse to 3-4 digit hex when possible?
      } = {}) => {
        if (alpha < 1) {
          coords.push(alpha);
        }
        coords = coords.map((c9) => Math.round(c9 * 255));
        let collapsible = collapse && coords.every((c9) => c9 % 17 === 0);
        let hex2 = coords.map((c9) => {
          if (collapsible) {
            return (c9 / 17).toString(16);
          }
          return c9.toString(16).padStart(2, "0");
        }).join("");
        return "#" + hex2;
      }
    },
    "keyword": {
      type: "custom",
      test: (str) => /^[a-z]+$/i.test(str),
      parse(str) {
        str = str.toLowerCase();
        let ret = { spaceId: "srgb", coords: null, alpha: 1 };
        if (str === "transparent") {
          ret.coords = KEYWORDS.black;
          ret.alpha = 0;
        } else {
          ret.coords = KEYWORDS[str];
        }
        if (ret.coords) {
          return ret;
        }
      }
    }
  }
});
var P32 = new RGBColorSpace({
  id: "p3",
  name: "P3",
  base: P3Linear,
  // Gamma encoding/decoding is the same as sRGB
  fromBase: sRGB.fromBase,
  toBase: sRGB.toBase,
  formats: {
    color: {
      id: "display-p3"
    }
  }
});
defaults7.display_space = sRGB;
if (typeof CSS !== "undefined" && CSS.supports) {
  for (let space of [lab3, REC2020, P32]) {
    let coords = space.getMinCoords();
    let color3 = { space, coords, alpha: 1 };
    let str = serialize(color3);
    if (CSS.supports("color", str)) {
      defaults7.display_space = space;
      break;
    }
  }
}
function display(color3, { space = defaults7.display_space, ...options } = {}) {
  let ret = serialize(color3, options);
  if (typeof CSS === "undefined" || CSS.supports("color", ret) || !defaults7.display_space) {
    ret = new String(ret);
    ret.color = color3;
  } else {
    let fallbackColor = to(color3, space);
    ret = new String(serialize(fallbackColor, options));
    ret.color = fallbackColor;
  }
  return ret;
}
function distance(color1, color22, space = "lab") {
  space = ColorSpace.get(space);
  let coords1 = space.from(color1);
  let coords2 = space.from(color22);
  return Math.sqrt(coords1.reduce((acc, c12, i6) => {
    let c23 = coords2[i6];
    if (isNaN(c12) || isNaN(c23)) {
      return acc;
    }
    return acc + (c23 - c12) ** 2;
  }, 0));
}
function equals(color1, color22) {
  color1 = getColor(color1);
  color22 = getColor(color22);
  return color1.space === color22.space && color1.alpha === color22.alpha && color1.coords.every((c9, i6) => c9 === color22.coords[i6]);
}
function getLuminance2(color3) {
  return get6(color3, [XYZ_D65, "y"]);
}
function setLuminance(color3, value) {
  set3(color3, [XYZ_D65, "y"], value);
}
function register$2(Color3) {
  Object.defineProperty(Color3.prototype, "luminance", {
    get() {
      return getLuminance2(this);
    },
    set(value) {
      setLuminance(this, value);
    }
  });
}
var luminance = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  getLuminance: getLuminance2,
  register: register$2,
  setLuminance
});
function contrastWCAG21(color1, color22) {
  color1 = getColor(color1);
  color22 = getColor(color22);
  let Y12 = Math.max(getLuminance2(color1), 0);
  let Y23 = Math.max(getLuminance2(color22), 0);
  if (Y23 > Y12) {
    [Y12, Y23] = [Y23, Y12];
  }
  return (Y12 + 0.05) / (Y23 + 0.05);
}
var normBG = 0.56;
var normTXT = 0.57;
var revTXT = 0.62;
var revBG = 0.65;
var blkThrs = 0.022;
var blkClmp = 1.414;
var loClip = 0.1;
var deltaYmin = 5e-4;
var scaleBoW = 1.14;
var loBoWoffset = 0.027;
var scaleWoB = 1.14;
function fclamp(Y3) {
  if (Y3 >= blkThrs) {
    return Y3;
  }
  return Y3 + (blkThrs - Y3) ** blkClmp;
}
function linearize(val) {
  let sign3 = val < 0 ? -1 : 1;
  let abs3 = Math.abs(val);
  return sign3 * Math.pow(abs3, 2.4);
}
function contrastAPCA(background, foreground) {
  foreground = getColor(foreground);
  background = getColor(background);
  let S4;
  let C5;
  let Sapc;
  let R3, G3, B6;
  foreground = to(foreground, "srgb");
  [R3, G3, B6] = foreground.coords;
  let lumTxt = linearize(R3) * 0.2126729 + linearize(G3) * 0.7151522 + linearize(B6) * 0.072175;
  background = to(background, "srgb");
  [R3, G3, B6] = background.coords;
  let lumBg = linearize(R3) * 0.2126729 + linearize(G3) * 0.7151522 + linearize(B6) * 0.072175;
  let Ytxt = fclamp(lumTxt);
  let Ybg = fclamp(lumBg);
  let BoW = Ybg > Ytxt;
  if (Math.abs(Ybg - Ytxt) < deltaYmin) {
    C5 = 0;
  } else {
    if (BoW) {
      S4 = Ybg ** normBG - Ytxt ** normTXT;
      C5 = S4 * scaleBoW;
    } else {
      S4 = Ybg ** revBG - Ytxt ** revTXT;
      C5 = S4 * scaleWoB;
    }
  }
  if (Math.abs(C5) < loClip) {
    Sapc = 0;
  } else if (C5 > 0) {
    Sapc = C5 - loBoWoffset;
  } else {
    Sapc = C5 + loBoWoffset;
  }
  return Sapc * 100;
}
function contrastMichelson(color1, color22) {
  color1 = getColor(color1);
  color22 = getColor(color22);
  let Y12 = Math.max(getLuminance2(color1), 0);
  let Y23 = Math.max(getLuminance2(color22), 0);
  if (Y23 > Y12) {
    [Y12, Y23] = [Y23, Y12];
  }
  let denom = Y12 + Y23;
  return denom === 0 ? 0 : (Y12 - Y23) / denom;
}
var max3 = 5e4;
function contrastWeber(color1, color22) {
  color1 = getColor(color1);
  color22 = getColor(color22);
  let Y12 = Math.max(getLuminance2(color1), 0);
  let Y23 = Math.max(getLuminance2(color22), 0);
  if (Y23 > Y12) {
    [Y12, Y23] = [Y23, Y12];
  }
  return Y23 === 0 ? max3 : (Y12 - Y23) / Y23;
}
function contrastLstar(color1, color22) {
  color1 = getColor(color1);
  color22 = getColor(color22);
  let L1 = get6(color1, [lab3, "l"]);
  let L22 = get6(color22, [lab3, "l"]);
  return Math.abs(L1 - L22);
}
var \u03B5$1 = 216 / 24389;
var \u03B53 = 24 / 116;
var \u03BA = 24389 / 27;
var white = WHITES.D65;
var lab_d65 = new ColorSpace({
  id: "lab-d65",
  name: "Lab D65",
  coords: {
    l: {
      refRange: [0, 100],
      name: "L"
    },
    a: {
      refRange: [-125, 125]
    },
    b: {
      refRange: [-125, 125]
    }
  },
  // Assuming XYZ is relative to D65, convert to CIE Lab
  // from CIE standard, which now defines these as a rational fraction
  white,
  base: XYZ_D65,
  // Convert D65-adapted XYZ to Lab
  //  CIE 15.3:2004 section 8.2.1.1
  fromBase(XYZ) {
    let xyz = XYZ.map((value, i6) => value / white[i6]);
    let f4 = xyz.map((value) => value > \u03B5$1 ? Math.cbrt(value) : (\u03BA * value + 16) / 116);
    return [
      116 * f4[1] - 16,
      // L
      500 * (f4[0] - f4[1]),
      // a
      200 * (f4[1] - f4[2])
      // b
    ];
  },
  // Convert Lab to D65-adapted XYZ
  // Same result as CIE 15.3:2004 Appendix D although the derivation is different
  // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
  toBase(Lab2) {
    let f4 = [];
    f4[1] = (Lab2[0] + 16) / 116;
    f4[0] = Lab2[1] / 500 + f4[1];
    f4[2] = f4[1] - Lab2[2] / 200;
    let xyz = [
      f4[0] > \u03B53 ? Math.pow(f4[0], 3) : (116 * f4[0] - 16) / \u03BA,
      Lab2[0] > 8 ? Math.pow((Lab2[0] + 16) / 116, 3) : Lab2[0] / \u03BA,
      f4[2] > \u03B53 ? Math.pow(f4[2], 3) : (116 * f4[2] - 16) / \u03BA
    ];
    return xyz.map((value, i6) => value * white[i6]);
  },
  formats: {
    "lab-d65": {
      coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});
var phi = Math.pow(5, 0.5) * 0.5 + 0.5;
function contrastDeltaPhi(color1, color22) {
  color1 = getColor(color1);
  color22 = getColor(color22);
  let Lstr1 = get6(color1, [lab_d65, "l"]);
  let Lstr2 = get6(color22, [lab_d65, "l"]);
  let deltaPhiStar = Math.abs(Math.pow(Lstr1, phi) - Math.pow(Lstr2, phi));
  let contrast2 = Math.pow(deltaPhiStar, 1 / phi) * Math.SQRT2 - 40;
  return contrast2 < 7.5 ? 0 : contrast2;
}
var contrastMethods = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  contrastAPCA,
  contrastDeltaPhi,
  contrastLstar,
  contrastMichelson,
  contrastWCAG21,
  contrastWeber
});
function contrast(background, foreground, o8 = {}) {
  if (isString(o8)) {
    o8 = { algorithm: o8 };
  }
  let { algorithm, ...rest } = o8;
  if (!algorithm) {
    let algorithms = Object.keys(contrastMethods).map((a7) => a7.replace(/^contrast/, "")).join(", ");
    throw new TypeError(`contrast() function needs a contrast algorithm. Please specify one of: ${algorithms}`);
  }
  background = getColor(background);
  foreground = getColor(foreground);
  for (let a7 in contrastMethods) {
    if ("contrast" + algorithm.toLowerCase() === a7.toLowerCase()) {
      return contrastMethods[a7](background, foreground, rest);
    }
  }
  throw new TypeError(`Unknown contrast algorithm: ${algorithm}`);
}
function uv(color3) {
  let [X3, Y3, Z3] = getAll(color3, XYZ_D65);
  let denom = X3 + 15 * Y3 + 3 * Z3;
  return [4 * X3 / denom, 9 * Y3 / denom];
}
function xy(color3) {
  let [X3, Y3, Z3] = getAll(color3, XYZ_D65);
  let sum2 = X3 + Y3 + Z3;
  return [X3 / sum2, Y3 / sum2];
}
function register$1(Color3) {
  Object.defineProperty(Color3.prototype, "uv", {
    get() {
      return uv(this);
    }
  });
  Object.defineProperty(Color3.prototype, "xy", {
    get() {
      return xy(this);
    }
  });
}
var chromaticity = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  register: register$1,
  uv,
  xy
});
function deltaE76(color3, sample) {
  return distance(color3, sample, "lab");
}
var \u03C0 = Math.PI;
var d2r = \u03C0 / 180;
function deltaECMC(color3, sample, { l: l7 = 2, c: c9 = 1 } = {}) {
  let [L1, a1, b1] = lab3.from(color3);
  let [, C1, H1] = lch2.from(lab3, [L1, a1, b1]);
  let [L22, a22, b22] = lab3.from(sample);
  let C22 = lch2.from(lab3, [L22, a22, b22])[1];
  if (C1 < 0) {
    C1 = 0;
  }
  if (C22 < 0) {
    C22 = 0;
  }
  let \u0394L = L1 - L22;
  let \u0394C = C1 - C22;
  let \u0394a = a1 - a22;
  let \u0394b = b1 - b22;
  let H22 = \u0394a ** 2 + \u0394b ** 2 - \u0394C ** 2;
  let SL = 0.511;
  if (L1 >= 16) {
    SL = 0.040975 * L1 / (1 + 0.01765 * L1);
  }
  let SC = 0.0638 * C1 / (1 + 0.0131 * C1) + 0.638;
  let T5;
  if (Number.isNaN(H1)) {
    H1 = 0;
  }
  if (H1 >= 164 && H1 <= 345) {
    T5 = 0.56 + Math.abs(0.2 * Math.cos((H1 + 168) * d2r));
  } else {
    T5 = 0.36 + Math.abs(0.4 * Math.cos((H1 + 35) * d2r));
  }
  let C42 = Math.pow(C1, 4);
  let F4 = Math.sqrt(C42 / (C42 + 1900));
  let SH = SC * (F4 * T5 + 1 - F4);
  let dE = (\u0394L / (l7 * SL)) ** 2;
  dE += (\u0394C / (c9 * SC)) ** 2;
  dE += H22 / SH ** 2;
  return Math.sqrt(dE);
}
var Yw$1 = 203;
var XYZ_Abs_D65 = new ColorSpace({
  // Absolute CIE XYZ, with a D65 whitepoint,
  // as used in most HDR colorspaces as a starting point.
  // SDR spaces are converted per BT.2048
  // so that diffuse, media white is 203 cd/m
  id: "xyz-abs-d65",
  name: "Absolute XYZ D65",
  coords: {
    x: {
      refRange: [0, 9504.7],
      name: "Xa"
    },
    y: {
      refRange: [0, 1e4],
      name: "Ya"
    },
    z: {
      refRange: [0, 10888.3],
      name: "Za"
    }
  },
  base: XYZ_D65,
  fromBase(XYZ) {
    return XYZ.map((v4) => Math.max(v4 * Yw$1, 0));
  },
  toBase(AbsXYZ) {
    return AbsXYZ.map((v4) => Math.max(v4 / Yw$1, 0));
  }
});
var b$1 = 1.15;
var g5 = 0.66;
var n$1 = 2610 / 2 ** 14;
var ninv$1 = 2 ** 14 / 2610;
var c1$2 = 3424 / 2 ** 12;
var c2$2 = 2413 / 2 ** 7;
var c3$2 = 2392 / 2 ** 7;
var p4 = 1.7 * 2523 / 2 ** 5;
var pinv = 2 ** 5 / (1.7 * 2523);
var d5 = -0.56;
var d0 = 16295499532821565e-27;
var XYZtoCone_M = [
  [0.41478972, 0.579999, 0.014648],
  [-0.20151, 1.120649, 0.0531008],
  [-0.0166008, 0.2648, 0.6684799]
];
var ConetoXYZ_M = [
  [1.9242264357876067, -1.0047923125953657, 0.037651404030618],
  [0.35031676209499907, 0.7264811939316552, -0.06538442294808501],
  [-0.09098281098284752, -0.3127282905230739, 1.5227665613052603]
];
var ConetoIab_M = [
  [0.5, 0.5, 0],
  [3.524, -4.066708, 0.542708],
  [0.199076, 1.096799, -1.295875]
];
var IabtoCone_M = [
  [1, 0.1386050432715393, 0.05804731615611886],
  [0.9999999999999999, -0.1386050432715393, -0.05804731615611886],
  [0.9999999999999998, -0.09601924202631895, -0.8118918960560388]
];
var Jzazbz = new ColorSpace({
  id: "jzazbz",
  name: "Jzazbz",
  coords: {
    jz: {
      refRange: [0, 1],
      name: "Jz"
    },
    az: {
      refRange: [-0.5, 0.5]
    },
    bz: {
      refRange: [-0.5, 0.5]
    }
  },
  base: XYZ_Abs_D65,
  fromBase(XYZ) {
    let [Xa, Ya, Za] = XYZ;
    let Xm = b$1 * Xa - (b$1 - 1) * Za;
    let Ym = g5 * Ya - (g5 - 1) * Xa;
    let LMS = multiplyMatrices(XYZtoCone_M, [Xm, Ym, Za]);
    let PQLMS = LMS.map(function(val) {
      let num = c1$2 + c2$2 * (val / 1e4) ** n$1;
      let denom = 1 + c3$2 * (val / 1e4) ** n$1;
      return (num / denom) ** p4;
    });
    let [Iz, az, bz] = multiplyMatrices(ConetoIab_M, PQLMS);
    let Jz = (1 + d5) * Iz / (1 + d5 * Iz) - d0;
    return [Jz, az, bz];
  },
  toBase(Jzazbz2) {
    let [Jz, az, bz] = Jzazbz2;
    let Iz = (Jz + d0) / (1 + d5 - d5 * (Jz + d0));
    let PQLMS = multiplyMatrices(IabtoCone_M, [Iz, az, bz]);
    let LMS = PQLMS.map(function(val) {
      let num = c1$2 - val ** pinv;
      let denom = c3$2 * val ** pinv - c2$2;
      let x6 = 1e4 * (num / denom) ** ninv$1;
      return x6;
    });
    let [Xm, Ym, Za] = multiplyMatrices(ConetoXYZ_M, LMS);
    let Xa = (Xm + (b$1 - 1) * Za) / b$1;
    let Ya = (Ym + (g5 - 1) * Xa) / g5;
    return [Xa, Ya, Za];
  },
  formats: {
    // https://drafts.csswg.org/css-color-hdr/#Jzazbz
    "color": {}
  }
});
var jzczhz = new ColorSpace({
  id: "jzczhz",
  name: "JzCzHz",
  coords: {
    jz: {
      refRange: [0, 1],
      name: "Jz"
    },
    cz: {
      refRange: [0, 1],
      name: "Chroma"
    },
    hz: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: Jzazbz,
  fromBase(jzazbz) {
    let [Jz, az, bz] = jzazbz;
    let hue2;
    const \u03B52 = 2e-4;
    if (Math.abs(az) < \u03B52 && Math.abs(bz) < \u03B52) {
      hue2 = NaN;
    } else {
      hue2 = Math.atan2(bz, az) * 180 / Math.PI;
    }
    return [
      Jz,
      // Jz is still Jz
      Math.sqrt(az ** 2 + bz ** 2),
      // Chroma
      constrain(hue2)
      // Hue, in degrees [0 to 360)
    ];
  },
  toBase(jzczhz2) {
    return [
      jzczhz2[0],
      // Jz is still Jz
      jzczhz2[1] * Math.cos(jzczhz2[2] * Math.PI / 180),
      // az
      jzczhz2[1] * Math.sin(jzczhz2[2] * Math.PI / 180)
      // bz
    ];
  },
  formats: {
    color: {}
  }
});
function deltaEJz(color3, sample) {
  let [Jz1, Cz1, Hz1] = jzczhz.from(color3);
  let [Jz2, Cz2, Hz2] = jzczhz.from(sample);
  let \u0394J = Jz1 - Jz2;
  let \u0394C = Cz1 - Cz2;
  if (Number.isNaN(Hz1) && Number.isNaN(Hz2)) {
    Hz1 = 0;
    Hz2 = 0;
  } else if (Number.isNaN(Hz1)) {
    Hz1 = Hz2;
  } else if (Number.isNaN(Hz2)) {
    Hz2 = Hz1;
  }
  let \u0394h = Hz1 - Hz2;
  let \u0394H = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin(\u0394h / 2 * (Math.PI / 180));
  return Math.sqrt(\u0394J ** 2 + \u0394C ** 2 + \u0394H ** 2);
}
var c1$1 = 3424 / 4096;
var c2$1 = 2413 / 128;
var c3$1 = 2392 / 128;
var m1 = 2610 / 16384;
var m22 = 2523 / 32;
var im1 = 16384 / 2610;
var im2 = 32 / 2523;
var XYZtoLMS_M$1 = [
  [0.3592, 0.6976, -0.0358],
  [-0.1922, 1.1004, 0.0755],
  [7e-3, 0.0749, 0.8434]
];
var LMStoIPT_M = [
  [2048 / 4096, 2048 / 4096, 0],
  [6610 / 4096, -13613 / 4096, 7003 / 4096],
  [17933 / 4096, -17390 / 4096, -543 / 4096]
];
var IPTtoLMS_M = [
  [0.9999888965628402, 0.008605050147287059, 0.11103437159861648],
  [1.00001110343716, -0.008605050147287059, -0.11103437159861648],
  [1.0000320633910054, 0.56004913547279, -0.3206339100541203]
];
var LMStoXYZ_M$1 = [
  [2.0701800566956137, -1.326456876103021, 0.20661600684785517],
  [0.3649882500326575, 0.6804673628522352, -0.04542175307585323],
  [-0.04959554223893211, -0.04942116118675749, 1.1879959417328034]
];
var ictcp = new ColorSpace({
  id: "ictcp",
  name: "ICTCP",
  // From BT.2100-2 page 7:
  // During production, signal values are expected to exceed the
  // range E = [0.0 : 1.0]. This provides processing headroom and avoids
  // signal degradation during cascaded processing. Such values of E,
  // below 0.0 or exceeding 1.0, should not be clipped during production
  // and exchange.
  // Values below 0.0 should not be clipped in reference displays (even
  // though they represent negative light) to allow the black level of
  // the signal (LB) to be properly set using test signals known as PLUGE
  coords: {
    i: {
      refRange: [0, 1],
      // Constant luminance,
      name: "I"
    },
    ct: {
      refRange: [-0.5, 0.5],
      // Full BT.2020 gamut in range [-0.5, 0.5]
      name: "CT"
    },
    cp: {
      refRange: [-0.5, 0.5],
      name: "CP"
    }
  },
  base: XYZ_Abs_D65,
  fromBase(XYZ) {
    let LMS = multiplyMatrices(XYZtoLMS_M$1, XYZ);
    return LMStoICtCp(LMS);
  },
  toBase(ICtCp) {
    let LMS = ICtCptoLMS(ICtCp);
    return multiplyMatrices(LMStoXYZ_M$1, LMS);
  },
  formats: {
    color: {}
  }
});
function LMStoICtCp(LMS) {
  let PQLMS = LMS.map(function(val) {
    let num = c1$1 + c2$1 * (val / 1e4) ** m1;
    let denom = 1 + c3$1 * (val / 1e4) ** m1;
    return (num / denom) ** m22;
  });
  return multiplyMatrices(LMStoIPT_M, PQLMS);
}
function ICtCptoLMS(ICtCp) {
  let PQLMS = multiplyMatrices(IPTtoLMS_M, ICtCp);
  let LMS = PQLMS.map(function(val) {
    let num = Math.max(val ** im2 - c1$1, 0);
    let denom = c2$1 - c3$1 * val ** im2;
    return 1e4 * (num / denom) ** im1;
  });
  return LMS;
}
function deltaEITP(color3, sample) {
  let [I1, T1, P1] = ictcp.from(color3);
  let [I22, T22, P22] = ictcp.from(sample);
  return 720 * Math.sqrt((I1 - I22) ** 2 + 0.25 * (T1 - T22) ** 2 + (P1 - P22) ** 2);
}
var XYZtoLMS_M = [
  [0.8190224432164319, 0.3619062562801221, -0.12887378261216414],
  [0.0329836671980271, 0.9292868468965546, 0.03614466816999844],
  [0.048177199566046255, 0.26423952494422764, 0.6335478258136937]
];
var LMStoXYZ_M = [
  [1.2268798733741557, -0.5578149965554813, 0.28139105017721583],
  [-0.04057576262431372, 1.1122868293970594, -0.07171106666151701],
  [-0.07637294974672142, -0.4214933239627914, 1.5869240244272418]
];
var LMStoLab_M = [
  [0.2104542553, 0.793617785, -0.0040720468],
  [1.9779984951, -2.428592205, 0.4505937099],
  [0.0259040371, 0.7827717662, -0.808675766]
];
var LabtoLMS_M = [
  [0.9999999984505198, 0.39633779217376786, 0.2158037580607588],
  [1.0000000088817609, -0.10556134232365635, -0.06385417477170591],
  [1.0000000546724108, -0.08948418209496575, -1.2914855378640917]
];
var OKLab = new ColorSpace({
  id: "oklab",
  name: "Oklab",
  coords: {
    l: {
      refRange: [0, 1],
      name: "L"
    },
    a: {
      refRange: [-0.4, 0.4]
    },
    b: {
      refRange: [-0.4, 0.4]
    }
  },
  // Note that XYZ is relative to D65
  white: "D65",
  base: XYZ_D65,
  fromBase(XYZ) {
    let LMS = multiplyMatrices(XYZtoLMS_M, XYZ);
    let LMSg = LMS.map((val) => Math.cbrt(val));
    return multiplyMatrices(LMStoLab_M, LMSg);
  },
  toBase(OKLab2) {
    let LMSg = multiplyMatrices(LabtoLMS_M, OKLab2);
    let LMS = LMSg.map((val) => val ** 3);
    return multiplyMatrices(LMStoXYZ_M, LMS);
  },
  formats: {
    "oklab": {
      coords: ["<percentage> | <number>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});
function deltaEOK(color3, sample) {
  let [L1, a1, b1] = OKLab.from(color3);
  let [L22, a22, b22] = OKLab.from(sample);
  let \u0394L = L1 - L22;
  let \u0394a = a1 - a22;
  let \u0394b = b1 - b22;
  return Math.sqrt(\u0394L ** 2 + \u0394a ** 2 + \u0394b ** 2);
}
var deltaEMethods = {
  deltaE76,
  deltaECMC,
  deltaE2000,
  deltaEJz,
  deltaEITP,
  deltaEOK
};
function deltaE(c12, c23, o8 = {}) {
  if (isString(o8)) {
    o8 = { method: o8 };
  }
  let { method = defaults7.deltaE, ...rest } = o8;
  c12 = getColor(c12);
  c23 = getColor(c23);
  for (let m5 in deltaEMethods) {
    if ("deltae" + method.toLowerCase() === m5.toLowerCase()) {
      return deltaEMethods[m5](c12, c23, rest);
    }
  }
  throw new TypeError(`Unknown deltaE method: ${method}`);
}
function lighten2(color3, amount = 0.25) {
  let space = ColorSpace.get("oklch", "lch");
  let lightness = [space, "l"];
  return set3(color3, lightness, (l7) => l7 * (1 + amount));
}
function darken2(color3, amount = 0.25) {
  let space = ColorSpace.get("oklch", "lch");
  let lightness = [space, "l"];
  return set3(color3, lightness, (l7) => l7 * (1 - amount));
}
var variations = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  darken: darken2,
  lighten: lighten2
});
function mix(c12, c23, p5 = 0.5, o8 = {}) {
  [c12, c23] = [getColor(c12), getColor(c23)];
  if (type2(p5) === "object") {
    [p5, o8] = [0.5, p5];
  }
  let { space, outputSpace, premultiplied } = o8;
  let r6 = range3(c12, c23, { space, outputSpace, premultiplied });
  return r6(p5);
}
function steps(c12, c23, options = {}) {
  let colorRange;
  if (isRange(c12)) {
    [colorRange, options] = [c12, c23];
    [c12, c23] = colorRange.rangeArgs.colors;
  }
  let {
    maxDeltaE,
    deltaEMethod,
    steps: steps2 = 2,
    maxSteps = 1e3,
    ...rangeOptions
  } = options;
  if (!colorRange) {
    [c12, c23] = [getColor(c12), getColor(c23)];
    colorRange = range3(c12, c23, rangeOptions);
  }
  let totalDelta = deltaE(c12, c23);
  let actualSteps = maxDeltaE > 0 ? Math.max(steps2, Math.ceil(totalDelta / maxDeltaE) + 1) : steps2;
  let ret = [];
  if (maxSteps !== void 0) {
    actualSteps = Math.min(actualSteps, maxSteps);
  }
  if (actualSteps === 1) {
    ret = [{ p: 0.5, color: colorRange(0.5) }];
  } else {
    let step = 1 / (actualSteps - 1);
    ret = Array.from({ length: actualSteps }, (_4, i6) => {
      let p5 = i6 * step;
      return { p: p5, color: colorRange(p5) };
    });
  }
  if (maxDeltaE > 0) {
    let maxDelta = ret.reduce((acc, cur, i6) => {
      if (i6 === 0) {
        return 0;
      }
      let \u0394\u0395 = deltaE(cur.color, ret[i6 - 1].color, deltaEMethod);
      return Math.max(acc, \u0394\u0395);
    }, 0);
    while (maxDelta > maxDeltaE) {
      maxDelta = 0;
      for (let i6 = 1; i6 < ret.length && ret.length < maxSteps; i6++) {
        let prev = ret[i6 - 1];
        let cur = ret[i6];
        let p5 = (cur.p + prev.p) / 2;
        let color3 = colorRange(p5);
        maxDelta = Math.max(maxDelta, deltaE(color3, prev.color), deltaE(color3, cur.color));
        ret.splice(i6, 0, { p: p5, color: colorRange(p5) });
        i6++;
      }
    }
  }
  ret = ret.map((a7) => a7.color);
  return ret;
}
function range3(color1, color22, options = {}) {
  if (isRange(color1)) {
    let [r6, options2] = [color1, color22];
    return range3(...r6.rangeArgs.colors, { ...r6.rangeArgs.options, ...options2 });
  }
  let { space, outputSpace, progression, premultiplied } = options;
  color1 = getColor(color1);
  color22 = getColor(color22);
  color1 = clone2(color1);
  color22 = clone2(color22);
  let rangeArgs = { colors: [color1, color22], options };
  if (space) {
    space = ColorSpace.get(space);
  } else {
    space = ColorSpace.registry[defaults7.interpolationSpace] || color1.space;
  }
  outputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;
  color1 = to(color1, space);
  color22 = to(color22, space);
  color1 = toGamut(color1);
  color22 = toGamut(color22);
  if (space.coords.h && space.coords.h.type === "angle") {
    let arc = options.hue = options.hue || "shorter";
    let hue2 = [space, "h"];
    let [\u03B81, \u03B82] = [get6(color1, hue2), get6(color22, hue2)];
    [\u03B81, \u03B82] = adjust(arc, [\u03B81, \u03B82]);
    set3(color1, hue2, \u03B81);
    set3(color22, hue2, \u03B82);
  }
  if (premultiplied) {
    color1.coords = color1.coords.map((c9) => c9 * color1.alpha);
    color22.coords = color22.coords.map((c9) => c9 * color22.alpha);
  }
  return Object.assign((p5) => {
    p5 = progression ? progression(p5) : p5;
    let coords = color1.coords.map((start2, i6) => {
      let end = color22.coords[i6];
      return interpolate(start2, end, p5);
    });
    let alpha = interpolate(color1.alpha, color22.alpha, p5);
    let ret = { space, coords, alpha };
    if (premultiplied) {
      ret.coords = ret.coords.map((c9) => c9 / alpha);
    }
    if (outputSpace !== space) {
      ret = to(ret, outputSpace);
    }
    return ret;
  }, {
    rangeArgs
  });
}
function isRange(val) {
  return type2(val) === "function" && !!val.rangeArgs;
}
defaults7.interpolationSpace = "lab";
function register(Color3) {
  Color3.defineFunction("mix", mix, { returns: "color" });
  Color3.defineFunction("range", range3, { returns: "function<color>" });
  Color3.defineFunction("steps", steps, { returns: "array<color>" });
}
var interpolation = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isRange,
  mix,
  range: range3,
  register,
  steps
});
var HSL = new ColorSpace({
  id: "hsl",
  name: "HSL",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    l: {
      range: [0, 100],
      name: "Lightness"
    }
  },
  base: sRGB,
  // Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB
  fromBase: (rgb2) => {
    let max4 = Math.max(...rgb2);
    let min4 = Math.min(...rgb2);
    let [r6, g6, b5] = rgb2;
    let [h5, s8, l7] = [NaN, 0, (min4 + max4) / 2];
    let d6 = max4 - min4;
    if (d6 !== 0) {
      s8 = l7 === 0 || l7 === 1 ? 0 : (max4 - l7) / Math.min(l7, 1 - l7);
      switch (max4) {
        case r6:
          h5 = (g6 - b5) / d6 + (g6 < b5 ? 6 : 0);
          break;
        case g6:
          h5 = (b5 - r6) / d6 + 2;
          break;
        case b5:
          h5 = (r6 - g6) / d6 + 4;
      }
      h5 = h5 * 60;
    }
    return [h5, s8 * 100, l7 * 100];
  },
  // Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative
  toBase: (hsl3) => {
    let [h5, s8, l7] = hsl3;
    h5 = h5 % 360;
    if (h5 < 0) {
      h5 += 360;
    }
    s8 /= 100;
    l7 /= 100;
    function f4(n9) {
      let k6 = (n9 + h5 / 30) % 12;
      let a7 = s8 * Math.min(l7, 1 - l7);
      return l7 - a7 * Math.max(-1, Math.min(k6 - 3, 9 - k6, 1));
    }
    return [f4(0), f4(8), f4(4)];
  },
  formats: {
    "hsl": {
      toGamut: true,
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"]
    },
    "hsla": {
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
      commas: true,
      lastAlpha: true
    }
  }
});
var HSV = new ColorSpace({
  id: "hsv",
  name: "HSV",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    v: {
      range: [0, 100],
      name: "Value"
    }
  },
  base: HSL,
  // https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion
  fromBase(hsl3) {
    let [h5, s8, l7] = hsl3;
    s8 /= 100;
    l7 /= 100;
    let v4 = l7 + s8 * Math.min(l7, 1 - l7);
    return [
      h5,
      // h is the same
      v4 === 0 ? 0 : 200 * (1 - l7 / v4),
      // s
      100 * v4
    ];
  },
  // https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion
  toBase(hsv) {
    let [h5, s8, v4] = hsv;
    s8 /= 100;
    v4 /= 100;
    let l7 = v4 * (1 - s8 / 2);
    return [
      h5,
      // h is the same
      l7 === 0 || l7 === 1 ? 0 : (v4 - l7) / Math.min(l7, 1 - l7) * 100,
      l7 * 100
    ];
  },
  formats: {
    color: {
      toGamut: true
    }
  }
});
var hwb = new ColorSpace({
  id: "hwb",
  name: "HWB",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    w: {
      range: [0, 100],
      name: "Whiteness"
    },
    b: {
      range: [0, 100],
      name: "Blackness"
    }
  },
  base: HSV,
  fromBase(hsv) {
    let [h5, s8, v4] = hsv;
    return [h5, v4 * (100 - s8) / 100, 100 - v4];
  },
  toBase(hwb2) {
    let [h5, w5, b5] = hwb2;
    w5 /= 100;
    b5 /= 100;
    let sum2 = w5 + b5;
    if (sum2 >= 1) {
      let gray2 = w5 / sum2;
      return [h5, 0, gray2 * 100];
    }
    let v4 = 1 - b5;
    let s8 = v4 === 0 ? 0 : 1 - w5 / v4;
    return [h5, s8 * 100, v4 * 100];
  },
  formats: {
    "hwb": {
      toGamut: true,
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"]
    }
  }
});
var toXYZ_M$2 = [
  [0.5766690429101305, 0.1855582379065463, 0.1882286462349947],
  [0.29734497525053605, 0.6273635662554661, 0.07529145849399788],
  [0.02703136138641234, 0.07068885253582723, 0.9913375368376388]
];
var fromXYZ_M$2 = [
  [2.0415879038107465, -0.5650069742788596, -0.34473135077832956],
  [-0.9692436362808795, 1.8759675015077202, 0.04155505740717557],
  [0.013444280632031142, -0.11836239223101838, 1.0151749943912054]
];
var A98Linear = new RGBColorSpace({
  id: "a98rgb-linear",
  name: "Linear Adobe\xAE 98 RGB compatible",
  white: "D65",
  toXYZ_M: toXYZ_M$2,
  fromXYZ_M: fromXYZ_M$2
});
var a98rgb = new RGBColorSpace({
  id: "a98rgb",
  name: "Adobe\xAE 98 RGB compatible",
  base: A98Linear,
  toBase: (RGB) => RGB.map((val) => Math.pow(Math.abs(val), 563 / 256) * Math.sign(val)),
  fromBase: (RGB) => RGB.map((val) => Math.pow(Math.abs(val), 256 / 563) * Math.sign(val)),
  formats: {
    color: {
      id: "a98-rgb"
    }
  }
});
var toXYZ_M$1 = [
  [0.7977604896723027, 0.13518583717574031, 0.0313493495815248],
  [0.2880711282292934, 0.7118432178101014, 8565396060525902e-20],
  [0, 0, 0.8251046025104601]
];
var fromXYZ_M$1 = [
  [1.3457989731028281, -0.25558010007997534, -0.05110628506753401],
  [-0.5446224939028347, 1.5082327413132781, 0.02053603239147973],
  [0, 0, 1.2119675456389454]
];
var ProPhotoLinear = new RGBColorSpace({
  id: "prophoto-linear",
  name: "Linear ProPhoto",
  white: "D50",
  base: XYZ_D50,
  toXYZ_M: toXYZ_M$1,
  fromXYZ_M: fromXYZ_M$1
});
var Et = 1 / 512;
var Et2 = 16 / 512;
var prophoto = new RGBColorSpace({
  id: "prophoto",
  name: "ProPhoto",
  base: ProPhotoLinear,
  toBase(RGB) {
    return RGB.map((v4) => v4 < Et2 ? v4 / 16 : v4 ** 1.8);
  },
  fromBase(RGB) {
    return RGB.map((v4) => v4 >= Et ? v4 ** (1 / 1.8) : 16 * v4);
  },
  formats: {
    color: {
      id: "prophoto-rgb"
    }
  }
});
var oklch = new ColorSpace({
  id: "oklch",
  name: "Oklch",
  coords: {
    l: {
      refRange: [0, 1],
      name: "Lightness"
    },
    c: {
      refRange: [0, 0.4],
      name: "Chroma"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  white: "D65",
  base: OKLab,
  fromBase(oklab) {
    let [L4, a7, b5] = oklab;
    let h5;
    const \u03B52 = 2e-4;
    if (Math.abs(a7) < \u03B52 && Math.abs(b5) < \u03B52) {
      h5 = NaN;
    } else {
      h5 = Math.atan2(b5, a7) * 180 / Math.PI;
    }
    return [
      L4,
      // OKLab L is still L
      Math.sqrt(a7 ** 2 + b5 ** 2),
      // Chroma
      constrain(h5)
      // Hue, in degrees [0 to 360)
    ];
  },
  // Convert from polar form
  toBase(oklch2) {
    let [L4, C5, h5] = oklch2;
    let a7, b5;
    if (isNaN(h5)) {
      a7 = 0;
      b5 = 0;
    } else {
      a7 = C5 * Math.cos(h5 * Math.PI / 180);
      b5 = C5 * Math.sin(h5 * Math.PI / 180);
    }
    return [L4, a7, b5];
  },
  formats: {
    "oklch": {
      coords: ["<number> | <percentage>", "<number> | <percentage>[0,1]", "<number> | <angle>"]
    }
  }
});
var Yw = 203;
var n8 = 2610 / 2 ** 14;
var ninv = 2 ** 14 / 2610;
var m4 = 2523 / 2 ** 5;
var minv = 2 ** 5 / 2523;
var c1 = 3424 / 2 ** 12;
var c22 = 2413 / 2 ** 7;
var c32 = 2392 / 2 ** 7;
var rec2100Pq = new RGBColorSpace({
  id: "rec2100pq",
  name: "REC.2100-PQ",
  base: REC2020Linear,
  toBase(RGB) {
    return RGB.map(function(val) {
      let x6 = (Math.max(val ** minv - c1, 0) / (c22 - c32 * val ** minv)) ** ninv;
      return x6 * 1e4 / Yw;
    });
  },
  fromBase(RGB) {
    return RGB.map(function(val) {
      let x6 = Math.max(val * Yw / 1e4, 0);
      let num = c1 + c22 * x6 ** n8;
      let denom = 1 + c32 * x6 ** n8;
      return (num / denom) ** m4;
    });
  },
  formats: {
    color: {
      id: "rec2100-pq"
    }
  }
});
var a6 = 0.17883277;
var b4 = 0.28466892;
var c8 = 0.55991073;
var scale = 3.7743;
var rec2100Hlg = new RGBColorSpace({
  id: "rec2100hlg",
  cssid: "rec2100-hlg",
  name: "REC.2100-HLG",
  referred: "scene",
  base: REC2020Linear,
  toBase(RGB) {
    return RGB.map(function(val) {
      if (val <= 0.5) {
        return val ** 2 / 3 * scale;
      }
      return (Math.exp((val - c8) / a6) + b4) / 12 * scale;
    });
  },
  fromBase(RGB) {
    return RGB.map(function(val) {
      val /= scale;
      if (val <= 1 / 12) {
        return Math.sqrt(3 * val);
      }
      return a6 * Math.log(12 * val - b4) + c8;
    });
  },
  formats: {
    color: {
      id: "rec2100-hlg"
    }
  }
});
var CATs = {};
hooks.add("chromatic-adaptation-start", (env) => {
  if (env.options.method) {
    env.M = adapt(env.W1, env.W2, env.options.method);
  }
});
hooks.add("chromatic-adaptation-end", (env) => {
  if (!env.M) {
    env.M = adapt(env.W1, env.W2, env.options.method);
  }
});
function defineCAT({ id: id2, toCone_M, fromCone_M }) {
  CATs[id2] = arguments[0];
}
function adapt(W1, W2, id2 = "Bradford") {
  let method = CATs[id2];
  let [\u03C1s, \u03B3s, \u03B2s] = multiplyMatrices(method.toCone_M, W1);
  let [\u03C1d, \u03B3d, \u03B2d] = multiplyMatrices(method.toCone_M, W2);
  let scale2 = [
    [\u03C1d / \u03C1s, 0, 0],
    [0, \u03B3d / \u03B3s, 0],
    [0, 0, \u03B2d / \u03B2s]
  ];
  let scaled_cone_M = multiplyMatrices(scale2, method.toCone_M);
  let adapt_M = multiplyMatrices(method.fromCone_M, scaled_cone_M);
  return adapt_M;
}
defineCAT({
  id: "von Kries",
  toCone_M: [
    [0.40024, 0.7076, -0.08081],
    [-0.2263, 1.16532, 0.0457],
    [0, 0, 0.91822]
  ],
  fromCone_M: [
    [1.8599364, -1.1293816, 0.2198974],
    [0.3611914, 0.6388125, -64e-7],
    [0, 0, 1.0890636]
  ]
});
defineCAT({
  id: "Bradford",
  // Convert an array of XYZ values in the range 0.0 - 1.0
  // to cone fundamentals
  toCone_M: [
    [0.8951, 0.2664, -0.1614],
    [-0.7502, 1.7135, 0.0367],
    [0.0389, -0.0685, 1.0296]
  ],
  // and back
  fromCone_M: [
    [0.9869929, -0.1470543, 0.1599627],
    [0.4323053, 0.5183603, 0.0492912],
    [-85287e-7, 0.0400428, 0.9684867]
  ]
});
defineCAT({
  id: "CAT02",
  // with complete chromatic adaptation to W2, so D = 1.0
  toCone_M: [
    [0.7328, 0.4296, -0.1624],
    [-0.7036, 1.6975, 61e-4],
    [3e-3, 0.0136, 0.9834]
  ],
  fromCone_M: [
    [1.0961238, -0.278869, 0.1827452],
    [0.454369, 0.4735332, 0.0720978],
    [-96276e-7, -5698e-6, 1.0153256]
  ]
});
defineCAT({
  id: "CAT16",
  toCone_M: [
    [0.401288, 0.650173, -0.051461],
    [-0.250268, 1.204414, 0.045854],
    [-2079e-6, 0.048952, 0.953127]
  ],
  // the extra precision is needed to avoid roundtripping errors
  fromCone_M: [
    [1.862067855087233, -1.011254630531685, 0.1491867754444518],
    [0.3875265432361372, 0.6214474419314753, -0.008973985167612518],
    [-0.01584149884933386, -0.03412293802851557, 1.04996443687785]
  ]
});
Object.assign(WHITES, {
  // whitepoint values from ASTM E308-01 with 10nm spacing, 1931 2 degree observer
  // all normalized to Y (luminance) = 1.00000
  // Illuminant A is a tungsten electric light, giving a very warm, orange light.
  A: [1.0985, 1, 0.35585],
  // Illuminant C was an early approximation to daylight: illuminant A with a blue filter.
  C: [0.98074, 1, 1.18232],
  // The daylight series of illuminants simulate natural daylight.
  // The color temperature (in degrees Kelvin/100) ranges from
  // cool, overcast daylight (D50) to bright, direct sunlight (D65).
  D55: [0.95682, 1, 0.92149],
  D75: [0.94972, 1, 1.22638],
  // Equal-energy illuminant, used in two-stage CAT16
  E: [1, 1, 1],
  // The F series of illuminants represent fluorescent lights
  F2: [0.99186, 1, 0.67393],
  F7: [0.95041, 1, 1.08747],
  F11: [1.00962, 1, 0.6435]
});
WHITES.ACES = [0.32168 / 0.33767, 1, (1 - 0.32168 - 0.33767) / 0.33767];
var toXYZ_M = [
  [0.6624541811085053, 0.13400420645643313, 0.1561876870049078],
  [0.27222871678091454, 0.6740817658111484, 0.05368951740793705],
  [-0.005574649490394108, 0.004060733528982826, 1.0103391003129971]
];
var fromXYZ_M = [
  [1.6410233796943257, -0.32480329418479, -0.23642469523761225],
  [-0.6636628587229829, 1.6153315916573379, 0.016756347685530137],
  [0.011721894328375376, -0.008284441996237409, 0.9883948585390215]
];
var ACEScg = new RGBColorSpace({
  id: "acescg",
  name: "ACEScg",
  // ACEScg  A scene-referred, linear-light encoding of ACES Data
  // https://docs.acescentral.com/specifications/acescg/
  // uses the AP1 primaries, see section 4.3.1 Color primaries
  coords: {
    r: {
      range: [0, 65504],
      name: "Red"
    },
    g: {
      range: [0, 65504],
      name: "Green"
    },
    b: {
      range: [0, 65504],
      name: "Blue"
    }
  },
  referred: "scene",
  white: WHITES.ACES,
  toXYZ_M,
  fromXYZ_M,
  formats: {
    color: {}
  }
});
var \u03B5 = 2 ** -16;
var ACES_min_nonzero = -0.35828683;
var ACES_cc_max = (Math.log2(65504) + 9.72) / 17.52;
var acescc = new RGBColorSpace({
  id: "acescc",
  name: "ACEScc",
  // see S-2014-003 ACEScc  A Logarithmic Encoding of ACES Data
  // https://docs.acescentral.com/specifications/acescc/
  // uses the AP1 primaries, see section 4.3.1 Color primaries
  // Appendix A: "Very small ACES scene referred values below 7 1/4 stops
  // below 18% middle gray are encoded as negative ACEScc values.
  // These values should be preserved per the encoding in Section 4.4
  // so that all positive ACES values are maintained."
  coords: {
    r: {
      range: [ACES_min_nonzero, ACES_cc_max],
      name: "Red"
    },
    g: {
      range: [ACES_min_nonzero, ACES_cc_max],
      name: "Green"
    },
    b: {
      range: [ACES_min_nonzero, ACES_cc_max],
      name: "Blue"
    }
  },
  referred: "scene",
  base: ACEScg,
  // from section 4.4.2 Decoding Function
  toBase(RGB) {
    const low = (9.72 - 15) / 17.52;
    return RGB.map(function(val) {
      if (val <= low) {
        return (2 ** (val * 17.52 - 9.72) - \u03B5) * 2;
      } else if (val < ACES_cc_max) {
        return 2 ** (val * 17.52 - 9.72);
      } else {
        return 65504;
      }
    });
  },
  // Non-linear encoding function from S-2014-003, section 4.4.1 Encoding Function
  fromBase(RGB) {
    return RGB.map(function(val) {
      if (val <= 0) {
        return (Math.log2(\u03B5) + 9.72) / 17.52;
      } else if (val < \u03B5) {
        return (Math.log2(\u03B5 + val * 0.5) + 9.72) / 17.52;
      } else {
        return (Math.log2(val) + 9.72) / 17.52;
      }
    });
  },
  // encoded media white (rgb 1,1,1) => linear  [ 222.861, 222.861, 222.861 ]
  // encoded media black (rgb 0,0,0) => linear [ 0.0011857, 0.0011857, 0.0011857]
  formats: {
    color: {}
  }
});
var spaces = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  A98RGB: a98rgb,
  A98RGB_Linear: A98Linear,
  ACEScc: acescc,
  ACEScg,
  HSL,
  HSV,
  HWB: hwb,
  ICTCP: ictcp,
  JzCzHz: jzczhz,
  Jzazbz,
  LCH: lch2,
  Lab: lab3,
  Lab_D65: lab_d65,
  OKLCH: oklch,
  OKLab,
  P3: P32,
  P3_Linear: P3Linear,
  ProPhoto: prophoto,
  ProPhoto_Linear: ProPhotoLinear,
  REC_2020: REC2020,
  REC_2020_Linear: REC2020Linear,
  REC_2100_HLG: rec2100Hlg,
  REC_2100_PQ: rec2100Pq,
  XYZ_ABS_D65: XYZ_Abs_D65,
  XYZ_D50,
  XYZ_D65,
  sRGB,
  sRGB_Linear: sRGBLinear
});
var Color2 = class _Color {
  /**
   * Creates an instance of Color.
   * Signatures:
   * - `new Color(stringToParse)`
   * - `new Color(otherColor)`
   * - `new Color({space, coords, alpha})`
   * - `new Color(space, coords, alpha)`
   * - `new Color(spaceId, coords, alpha)`
   */
  constructor(...args) {
    let color3;
    if (args.length === 1) {
      color3 = getColor(args[0]);
    }
    let space, coords, alpha;
    if (color3) {
      space = color3.space || color3.spaceId;
      coords = color3.coords;
      alpha = color3.alpha;
    } else {
      [space, coords, alpha] = args;
    }
    Object.defineProperty(this, "space", {
      value: ColorSpace.get(space),
      writable: false,
      enumerable: true,
      configurable: true
      // see note in https://262.ecma-international.org/8.0/#sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver
    });
    this.coords = coords ? coords.slice() : [0, 0, 0];
    this.alpha = alpha < 1 ? alpha : 1;
    for (let i6 = 0; i6 < this.coords.length; i6++) {
      if (this.coords[i6] === "NaN") {
        this.coords[i6] = NaN;
      }
    }
    for (let id2 in this.space.coords) {
      Object.defineProperty(this, id2, {
        get: () => this.get(id2),
        set: (value) => this.set(id2, value)
      });
    }
  }
  get spaceId() {
    return this.space.id;
  }
  clone() {
    return new _Color(this.space, this.coords, this.alpha);
  }
  toJSON() {
    return {
      spaceId: this.spaceId,
      coords: this.coords,
      alpha: this.alpha
    };
  }
  display(...args) {
    let ret = display(this, ...args);
    ret.color = new _Color(ret.color);
    return ret;
  }
  /**
   * Get a color from the argument passed
   * Basically gets us the same result as new Color(color) but doesn't clone an existing color object
   */
  static get(color3, ...args) {
    if (color3 instanceof _Color) {
      return color3;
    }
    return new _Color(color3, ...args);
  }
  static defineFunction(name, code, o8 = code) {
    let { instance = true, returns } = o8;
    let func = function(...args) {
      let ret = code(...args);
      if (returns === "color") {
        ret = _Color.get(ret);
      } else if (returns === "function<color>") {
        let f4 = ret;
        ret = function(...args2) {
          let ret2 = f4(...args2);
          return _Color.get(ret2);
        };
        Object.assign(ret, f4);
      } else if (returns === "array<color>") {
        ret = ret.map((c9) => _Color.get(c9));
      }
      return ret;
    };
    if (!(name in _Color)) {
      _Color[name] = func;
    }
    if (instance) {
      _Color.prototype[name] = function(...args) {
        return func(this, ...args);
      };
    }
  }
  static defineFunctions(o8) {
    for (let name in o8) {
      _Color.defineFunction(name, o8[name], o8[name]);
    }
  }
  static extend(exports2) {
    if (exports2.register) {
      exports2.register(_Color);
    } else {
      for (let name in exports2) {
        _Color.defineFunction(name, exports2[name]);
      }
    }
  }
};
Color2.defineFunctions({
  get: get6,
  getAll,
  set: set3,
  setAll,
  to,
  equals,
  inGamut,
  toGamut,
  distance,
  toString: serialize
});
Object.assign(Color2, {
  util,
  hooks,
  WHITES,
  Space: ColorSpace,
  spaces: ColorSpace.registry,
  parse: parse2,
  // Global defaults one may want to configure
  defaults: defaults7
});
for (let key of Object.keys(spaces)) {
  ColorSpace.register(spaces[key]);
}
for (let id2 in ColorSpace.registry) {
  addSpaceAccessors(id2, ColorSpace.registry[id2]);
}
hooks.add("colorspace-init-end", (space) => {
  addSpaceAccessors(space.id, space);
  space.aliases?.forEach((alias) => {
    addSpaceAccessors(alias, space);
  });
});
function addSpaceAccessors(id2, space) {
  Object.keys(space.coords);
  Object.values(space.coords).map((c9) => c9.name);
  let propId = id2.replace(/-/g, "_");
  Object.defineProperty(Color2.prototype, propId, {
    // Convert coords to coords in another colorspace and return them
    // Source colorspace: this.spaceId
    // Target colorspace: id
    get() {
      let ret = this.getAll(id2);
      if (typeof Proxy === "undefined") {
        return ret;
      }
      return new Proxy(ret, {
        has: (obj, property2) => {
          try {
            ColorSpace.resolveCoord([space, property2]);
            return true;
          } catch (e9) {
          }
          return Reflect.has(obj, property2);
        },
        get: (obj, property2, receiver) => {
          if (property2 && typeof property2 !== "symbol" && !(property2 in obj)) {
            let { index: index2 } = ColorSpace.resolveCoord([space, property2]);
            if (index2 >= 0) {
              return obj[index2];
            }
          }
          return Reflect.get(obj, property2, receiver);
        },
        set: (obj, property2, value, receiver) => {
          if (property2 && typeof property2 !== "symbol" && !(property2 in obj) || property2 >= 0) {
            let { index: index2 } = ColorSpace.resolveCoord([space, property2]);
            if (index2 >= 0) {
              obj[index2] = value;
              this.setAll(id2, obj);
              return true;
            }
          }
          return Reflect.set(obj, property2, value, receiver);
        }
      });
    },
    // Convert coords in another colorspace to internal coords and set them
    // Target colorspace: this.spaceId
    // Source colorspace: id
    set(coords) {
      this.setAll(id2, coords);
    },
    configurable: true,
    enumerable: true
  });
}
Color2.extend(deltaEMethods);
Color2.extend({ deltaE });
Object.assign(Color2, { deltaEMethods });
Color2.extend(variations);
Color2.extend({ contrast });
Color2.extend(chromaticity);
Color2.extend(luminance);
Color2.extend(interpolation);
Color2.extend(contrastMethods);

// src/value_box.ts
var ValueBox = class extends s4 {
  constructor() {
    super(...arguments);
    this.value = "";
    this.bg = "brand";
    this.textColor = "";
    this.icon = "gg:chart";
    this.title = "";
    this.subtitle = "";
    this.subvalue = "";
  }
  updated() {
    console.log("Value box initialized");
    this.style.setProperty("--bg-color", validateBgColor(this.bg));
    this.style.setProperty(
      "--text-color",
      this.textColor !== "" ? this.textColor : this.decideTextColor(this.bg)
    );
  }
  decideTextColor(bgColor) {
    let color3 = null;
    const variableValue = sanatizeCssVarName(bgColor);
    if (variableValue) {
      const variableColor = this.getVariableColor(variableValue);
      console.log({ variableValue, variableColor });
      color3 = new Color2(variableColor);
    }
    try {
      color3 = new Color2(bgColor);
    } catch (e9) {
      console.warn("Could not parse color", e9);
    }
    if (!color3) {
      return lightText;
    }
    const lightTextContrast = color3.contrastWCAG21(new Color2(lightText));
    const darkTextContrast = color3.contrastWCAG21(new Color2(darkText));
    console.log("Contrast decision", {
      color: this.bg,
      lightTextContrast,
      darkTextContrast
    });
    return lightTextContrast > darkTextContrast ? lightText : darkText;
  }
  getVariableColor(variable) {
    const computedStyle = getComputedStyle(this);
    return computedStyle.getPropertyValue(variable);
  }
  render() {
    return x`
      <div class="title">
        <div class="main">
          <slot name="title">${this.title}</slot>
        </div>
        <div class="subtitle">
          <slot name="subtitle">${this.subtitle}</slot>
        </div>
      </div>
      <div class="value">
        <div class="main">
          <slot name="value">${sanatizeValue(this.value)}</slot>
        </div>
        <div class="subvalue">
          <slot name="subvalue">${this.subvalue}</slot>
        </div>
      </div>
      <div class="icon">
        <slot name="icon">
          <shiny-icon name=${this.icon}></shiny-icon>
        </slot>
      </div>
    `;
  }
};
ValueBox.styles = [
  i`
      :host {
        --bg-color: var(--surface-1);
        --text-color: var(--text-1);

        height: 100%;
        max-height: 200px;
        min-height: 100px;
        max-width: 400px;
        background-color: var(--bg-color);
        color: var(--text-color);
        padding: var(--size-m);
        border-radius: var(--radius-m);
        box-shadow: var(--shadow-m);
        display: grid;
        gap: var(--size-s);
        grid-template-areas:
          "title icon"
          "value icon";
      }

      .title {
        grid-area: title;
      }

      .title .main {
        font-size: var(--font-size-l);
        font-weight: var(--font-weight-bold);
      }

      .value {
        grid-area: value;
      }

      .value .main {
        font-size: var(--font-size-h1);
        font-family: var(--font-mono);
      }

      .subvalue {
        margin-top: calc(-1 * var(--size-xs));
      }

      .subtitle,
      .subvalue {
        font-size: var(--font-size-m);
        opacity: 0.8;
        font-style: italic;
      }

      .icon {
        grid-area: icon;
        font-size: var(--size-xl);
        display: grid;
        place-content: center;
      }
    `
];
__decorateClass([
  n6({ reflect: true })
], ValueBox.prototype, "value", 2);
__decorateClass([
  n6({ type: String })
], ValueBox.prototype, "bg", 2);
__decorateClass([
  n6({ type: String })
], ValueBox.prototype, "textColor", 2);
__decorateClass([
  n6({ type: String })
], ValueBox.prototype, "icon", 2);
__decorateClass([
  n6({ type: String })
], ValueBox.prototype, "title", 2);
__decorateClass([
  n6({ type: String })
], ValueBox.prototype, "subtitle", 2);
__decorateClass([
  n6({ type: String })
], ValueBox.prototype, "subvalue", 2);
ValueBox = __decorateClass([
  e6("value-box")
], ValueBox);
function validateBgColor(value) {
  const unwrappedCssVarName = sanatizeCssVarName(value);
  if (unwrappedCssVarName) {
    return `var(${unwrappedCssVarName})`;
  }
  return value;
}
function sanatizeCssVarName(value) {
  const validOPColors = new Set(
    [
      "Stone",
      "Red",
      "Pink",
      "Purple",
      "Violet",
      "Indigo",
      "Blue",
      "Cyan",
      "Teal",
      "Green",
      "Lime",
      "Yellow",
      "Orange",
      "Choco",
      "Brown",
      "Sand",
      "Camo",
      "Jungle"
    ].map((color3) => color3.toLowerCase())
  );
  if (validOPColors.has(value.toLowerCase())) {
    return `--${value.toLowerCase()}-8`;
  }
  if (value.startsWith("var(--") && value.endsWith(")")) {
    return value.slice(4, -1);
  }
  if (value.startsWith("--")) {
    return value;
  }
  return null;
}
function sanatizeValue(value) {
  const numberValue = Number(value);
  if (!isNaN(numberValue)) {
    return numberValue.toFixed(2);
  }
  return value;
}
var lightText = "#f1f3f5";
var darkText = "#212529";
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

iconify-icon/dist/iconify-icon.mjs:
  (**
  * (c) Iconify
  *
  * For the full copyright and license information, please view the license.txt
  * files at https://github.com/iconify/iconify
  *
  * Licensed under MIT.
  *
  * @license MIT
  * @version 1.0.7
  *)
*/
//# sourceMappingURL=components.js.map
